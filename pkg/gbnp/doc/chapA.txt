  
  [1XA. Examples[0X
  
  
  [1XA.1 Introduction[0X
  
  In this chapter all available commented examples can be found. Those without
  comments  are in the directory [11Xgbnp/examples[0m. Timing results are obtained on
  an  Intel  Pentium  4  3.00GHz  processor  running  Linux (2.6.28-15-generic
  #49-Ubuntu  SMP  Tue  Aug 18 18:40:08 UTC 2009 i686 GNU/Linux) and using GAP
  4.4.10.
  
  --    [14XA.2[0m [14X'A simple commutative GrÃ¶bner basis computation'[0m
  
  --    [14XA.3[0m [14X'A truncated GrÃ¶bner basis for Leonard pairs'[0m
  
  --    [14XA.4[0m [14X'The truncated variant on two weighted homogeneous polynomials'[0m
  
  --    [14XA.5[0m [14X'The order of the Weyl group of type E_6'[0m
  
  --    [14XA.6[0m [14X'The gcd of some univariate polynomials'[0m
  
  --    [14XA.7[0m [14X'From the Tapas book'[0m
  
  --    [14XA.8[0m [14X'The Birman-Murakami-Wenzl algebra of type A_3'[0m
  
  --    [14XA.9[0m [14X'The Birman-Murakami-Wenzl algebra of type A_2'[0m
  
  --    [14XA.10[0m [14X'A commutative example by Mora'[0m
  
  --    [14XA.11[0m [14X'Tracing an example by Mora'[0m
  
  --    [14XA.12[0m [14X'Finiteness of the Weyl group of type E_6'[0m
  
        This extends Example [14XA.5[0m.
  
  --    [14XA.13[0m [14X'Preprocessing for Weyl group computations'[0m
  
        This extends two earlier examples [14XA.5[0m and [14XA.12[0m.
  
  --    [14XA.14[0m [14X'A quotient algebra with exponential growth'[0m
  
  --    [14XA.15[0m [14X'A commutative quotient algebra of polynomial growth'[0m
  
        This extends Example [14XA.7[0m.
  
  --    [14XA.16[0m [14X'An algebra over a finite field'[0m
  
  --    [14XA.17[0m [14X'The dihedral group of order 8'[0m
  
  --    [14XA.18[0m [14X'The dihedral group of order 8 on another module'[0m
  
        This extends Example [14XA.17[0m.
  
  --    [14XA.19[0m [14X'The dihedral group on a non-cyclic module'[0m
  
        This example also extends Example [14XA.17[0m.
  
  --    [14XA.20[0m [14X'The icosahedral group'[0m
  
  --    [14XA.21[0m [14X'The symmetric inverse monoid for a set of size four'[0m
  
  --    [14XA.22[0m [14X'A module of the Hecke algebra of type A_3 over GF(3)'[0m
  
  --    [14XA.23[0m [14X'Generalized Temperley-Lieb algebras'[0m
  
  --    [14XA.24[0m [14X'The universal enveloping algebra of a Lie algebra'[0m
  
  --    [14XA.25[0m [14X'Serre's exercise'[0m
  
  --    [14XA.26[0m [14X'Baur and Draisma's transformations'[0m
  
  --    [14XA.27[0m [14X'The cola gene puzzle'[0m
  
  
  [1XA.2 A simple commutative GrÃ¶bner basis computation[0X
  
  In  this  commutative  example  the  relations are x^2y-1 and xy^2-1; we add
  xy-yx  to  enforce  that  x  and y commute. The answer should be x^3-1, x-y,
  xy-yx,   as   the   reduction  ordering  is  total  degree  first  and  then
  lexicographic with x smaller than y.
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 2
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 1 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,2);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[0X
  [4X------------------------------------------------------------------[0X
  
  Then input the relations in NP format (see Section [14X2.1[0m). They will be put in
  the list [10XLnp[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> Lnp := [ [[[1,2],[2,1]],[1,-1]]   ];[0X
    [4X[ [ [ [ 1, 2 ], [ 2, 1 ] ], [ 1, -1 ] ] ][0X
    [4Xgap> x2y := [[[1,1,2],[]],[1,-1]];[0X
    [4X[ [ [ 1, 1, 2 ], [  ] ], [ 1, -1 ] ][0X
    [4Xgap>     AddSet(Lnp,x2y);   [0X
    [4Xgap> xy2 := [[[1,2,2],[]],[1,-1]];[0X
    [4X[ [ [ 1, 2, 2 ], [  ] ], [ 1, -1 ] ][0X
    [4Xgap>     AddSet(Lnp,xy2);[0X
  [4X------------------------------------------------------------------[0X
  
  The relations can be exhibited with [2XPrintNPList[0m ([14X3.2-3[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(Lnp);[0X
    [4X a^2b - 1 [0X
    [4X ab - ba [0X
    [4X ab^2 - 1 [0X
  [4X------------------------------------------------------------------[0X
  
  Let  the  variables  be  printed  as  x and y instead of a and b by means of
  [2XGBNP.ConfigPrint[0m ([14X3.2-2[0m)
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBNP.ConfigPrint("x","y");[0X
  [4X------------------------------------------------------------------[0X
  
  The GrÃ¶bner basis can now be calculated with [2XSGrobner[0m ([14X3.4-2[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB := SGrobner(Lnp);[0X
    [4X#I  number of entered polynomials is 3[0X
    [4X#I  number of polynomials after reduction is 3[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  length of G =1[0X
    [4X#I  length of todo is 1[0X
    [4X#I  length of G =2[0X
    [4X#I  length of todo is 0[0X
    [4X#I  List of todo lengths is [ 1, 1, 0 ][0X
    [4X#I  End of phase III[0X
    [4X#I  G: Cleaning finished, 0 polynomials reduced[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 8 msecs.[0X
    [4X[ [ [ [ 2 ], [ 1 ] ], [ 1, -1 ] ], [ [ [ 1, 1, 1 ], [  ] ], [ 1, -1 ] ] ][0X
  [4X------------------------------------------------------------------[0X
  
  When printed, it looks like:
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(GB);[0X
    [4X y - x [0X
    [4X x^3 - 1 [0X
  [4X------------------------------------------------------------------[0X
  
  The  dimension of the quotient algebra can be calculated with [2XDimQA[0m ([14X3.5-2[0m).
  The arguments are the GrÃ¶bner basis [10XGB[0m and the number of variables is [10X2[0m:
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> DimQA(GB,2);[0X
    [4X3[0X
  [4X------------------------------------------------------------------[0X
  
  A  basis of this quotient algebra can be calculated with [2XBaseQA[0m ([14X3.5-1[0m). The
  arguments  are  a  GrÃ¶bner  basis  [10XGB[0m,  the number of variables [3Xt[0m (=2) and a
  variable [3Xmaxno[0m for returning partial quotient algebras (0 means full basis).
  The calculated basis will be printed as well.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> B:=BaseQA(GB,2,0);;[0X
    [4Xgap> PrintNPList(B);[0X
    [4X 1 [0X
    [4X x [0X
    [4X x^2 [0X
  [4X------------------------------------------------------------------[0X
  
  The  strong  normal  form  of  the  element  xyxyxyx  can be found by use of
  [2XStrongNormalFormNP[0m  ([14X3.5-6[0m).  The arguments are this element and the GrÃ¶bner
  basis [10XGB[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> f:=[[[1,2,1,2,1,2,1]],[1]];;[0X
    [4Xgap> PrintNP(f);[0X
    [4X xyxyxyx [0X
    [4Xgap> p:=StrongNormalFormNP(f,GB);;[0X
    [4Xgap> PrintNP(p);[0X
    [4X x [0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.3 A truncated GrÃ¶bner basis for Leonard pairs[0X
  
  To  provide  Terwilliger  with  experimental  dimension  information  in low
  degrees   for  his  theory  of  Leonard  pairs  a  truncated  GrÃ¶bner  basis
  computation was carried out as follows.
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 1
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 2 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,2);[0X
  [4X------------------------------------------------------------------[0X
  
  We truncate the example by putting all monomials of degree n in the ideal by
  means  of  the  function  [10XMkTrLst[0m  to  be  introduced below; a better way to
  compute the result is by means of the truncated GB algorithms (See [14XA.24[0m).
  
  We want to truncate at degree 7 so we have fixed n = 8.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> n := 8;;[0X
  [4X------------------------------------------------------------------[0X
  
  Now  enter  the relations in NP form (see [14X2.1[0m). The function [10XMkTrLst[0m will be
  introduced,  which  will return all monomials of degree [10Xn[0m. The list of ideal
  generators of interest is called [10XI[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> sqbr := function(n,q) ; return (q^3-q^-3)/(q-q^(-1)); end;;[0X
    [4X[0X
    [4Xgap> c := sqbr(3,5);[0X
    [4X651/25[0X
    [4X[0X
    [4Xgap> s1 :=[[[1,1,1,2],[1,1,2,1],[1,2,1,1],[2,1,1,1]],[1,-c,c,-1]];;[0X
    [4Xgap> s2 :=[[[2,2,2,1],[2,2,1,2],[2,1,2,2],[1,2,2,2]],[1,-c,c,-1]];;[0X
    [4X[0X
    [4Xgap> MkTrLst := function(l) local ans, h1, h2, a, i;[0X
    [4X>    ans := [[1],[2]];[0X
    [4X>    for i in [2..l] do[0X
    [4X>       h1 := [];[0X
    [4X>       h2 := [];[0X
    [4X>       for a in ans do[0X
    [4X>         Add(h1,Concatenation([1],a));[0X
    [4X>         Add(h2,Concatenation([2],a));[0X
    [4X>       od;[0X
    [4X>       ans := Concatenation(h1,h2);[0X
    [4X>    od;[0X
    [4X>    return List(ans, a -> [[a],[1]]);[0X
    [4X> end;;[0X
    [4X[0X
    [4Xgap> I := Concatenation([s1,s2],MkTrLst(n));;[0X
  [4X------------------------------------------------------------------[0X
  
  To give an impression, we print the first 20 entries of this list:
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(I{[1..20]});[0X
    [4X a^3b - 651/25a^2ba + 651/25aba^2 - ba^3 [0X
    [4X b^3a - 651/25b^2ab + 651/25bab^2 - ab^3 [0X
    [4X a^8 [0X
    [4X a^7b [0X
    [4X a^6ba [0X
    [4X a^6b^2 [0X
    [4X a^5ba^2 [0X
    [4X a^5bab [0X
    [4X a^5b^2a [0X
    [4X a^5b^3 [0X
    [4X a^4ba^3 [0X
    [4X a^4ba^2b [0X
    [4X a^4baba [0X
    [4X a^4bab^2 [0X
    [4X a^4b^2a^2 [0X
    [4X a^4b^2ab [0X
    [4X a^4b^3a [0X
    [4X a^4b^4 [0X
    [4X a^3ba^4 [0X
    [4X a^3ba^3b [0X
  [4X------------------------------------------------------------------[0X
  
  We calculate the GrÃ¶bner basis with [2XSGrobner[0m ([14X3.4-2[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB := SGrobner(I);;[0X
    [4X#I  number of entered polynomials is 258[0X
    [4X#I  number of polynomials after reduction is 114[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  End of phase III[0X
    [4X#I  Time needed to clean G :0[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 232 msecs.[0X
  [4X------------------------------------------------------------------[0X
  
  Now print the first part of the GrÃ¶bner basis with [2XPrintNPList[0m ([14X3.2-3[0m) (only
  the  first  20  polynomials  are printed here, the full GrÃ¶bner basis can be
  printed with [10XPrintNPList(GB)[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(GB{[1..20]});[0X
    [4X ba^3 - 651/25aba^2 + 651/25a^2ba - a^3b [0X
    [4X b^3a - 651/25b^2ab + 651/25bab^2 - ab^3 [0X
    [4X b^2a^2ba - bab^2a^2 - baba^2b + ba^2bab + ab^2aba - abab^2a - aba^2b^2 + a^2b\[0X
    [4X^2ab [0X
    [4X b^2ab^2a^2 - 651/25b^2ababa + b^2aba^2b + 626/25bab^2aba - bab^2a^2b + babab^\[0X
    [4X2a - ba^2b^2ab + ba^2bab^2 - 651/25ab^2ab^2a + ab^2abab + 423176/625abab^2ab -\[0X
    [4X 423801/625ababab^2 + 626/25aba^2b^3 - 406901/625a^2b^2ab^2 + 423176/625a^2bab\[0X
    [4X^3 - 651/25a^3b^4 [0X
    [4X a^8 [0X
    [4X a^7b [0X
    [4X a^6ba [0X
    [4X a^6b^2 [0X
    [4X a^5ba^2 [0X
    [4X a^5bab [0X
    [4X a^5b^2a [0X
    [4X a^5b^3 [0X
    [4X a^4ba^2b [0X
    [4X a^4baba [0X
    [4X a^4bab^2 [0X
    [4X a^4b^2a^2 [0X
    [4X a^4b^2ab [0X
    [4X a^4b^4 [0X
    [4X a^3ba^2ba [0X
    [4X a^3ba^2b^2 [0X
  [4X------------------------------------------------------------------[0X
  
  The  truncated  quotient  algebra  is  obtained  by  factoring out the ideal
  generated  by  the  GrÃ¶bner  basis [10XGB[0m and so its dimension can be calculated
  with [2XDimQA[0m ([14X3.5-2[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> DimQA(GB,2);[0X
    [4X#I  The computation took 0 msecs.[0X
    [4X157[0X
  [4X------------------------------------------------------------------[0X
  
  Here  is  what Paul Terwilliger wrote in reaction to the computation carried
  out by this example:
  
  I  just  wanted  to  thank you again for the dimension data that you gave me
  after  the  Durham  meeting.  It  ended  up  having  a large impact. See the
  attached paper; joint with Tatsuro Ito.
  
  I  spent  several weeks in Japan this past January, working with Tatsuro and
  trying  to  find  a good basis for the algebra on two symbols subject to the
  q-Serre  relations.  After much frustration, we thought of feeding your data
  into  Sloane's  online  handbook  of  integer  sequences.  We  did it out of
  curiosity  more  than  anything;  we  did not expect the handbook data to be
  particularly useful. But it was.
  
  The  handbook  told  us that the graded dimension generating function, using
  your  data for the coefficients, matched the q-series for the inverse of the
  Jacobi  theta function vartheta_4; armed with this overwhelming hint we were
  able to prove that the graded dimension generating function was indeed given
  by  the  inverse  of  vartheta_4.  With that info we were able to get a nice
  result about td pairs.
  
  Paul
  
  
  [1XA.4 The truncated variant on two weighted homogeneous polynomials[0X
  
  Here  we  exhibit  a  truncated non-commutative homogeneous weighted GrÃ¶bner
  basis  computation.  This  example  uses the functions from Section [14X3.8[0m, the
  truncation variants (see also Section [14X2.6[0m).
  
  The input is a set of polynomials in x and y, which are homogeneous when the
  weight    of    x    is    2    and    of    y    is   3.   The   input   is
  x^3y^2-x^6+y^4,y^2x^3+xyxyx+x^2yxy.  We  truncate  the computation at degree
  16.          The          truncated         GrÃ¶bner         basis         is
  y^2x^3+xyxyx+x^2yxy,x^6-x^3y^2-y^4,x^3y^2x-x^4y^2-xy^4  and the dimension of
  the quotient algebra is 134.
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 1
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 1 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[0X
  [4X------------------------------------------------------------------[0X
  
  The variables will be printed as x and y.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBNP.ConfigPrint("x","y");[0X
  [4X------------------------------------------------------------------[0X
  
  The level to truncate at is assigned to n.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> n := 16;;[0X
  [4X------------------------------------------------------------------[0X
  
  Now enter the relations in NP form (see Section [14X2.1[0m) and the weights.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> s1 :=[[[1,1,1,2,2],[1,1,1,1,1,1],[2,2,2,2]],[1,-1,1]];;[0X
    [4Xgap> s2 :=[[[2,2,1,1,1],[1,2,1,2,1],[1,1,2,1,2]],[1,1,1]];;[0X
    [4Xgap> K := [s1,s2];;[0X
    [4Xgap> weights:=[2,3];;[0X
  [4X------------------------------------------------------------------[0X
  
  The input can be printed with [2XPrintNPList[0m ([14X3.2-3[0m)
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(K);[0X
    [4X x^3y^2 - x^6 + y^4 [0X
    [4X y^2x^3 + xyxyx + x^2yxy [0X
  [4X------------------------------------------------------------------[0X
  
  Verify  whether the list [10XK[0m consists only of polynomials that are homogeneous
  with respect to [10Xweights[0m by means of [2XCheckHomogeneousNPs[0m ([14X3.8-3[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> CheckHomogeneousNPs(K,weights);[0X
    [4X#I  Input is homogeneous[0X
    [4X[ 12, 12 ][0X
  [4X------------------------------------------------------------------[0X
  
  Now  calculate  the  truncated GrÃ¶bner basis with [2XSGrobnerTrunc[0m ([14X3.8-2[0m). The
  output will only contain homogeneous polynomials of degree at most [10Xn[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> G := SGrobnerTrunc(K,n,weights);;[0X
    [4X#I  number of entered polynomials is 2[0X
    [4X#I  number of polynomials after reduction is 2[0X
    [4X#I  End of phase I[0X
    [4X#I  Input is homogeneous[0X
    [4X#I  Reached level 16[0X
    [4X#I  end of the algorithm[0X
    [4X#I  The computation took 8 msecs.[0X
  [4X------------------------------------------------------------------[0X
  
  The  GrÃ¶bner  basis  of  the  truncated quotient algebra can be printed with
  [2XPrintNPList[0m ([14X3.2-3[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(G);[0X
    [4X y^2x^3 + xyxyx + x^2yxy [0X
    [4X x^6 - x^3y^2 - y^4 [0X
    [4X x^3y^2x - x^4y^2 + y^4x - xy^4 [0X
  [4X------------------------------------------------------------------[0X
  
  The  standard  basis of the quotient of the free noncommutative algebra on n
  variables,  where  n is the length of the vector [10Xweights[0m, by the homogeneous
  ideal  generated  by  [10XK[0m  up to degree n is obtained by means of the function
  [2XBaseQATrunc[0m ([14X3.8-4[0m) applied to [10XK[0m, [10Xn[0m, and [10Xweights[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> B := BaseQATrunc(K,n,weights);;[0X
    [4X#I  number of entered polynomials is 2[0X
    [4X#I  number of polynomials after reduction is 2[0X
    [4X#I  End of phase I[0X
    [4X#I  Input is homogeneous[0X
    [4X#I  Reached level 16[0X
    [4X#I  end of the algorithm[0X
    [4X#I  The computation took 4 msecs.[0X
    [4Xgap> i := Length(B);[0X
    [4X17[0X
    [4Xgap> Print("at level ",i-1," the standard monomials are:\n");[0X
    [4Xat level 16 the standard monomials are:[0X
    [4Xgap> PrintNPList(List(B[i], qq -> [[qq],[1]]));[0X
    [4X yxyx^4 [0X
    [4X yx^2yx^3 [0X
    [4X xyxyx^3 [0X
    [4X yx^3yx^2 [0X
    [4X xyx^2yx^2 [0X
    [4X x^2yxyx^2 [0X
    [4X y^4x^2 [0X
    [4X yx^4yx [0X
    [4X xyx^3yx [0X
    [4X x^2yx^2yx [0X
    [4X x^3yxyx [0X
    [4X y^3xyx [0X
    [4X y^2xy^2x [0X
    [4X yxy^3x [0X
    [4X xy^4x [0X
    [4X yx^5y [0X
    [4X xyx^4y [0X
    [4X x^2yx^3y [0X
    [4X x^3yx^2y [0X
    [4X y^3x^2y [0X
    [4X x^4yxy [0X
    [4X y^2xyxy [0X
    [4X yxy^2xy [0X
    [4X xy^3xy [0X
    [4X x^5y^2 [0X
    [4X y^2x^2y^2 [0X
    [4X yxyxy^2 [0X
    [4X xy^2xy^2 [0X
    [4X yx^2y^3 [0X
    [4X xyxy^3 [0X
    [4X x^2y^4 [0X
  [4X------------------------------------------------------------------[0X
  
  The  same  result can be obtained by using the truncated GrÃ¶bner basis found
  for [10XG[0m instead of [10XK[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> B2 := BaseQATrunc(G,n,weights);;[0X
    [4X#I  number of entered polynomials is 3[0X
    [4X#I  number of polynomials after reduction is 3[0X
    [4X#I  End of phase I[0X
    [4X#I  Input is homogeneous[0X
    [4X#I  Reached level 16[0X
    [4X#I  end of the algorithm[0X
    [4X#I  The computation took 4 msecs.[0X
    [4Xgap> B = B2;[0X
    [4Xtrue[0X
  [4X------------------------------------------------------------------[0X
  
  Also,  the  same  result  can  be obtained by using the leading terms of the
  truncated GrÃ¶bner basis found for [10XG[0m instead of [10XK[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> B3 := BaseQATrunc(List( LMonsNP(G), qq -> [[qq],[1]]),n,weights);;[0X
    [4X#I  number of entered polynomials is 3[0X
    [4X#I  number of polynomials after reduction is 3[0X
    [4X#I  End of phase I[0X
    [4X#I  Input is homogeneous[0X
    [4X#I  Reached level 16[0X
    [4X#I  end of the algorithm[0X
    [4X#I  The computation took 0 msecs.[0X
    [4Xgap> B = B3;[0X
    [4Xtrue[0X
  [4X------------------------------------------------------------------[0X
  
  A  list of dimensions of the homogeneous parts of the quotient algebra up to
  degree  n  is  obtained by means of [2XDimsQATrunc[0m ([14X3.8-5[0m) with arguments [10XG[0m, [10Xn[0m,
  and [10Xweights[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> DimsQATrunc(G,n,weights);[0X
    [4X#I  number of entered polynomials is 3[0X
    [4X#I  number of polynomials after reduction is 3[0X
    [4X#I  End of phase I[0X
    [4X#I  Input is homogeneous[0X
    [4X#I  Reached level 16[0X
    [4X#I  end of the algorithm[0X
    [4X#I  The computation took 4 msecs.[0X
    [4X[ 1, 0, 1, 1, 1, 2, 2, 3, 4, 5, 7, 9, 10, 16, 17, 24, 31 ][0X
  [4X------------------------------------------------------------------[0X
  
  Even  more  detailed  information  is  given by the list of frequences up to
  degree  [10Xn[0m.  This is obtained by means of [2XFreqsQATrunc[0m ([14X3.8-6[0m) with arguments
  [10XG[0m, [10Xn[0m, and [10Xweights[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> FreqsQATrunc(G,n,weights);[0X
    [4X#I  number of entered polynomials is 3[0X
    [4X#I  number of polynomials after reduction is 3[0X
    [4X#I  End of phase I[0X
    [4X#I  Input is homogeneous[0X
    [4X#I  Reached level 16[0X
    [4X#I  end of the algorithm[0X
    [4X#I  The computation took 0 msecs.[0X
    [4X[ [ [ [  ], 1 ] ], [ [ [ 1, 0 ], 1 ] ], [ [ [ 0, 1 ], 1 ] ], [0X
    [4X  [ [ [ 2, 0 ], 1 ] ], [ [ [ 1, 1 ], 2 ] ], [0X
    [4X  [ [ [ 3, 0 ], 1 ], [ [ 0, 2 ], 1 ] ], [ [ [ 2, 1 ], 3 ] ], [0X
    [4X  [ [ [ 4, 0 ], 1 ], [ [ 1, 2 ], 3 ] ], [ [ [ 3, 1 ], 4 ], [ [ 0, 3 ], 1 ] ], [0X
    [4X  [ [ [ 5, 0 ], 1 ], [ [ 2, 2 ], 6 ] ], [ [ [ 4, 1 ], 5 ], [ [ 1, 3 ], 4 ] ], [0X
    [4X  [ [ [ 3, 2 ], 9 ], [ [ 0, 4 ], 1 ] ], [ [ [ 5, 1 ], 6 ], [ [ 2, 3 ], 10 ] ],[0X
    [4X  [ [ [ 4, 2 ], 12 ], [ [ 1, 4 ], 5 ] ], [0X
    [4X  [ [ [ 6, 1 ], 5 ], [ [ 3, 3 ], 18 ], [ [ 0, 5 ], 1 ] ], [0X
    [4X  [ [ [ 5, 2 ], 16 ], [ [ 2, 4 ], 15 ] ] ][0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.5 The order of the Weyl group of type E_6[0X
  
  In  order  to show how the order of a finite group of manageable size with a
  manageable  presentation can be computed, we determine the order of the Weyl
  group of type E_6. This number is well known to be 51840.
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 1
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 2 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,2);[0X
  [4X------------------------------------------------------------------[0X
  
  Then  input  the  relations  in  NP  format  (see  [14X2.1[0m).  They come from the
  presentation of the Weyl group as a Coxeter group. This means that there are
  six variables, one for each generator. We let the corresponding variables be
  printed as r_1, ..., r_6 by means of [2XGBNP.ConfigPrint[0m ([14X3.2-2[0m)
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBNP.ConfigPrint(6,"r");[0X
  [4X------------------------------------------------------------------[0X
  
  The  relations are binomial and represent the group relations, which express
  that  the  generators  are  involutions (that is, have order 2) and that the
  orders  of  the  products  of any two generators is specified by the Coxeter
  diagram  (see any book on Coxeter groups for details). The relations will be
  assigned to [10XKI[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> k1 := [[[1,3,1],[3,1,3]],[1,-1]];;[0X
    [4Xgap> k2 := [[[4,3,4],[3,4,3]],[1,-1]];;[0X
    [4Xgap> k3 := [[[4,2,4],[2,4,2]],[1,-1]];;[0X
    [4Xgap> k4 := [[[4,5,4],[5,4,5]],[1,-1]];;[0X
    [4Xgap> k5 := [[[6,5,6],[5,6,5]],[1,-1]];;[0X
    [4Xgap> k6 := [[[1,2],[2,1]],[1,-1]];;[0X
    [4Xgap> k7 := [[[1,4],[4,1]],[1,-1]];;[0X
    [4Xgap> k8 := [[[1,5],[5,1]],[1,-1]];;[0X
    [4Xgap> k9 := [[[1,6],[6,1]],[1,-1]];;[0X
    [4Xgap> k10 := [[[2,3],[3,2]],[1,-1]];;[0X
    [4Xgap> k11 := [[[2,5],[5,2]],[1,-1]];;[0X
    [4Xgap> k12 := [[[2,6],[6,2]],[1,-1]];;[0X
    [4Xgap> k13 := [[[3,5],[5,3]],[1,-1]];;[0X
    [4Xgap> k14 := [[[3,6],[6,3]],[1,-1]];;[0X
    [4Xgap> k15 := [[[4,6],[6,4]],[1,-1]];;[0X
    [4Xgap> k16 := [[[1,1],[]],[1,-1]];;[0X
    [4Xgap> k17 := [[[2,2],[]],[1,-1]];;[0X
    [4Xgap> k18 := [[[3,3],[]],[1,-1]];;[0X
    [4Xgap> k19 := [[[4,4],[]],[1,-1]];;[0X
    [4Xgap> k20 := [[[5,5],[]],[1,-1]];;[0X
    [4Xgap> k21 := [[[6,6],[]],[1,-1]];;[0X
    [4Xgap> KI := [k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,[0X
    [4X>        k11,k12,k13,k14,k15,k16,k17,k18,k19,k20,k21[0X
    [4X>       ];;[0X
  [4X------------------------------------------------------------------[0X
  
  The relations can be shown with [2XPrintNPList[0m ([14X3.2-3[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(KI);[0X
    [4X r.1r.3r.1 - r.3r.1r.3 [0X
    [4X r.4r.3r.4 - r.3r.4r.3 [0X
    [4X r.4r.2r.4 - r.2r.4r.2 [0X
    [4X r.4r.5r.4 - r.5r.4r.5 [0X
    [4X r.6r.5r.6 - r.5r.6r.5 [0X
    [4X r.1r.2 - r.2r.1 [0X
    [4X r.1r.4 - r.4r.1 [0X
    [4X r.1r.5 - r.5r.1 [0X
    [4X r.1r.6 - r.6r.1 [0X
    [4X r.2r.3 - r.3r.2 [0X
    [4X r.2r.5 - r.5r.2 [0X
    [4X r.2r.6 - r.6r.2 [0X
    [4X r.3r.5 - r.5r.3 [0X
    [4X r.3r.6 - r.6r.3 [0X
    [4X r.4r.6 - r.6r.4 [0X
    [4X r.1^2 - 1 [0X
    [4X r.2^2 - 1 [0X
    [4X r.3^2 - 1 [0X
    [4X r.4^2 - 1 [0X
    [4X r.5^2 - 1 [0X
    [4X r.6^2 - 1 [0X
  [4X------------------------------------------------------------------[0X
  
  The GrÃ¶bner basis can now be calculated with [2XSGrobner[0m ([14X3.4-2[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB := SGrobner(KI);;[0X
    [4X#I  number of entered polynomials is 21[0X
    [4X#I  number of polynomials after reduction is 21[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  End of phase III[0X
    [4X#I  Time needed to clean G :0[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 220 msecs.[0X
    [4Xgap> PrintNPList(GB);[0X
    [4X r.1^2 - 1 [0X
    [4X r.2r.1 - r.1r.2 [0X
    [4X r.2^2 - 1 [0X
    [4X r.3r.2 - r.2r.3 [0X
    [4X r.3^2 - 1 [0X
    [4X r.4r.1 - r.1r.4 [0X
    [4X r.4^2 - 1 [0X
    [4X r.5r.1 - r.1r.5 [0X
    [4X r.5r.2 - r.2r.5 [0X
    [4X r.5r.3 - r.3r.5 [0X
    [4X r.5^2 - 1 [0X
    [4X r.6r.1 - r.1r.6 [0X
    [4X r.6r.2 - r.2r.6 [0X
    [4X r.6r.3 - r.3r.6 [0X
    [4X r.6r.4 - r.4r.6 [0X
    [4X r.6^2 - 1 [0X
    [4X r.3r.1r.2 - r.2r.3r.1 [0X
    [4X r.3r.1r.3 - r.1r.3r.1 [0X
    [4X r.4r.2r.4 - r.2r.4r.2 [0X
    [4X r.4r.3r.4 - r.3r.4r.3 [0X
    [4X r.5r.4r.5 - r.4r.5r.4 [0X
    [4X r.6r.5r.6 - r.5r.6r.5 [0X
    [4X r.4r.3r.1r.4 - r.3r.4r.3r.1 [0X
    [4X r.5r.4r.2r.5 - r.4r.5r.4r.2 [0X
    [4X r.5r.4r.3r.5 - r.4r.5r.4r.3 [0X
    [4X r.6r.5r.4r.6 - r.5r.6r.5r.4 [0X
    [4X r.4r.2r.3r.4r.2 - r.3r.4r.2r.3r.4 [0X
    [4X r.4r.2r.3r.4r.3 - r.2r.4r.2r.3r.4 [0X
    [4X r.5r.4r.2r.3r.5 - r.4r.5r.4r.2r.3 [0X
    [4X r.5r.4r.3r.1r.5 - r.4r.5r.4r.3r.1 [0X
    [4X r.6r.5r.4r.2r.6 - r.5r.6r.5r.4r.2 [0X
    [4X r.6r.5r.4r.3r.6 - r.5r.6r.5r.4r.3 [0X
    [4X r.4r.2r.3r.1r.4r.2 - r.3r.4r.2r.3r.1r.4 [0X
    [4X r.5r.4r.2r.3r.1r.5 - r.4r.5r.4r.2r.3r.1 [0X
    [4X r.6r.5r.4r.2r.3r.6 - r.5r.6r.5r.4r.2r.3 [0X
    [4X r.6r.5r.4r.3r.1r.6 - r.5r.6r.5r.4r.3r.1 [0X
    [4X r.4r.2r.3r.1r.4r.3r.1 - r.2r.4r.2r.3r.1r.4r.3 [0X
    [4X r.5r.4r.2r.3r.4r.5r.4 - r.4r.5r.4r.2r.3r.4r.5 [0X
    [4X r.6r.5r.4r.2r.3r.1r.6 - r.5r.6r.5r.4r.2r.3r.1 [0X
    [4X r.6r.5r.4r.2r.3r.4r.6 - r.5r.6r.5r.4r.2r.3r.4 [0X
    [4X r.5r.4r.2r.3r.1r.4r.5r.4 - r.4r.5r.4r.2r.3r.1r.4r.5 [0X
    [4X r.6r.5r.4r.2r.3r.1r.4r.6 - r.5r.6r.5r.4r.2r.3r.1r.4 [0X
    [4X r.6r.5r.4r.2r.3r.1r.4r.3r.6 - r.5r.6r.5r.4r.2r.3r.1r.4r.3 [0X
    [4X r.6r.5r.4r.2r.3r.4r.5r.6r.5 - r.5r.6r.5r.4r.2r.3r.4r.5r.6 [0X
    [4X r.5r.4r.2r.3r.1r.4r.3r.5r.4r.3 - r.4r.5r.4r.2r.3r.1r.4r.3r.5r.4 [0X
    [4X r.6r.5r.4r.2r.3r.1r.4r.5r.6r.5 - r.5r.6r.5r.4r.2r.3r.1r.4r.5r.6 [0X
    [4X r.5r.4r.2r.3r.1r.4r.3r.5r.4r.2r.3 - r.4r.5r.4r.2r.3r.1r.4r.3r.5r.4r.2 [0X
    [4X r.6r.5r.4r.2r.3r.1r.4r.3r.5r.6r.5 - r.5r.6r.5r.4r.2r.3r.1r.4r.3r.5r.6 [0X
    [4X r.6r.5r.4r.2r.3r.1r.4r.3r.5r.4r.6r.5r.4 - r.5r.6r.5r.4r.2r.3r.1r.4r.3r.5r.4r.\[0X
    [4X6r.5 [0X
    [4X r.6r.5r.4r.2r.3r.1r.4r.3r.5r.4r.2r.6r.5r.4r.2 - r.5r.6r.5r.4r.2r.3r.1r.4r.3r.\[0X
    [4X5r.4r.2r.6r.5r.4 [0X
  [4X------------------------------------------------------------------[0X
  
  The  base  of  the  quotient  algebra can be calculated with [2XBaseQA[0m ([14X3.5-1[0m),
  which  has  as  arguments  a  GrÃ¶bner  basis [10XGB[0m, a number of symbols [10X6[0m and a
  maximum terms to be found (here 0 is entered, for a full base) . Since it is
  very long we will not print it here.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> B:=BaseQA(GB,6,0);;[0X
  [4X------------------------------------------------------------------[0X
  
  The  dimension of the quotient algebra can be calculated with [2XDimQA[0m ([14X3.5-2[0m),
  the  arguments  are  the GrÃ¶bner basis [10XGB[0m and the number of symbols [10X6[0m. Since
  [2XInfoGBNPTime[0m  ([14X4.3-1[0m)  is  set  to  2,  we get timing information from [2XDimQA[0m
  ([14X3.5-2[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> DimQA(GB,6);[0X
    [4X#I  The computation took 280 msecs.[0X
    [4X51840[0X
  [4X------------------------------------------------------------------[0X
  
  Note  that  the  calculation  of  the  dimension  takes  almost  as  long as
  calculating  the  base. Since we have already calculated a base [10XB[0m it is much
  more efficient to calculate the dimension with [10XLength[0m:
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> Length(B);[0X
    [4X51840[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.6 The gcd of some univariate polynomials[0X
  
  A  list  of  univariate  polynomials is generated. The result of the GrÃ¶bner
  basis  computation  on  this list should be a single monic polynomial, their
  gcd.
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 2
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 1 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,2);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[0X
  [4X------------------------------------------------------------------[0X
  
  Let the single variable be printed as x by means of [2XGBNP.ConfigPrint[0m ([14X3.2-2[0m)
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBNP.ConfigPrint("x");[0X
  [4X------------------------------------------------------------------[0X
  
  Now input the relations in NP format (see [14X2.1[0m). They will be assigned to [10XKI[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> p0 := [[[1,1,1],[1,1],[1],[]],[1,2,2,1]];;[0X
    [4Xgap> p1 := [[[1,1,1,1],[1,1],[]],[1,1,1]];;[0X
    [4Xgap> KI := [p0,p1];;[0X
    [4X[0X
    [4Xgap> for i in [2..12] do [0X
    [4X>     h := AddNP(AddNP(KI[i],KI[i-1],1,3), [0X
    [4X>     	AddNP(BimulNP([1],KI[i],[]),KI[i-1],2,1),3,-5);[0X
    [4X>     Add(KI,h);[0X
    [4X> od;[0X
  [4X------------------------------------------------------------------[0X
  
  The relations can be shown with [2XPrintNPList[0m ([14X3.2-3[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(KI);[0X
    [4X x^3 + 2x^2 + 2x + 1 [0X
    [4X x^4 + x^2 + 1 [0X
    [4X - 10x^5 + 3x^4 - 6x^3 + 11x^2 - 2x + 7 [0X
    [4X 100x^6 - 60x^5 + 73x^4 - 128x^3 + 57x^2 - 76x + 25 [0X
    [4X - 1000x^7 + 900x^6 - 950x^5 + 1511x^4 - 978x^3 + 975x^2 - 486x + 103 [0X
    [4X 10000x^8 - 12000x^7 + 12600x^6 - 18200x^5 + 14605x^4 - 13196x^3 + 8013x^2 - 2\[0X
    [4X792x + 409 [0X
    [4X - 100000x^9 + 150000x^8 - 166000x^7 + 223400x^6 - 204450x^5 + 181819x^4 - 123\[0X
    [4X630x^3 + 55859x^2 - 14410x + 1639 [0X
    [4X 1000000x^10 - 1800000x^9 + 2150000x^8 - 2780000x^7 + 2765100x^6 - 2504340x^5 \[0X
    [4X+ 1840177x^4 - 982264x^3 + 343729x^2 - 70788x + 6553 [0X
    [4X - 10000000x^11 + 21000000x^10 - 27300000x^9 + 34850000x^8 - 36655000x^7 + 342\[0X
    [4X32300x^6 - 26732590x^5 + 16070447x^4 - 6878602x^3 + 1962503x^2 - 335534x + 262\[0X
    [4X15 [0X
    [4X 100000000x^12 - 240000000x^11 + 340000000x^10 - 437600000x^9 + 479700000x^8 -\[0X
    [4X 463408000x^7 + 381083200x^6 - 250919600x^5 + 124358069x^4 - 44189892x^3 + 106\[0X
    [4X17765x^2 - 1551904x + 104857 [0X
    [4X - 1000000000x^13 + 2700000000x^12 - 4160000000x^11 + 5480000000x^10 - 6219000\[0X
    [4X000x^9 + 6212580000x^8 - 5347676000x^7 + 3789374800x^6 - 2103269850x^5 + 87925\[0X
    [4X4915x^4 - 266261734x^3 + 55222347x^2 - 7046418x + 419431 [0X
    [4X 10000000000x^14 - 30000000000x^13 + 50100000000x^12 - 68240000000x^11 + 79990\[0X
    [4X000000x^10 - 82533200000x^9 + 74033300000x^8 - 55790408000x^7 + 33925155700x^6\[0X
    [4X - 16106037100x^5 + 5797814361x^4 - 1527768240x^3 + 278602281x^2 - 31541180x +\[0X
    [4X 1677721 [0X
    [4X - 100000000000x^15 + 330000000000x^14 - 595000000000x^13 + 843500000000x^12 -\[0X
    [4X 1021260000000x^11 + 1087222000000x^10 - 1012808600000x^9 + 804854300000x^8 - \[0X
    [4X528013485000x^7 + 277993337300x^6 - 114709334310x^5 + 36188145143x^4 - 8434374\[0X
    [4X466x^3 + 1372108031x^2 - 139586422x + 6710887 [0X
    [4Xgap> Length(KI);[0X
    [4X13[0X
  [4X------------------------------------------------------------------[0X
  
  The GrÃ¶bner basis can now be calculated with [2XSGrobner[0m ([14X3.4-2[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB := SGrobner(KI);;[0X
    [4X#I  number of entered polynomials is 13[0X
    [4X#I  number of polynomials after reduction is 1[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  List of todo lengths is [ 0 ][0X
    [4X#I  End of phase III[0X
    [4X#I  G: Cleaning finished, 0 polynomials reduced[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 8 msecs.[0X
  [4X------------------------------------------------------------------[0X
  
  Printed it looks like:
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(GB);[0X
    [4X x^2 + x + 1 [0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.7 From the Tapas book[0X
  
  This  example  is  a standard commutative GrÃ¶bner basis computation from the
  book  Some  Tapas  of  Computer  Algebra  [CCS99],  page  339. There are six
  variables, named a, ... , f by default. We work over the rationals and study
  the  ideal  generated  by  the twelve polynomials occurring on the middle of
  page  339  of  the  Tapas  book in a project by De Boer and Pellikaan on the
  ternary  cyclic  code  of length 11. Below these are named [10Xp1[0m, ..., [10Xp12[0m. The
  result  should  be  the  union of a,b and the set of 6 homogeneous binomials
  (that  is, polynomials with two terms) of degree 2 forcing commuting between
  c, d, e, and f.
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 2
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 1 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,2);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[0X
  [4X------------------------------------------------------------------[0X
  
  Now  define some functions which will help in the construction of relations.
  The  function  [10Xpowermon(g, exp)[0m will return the monomial g^exp. The function
  [10Xcomm(a,  b)[0m  will  return  a  relation forcing commutativity between its two
  arguments [10Xa[0m and [10Xb[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> powermon := function(base, exp)[0X
    [4X>  local ans,i;[0X
    [4X>  ans := [];[0X
    [4X>  for i in [1..exp] do ans :=  Concatenation(ans,[base]); od;[0X
    [4X>  return ans;[0X
    [4X> end;;[0X
    [4X[0X
    [4Xgap> comm := function(a,b)[0X
    [4X>   return [[[a,b],[b,a]],[1,-1]];[0X
    [4X> end;;[0X
  [4X------------------------------------------------------------------[0X
  
  Now the relations are entered.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> p1 := [[[5,1]],[1]];;[0X
    [4Xgap> p2 := [[powermon(1,3),[6,1]],[1,1]];;[0X
    [4Xgap> p3 := [[powermon(1,9),Concatenation([3],powermon(1,3))],[1,1]];;[0X
    [4Xgap> p4 := [[powermon(1,81),Concatenation([3],powermon(1,9)),[0X
    [4X> 	Concatenation([4],powermon(1,3))],[1,1,1]];;[0X
    [4Xgap> p5 := [[Concatenation([3],powermon(1,81)),Concatenation([4],powermon(1,9)),[0X
    [4X> 	Concatenation([5],powermon(1,3))],[1,1,1]];;[0X
    [4Xgap> p6 := [[powermon(1,27),Concatenation([4],powermon(1,81)),Concatenation([5],[0X
    [4X> 	powermon(1,9)),Concatenation([6],powermon(1,3))],[1,1,1,1]];;[0X
    [4Xgap> p7 := [[powermon(2,1),Concatenation([3],powermon(1,27)),Concatenation([5],[0X
    [4X> 	powermon(1,81)),Concatenation([6],powermon(1,9))],[1,1,1,1]];;[0X
    [4Xgap> p8 := [[Concatenation([3],powermon(2,1)),Concatenation([4],powermon(1,27)),[0X
    [4X> 	Concatenation([6],powermon(1,81))],[1,1,1]];;[0X
    [4Xgap> p9 := [[Concatenation([],powermon(1,1)),Concatenation([4],powermon(2,1)),[0X
    [4X> 	Concatenation([5],powermon(1,27))],[1,1,1]];;[0X
    [4Xgap> p10 := [[Concatenation([3],powermon(1,1)),Concatenation([5],powermon(2,1)),[0X
    [4X> 	Concatenation([6],powermon(1,27))],[1,1,1]];;[0X
    [4Xgap> p11 := [[Concatenation([4],powermon(1,1)),Concatenation([6],powermon(2,1))],[0X
    [4X> 	[1,1]];;[0X
    [4Xgap> p12 := [[Concatenation([],powermon(2,3)),Concatenation([],powermon(2,1))],[0X
    [4X> 	[1,-1]];;[0X
    [4Xgap> KI := [p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12];;[0X
    [4Xgap> for i in [1..5] do[0X
    [4X>     for j in [i+1..6] do[0X
    [4X>         Add(KI,comm(i,j));[0X
    [4X>     od;[0X
    [4X> od;[0X
  [4X------------------------------------------------------------------[0X
  
  The relations can be shown with [2XPrintNPList[0m ([14X3.2-3[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(KI);[0X
    [4X ea [0X
    [4X a^3 + fa [0X
    [4X a^9 + ca^3 [0X
    [4X a^81 + ca^9 + da^3 [0X
    [4X ca^81 + da^9 + ea^3 [0X
    [4X a^27 + da^81 + ea^9 + fa^3 [0X
    [4X b + ca^27 + ea^81 + fa^9 [0X
    [4X cb + da^27 + fa^81 [0X
    [4X a + db + ea^27 [0X
    [4X ca + eb + fa^27 [0X
    [4X da + fb [0X
    [4X b^3 - b [0X
    [4X ab - ba [0X
    [4X ac - ca [0X
    [4X ad - da [0X
    [4X ae - ea [0X
    [4X af - fa [0X
    [4X bc - cb [0X
    [4X bd - db [0X
    [4X be - eb [0X
    [4X bf - fb [0X
    [4X cd - dc [0X
    [4X ce - ec [0X
    [4X cf - fc [0X
    [4X de - ed [0X
    [4X df - fd [0X
    [4X ef - fe [0X
    [4Xgap> Length(KI);[0X
    [4X27[0X
  [4X------------------------------------------------------------------[0X
  
  It  is sometimes easier to enter the relations as elements of a free algebra
  and then use the function [2XGP2NP[0m ([14X3.1-1[0m) or the function [2XGP2NPList[0m ([14X3.1-2[0m) to
  convert  them. This will be demonstrated below. More about converting can be
  read in Section [14X3.1[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> F:=Rationals;;[0X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(F,"a","b","c","d","e","f");;[0X
    [4Xgap> a:=A.a;; b:=A.b;; c:=A.c;; d:=A.d;; e:=A.e;; f:=A.f;;[0X
    [4Xgap> KI_gp:=[e*a,                         #p1[0X
    [4X>         a^3 + f*a,                      #p2[0X
    [4X>         a^9 + c*a^3,                    #p3[0X
    [4X>         a^81 + c*a^9 + d*a^3,           #p4[0X
    [4X>         c*a^81 + d*a^9 + e*a^3,         #p5[0X
    [4X>         a^27 + d*a^81 + e*a^9 + f*a^3,  #p6[0X
    [4X>         b + c*a^27 + e*a^81 + f*a^9,    #p7[0X
    [4X>         c*b + d*a^27 + f*a^81,          #p8[0X
    [4X>         a + d*b + e*a^27,               #p9[0X
    [4X>         c*a + e*b + f*a^27,             #p10[0X
    [4X>         d*a + f*b,                      #p11[0X
    [4X>         b^3 - b];;                      #p12[0X
  [4X------------------------------------------------------------------[0X
  
  These  relations  can  be  converted  to  NP  form  (see [14X2.1[0m) with [2XGP2NPList[0m
  ([14X3.1-2[0m).  For  use  in  a  GrÃ¶bner basis computation we have to order the NP
  polynomials in [10XKI[0m. This can be done with [2XCleanNP[0m ([14X3.3-7[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> KI_np:=GP2NPList(KI_gp);;[0X
    [4Xgap> Apply(KI,x->CleanNP(x));;[0X
    [4Xgap> KI_np=KI{[1..12]};[0X
    [4Xtrue[0X
  [4X------------------------------------------------------------------[0X
  
  The  GrÃ¶bner  basis  can now be calculated with [2XSGrobner[0m ([14X3.4-2[0m) and printed
  with [2XPrintNPList[0m ([14X3.2-3[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB := SGrobner(KI);;[0X
    [4X#I  number of entered polynomials is 27[0X
    [4X#I  number of polynomials after reduction is 8[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  List of todo lengths is [ 0 ][0X
    [4X#I  End of phase III[0X
    [4X#I  G: Cleaning finished, 0 polynomials reduced[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 1220 msecs.[0X
    [4Xgap> PrintNPList(GB);[0X
    [4X a [0X
    [4X b [0X
    [4X dc - cd [0X
    [4X ec - ce [0X
    [4X ed - de [0X
    [4X fc - cf [0X
    [4X fd - df [0X
    [4X fe - ef [0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.8 The Birman-Murakami-Wenzl algebra of type A_3[0X
  
  We  study  the Birman-Murakami-Wenzl algebra of type A_3 as an algebra given
  by generators and relations. A reference for the relations used is [CGW05].
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 1
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 1 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[0X
  [4X------------------------------------------------------------------[0X
  
  The  variables  are g_1, g_2, g_3, e_1, e_2, e_3, in this order. In order to
  have  the results printed out with these symbols, we invoke [2XGBNP.ConfigPrint[0m
  ([14X3.2-2[0m)
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBNP.ConfigPrint("g1","g2","g3","e1","e2","e3");[0X
  [4X------------------------------------------------------------------[0X
  
  Now  enter  the  relations.  This  will  be  done  in NP form (see [14X2.1[0m). The
  inderminates  m  and  l in the coefficient ring of the Birman-Murakami-Wenzl
  algebra  are  specialized to 7 and 11 in order to make the computations more
  efficient.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> m:= 7;;[0X
    [4Xgap> l:= 11;;[0X
    [4X[0X
    [4Xgap> #relations Theorem 1.1[0X
    [4Xgap> k1 := [[[4],[1,1],[1],[]],[1,-l/m,-l,l/m]];;[0X
    [4Xgap> k2 := [[[5],[2,2],[2],[]],[1,-l/m,-l,l/m]];;[0X
    [4Xgap> k3 := [[[6],[3,3],[3],[]],[1,-l/m,-l,l/m]];;[0X
    [4X[0X
    [4Xgap> #relations B1[0X
    [4Xgap> #empty set here[0X
    [4X[0X
    [4Xgap> #relations B2:[0X
    [4Xgap> k4 := [[[1,2,1],[2,1,2]],[1,-1]];;[0X
    [4Xgap> k5 := [[[2,3,2],[3,2,3]],[1,-1]];;[0X
    [4Xgap> k6 := [[[1,3],[3,1]],[1,-1]];;[0X
    [4X[0X
    [4Xgap> #relations R1[0X
    [4Xgap> kr1 := [[[1,4],[4]],[1,-1/l]];;[0X
    [4Xgap> kr2 := [[[2,5],[5]],[1,-1/l]];;[0X
    [4Xgap> kr3 := [[[3,6],[6]],[1,-1/l]];;[0X
    [4X[0X
    [4Xgap> #relations R2:[0X
    [4Xgap> kr4 := [[[4,2,4],[4]],[1,-l]];;[0X
    [4Xgap> kr5 := [[[5,1,5],[5]],[1,-l]];;[0X
    [4Xgap> kr6 := [[[5,3,5],[5]],[1,-l]];;[0X
    [4Xgap> kr7 := [[[6,2,6],[6]],[1,-l]];;[0X
    [4X[0X
    [4Xgap> #relations R2'[0X
    [4Xgap> km1 := [[[4,5,4],[4]],[1,-1]];;[0X
    [4Xgap> km2 := [[[5,4,5],[5]],[1,-1]];;[0X
    [4Xgap> km3 := [[[5,6,5],[5]],[1,-1]];;[0X
    [4Xgap> km4 := [[[6,5,6],[6]],[1,-1]];;[0X
    [4X[0X
    [4Xgap> KI := [k1,k2,k3,k4,k5,k6,kr1,kr2,kr3,kr4,kr5,kr6,kr7,km1,km2,km3,km4];;[0X
  [4X------------------------------------------------------------------[0X
  
  Now print the relations with [2XPrintNPList[0m ([14X3.2-3[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(KI);[0X
    [4X e1 - 11/7g1^2 - 11g1 + 11/7 [0X
    [4X e2 - 11/7g2^2 - 11g2 + 11/7 [0X
    [4X e3 - 11/7g3^2 - 11g3 + 11/7 [0X
    [4X g1g2g1 - g2g1g2 [0X
    [4X g2g3g2 - g3g2g3 [0X
    [4X g1g3 - g3g1 [0X
    [4X g1e1 - 1/11e1 [0X
    [4X g2e2 - 1/11e2 [0X
    [4X g3e3 - 1/11e3 [0X
    [4X e1g2e1 - 11e1 [0X
    [4X e2g1e2 - 11e2 [0X
    [4X e2g3e2 - 11e2 [0X
    [4X e3g2e3 - 11e3 [0X
    [4X e1e2e1 - e1 [0X
    [4X e2e1e2 - e2 [0X
    [4X e2e3e2 - e2 [0X
    [4X e3e2e3 - e3 [0X
    [4Xgap> Length(KI);[0X
    [4X17[0X
  [4X------------------------------------------------------------------[0X
  
  Now calculate the GrÃ¶bner basis with [2XSGrobner[0m ([14X3.4-2[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB := SGrobner(KI);;[0X
    [4X#I  number of entered polynomials is 17[0X
    [4X#I  number of polynomials after reduction is 17[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  End of phase III[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 144 msecs.[0X
    [4Xgap> PrintNPList(GB);[0X
    [4X g1^2 - 7/11e1 + 7g1 - 1 [0X
    [4X g1e1 - 1/11e1 [0X
    [4X g2^2 - 7/11e2 + 7g2 - 1 [0X
    [4X g2e2 - 1/11e2 [0X
    [4X g3g1 - g1g3 [0X
    [4X g3^2 - 7/11e3 + 7g3 - 1 [0X
    [4X g3e3 - 1/11e3 [0X
    [4X e1g1 - 1/11e1 [0X
    [4X e1g3 - g3e1 [0X
    [4X e1^2 + 43/77e1 [0X
    [4X e2g2 - 1/11e2 [0X
    [4X e2^2 + 43/77e2 [0X
    [4X e3g1 - g1e3 [0X
    [4X e3g3 - 1/11e3 [0X
    [4X e3e1 - e1e3 [0X
    [4X e3^2 + 43/77e3 [0X
    [4X g1g2e1 - e2e1 [0X
    [4X g1g3e1 - 1/11g3e1 [0X
    [4X g1e2e1 + 7e2e1 - g2e1 - 7e1 [0X
    [4X g2g1g2 - g1g2g1 [0X
    [4X g2g1e2 - e1e2 [0X
    [4X g2g3e2 - e3e2 [0X
    [4X g2e1g2 - g1e2g1 - 7e2g1 + 7e1g2 + 7g2e1 - 7g1e2 - 49e2 + 49e1 [0X
    [4X g2e1e2 + 7e1e2 - g1e2 - 7e2 [0X
    [4X g2e3e2 + 7e3e2 - g3e2 - 7e2 [0X
    [4X g3g2g3 - g2g3g2 [0X
    [4X g3g2e3 - e2e3 [0X
    [4X g3e1e3 - 1/11e1e3 [0X
    [4X g3e2g3 - g2e3g2 - 7e3g2 + 7e2g3 + 7g3e2 - 7g2e3 - 49e3 + 49e2 [0X
    [4X g3e2e3 + 7e2e3 - g2e3 - 7e3 [0X
    [4X e1g2g1 - e1e2 [0X
    [4X e1g2e1 - 11e1 [0X
    [4X e1e2g1 + 7e1e2 - e1g2 - 7e1 [0X
    [4X e1e2e1 - e1 [0X
    [4X e2g1g2 - e2e1 [0X
    [4X e2g1e2 - 11e2 [0X
    [4X e2g3g2 - e2e3 [0X
    [4X e2g3e2 - 11e2 [0X
    [4X e2e1g2 + 7e2e1 - e2g1 - 7e2 [0X
    [4X e2e1e2 - e2 [0X
    [4X e2e3g2 + 7e2e3 - e2g3 - 7e2 [0X
    [4X e2e3e2 - e2 [0X
    [4X e3g2g3 - e3e2 [0X
    [4X e3g2e3 - 11e3 [0X
    [4X e3e2g3 + 7e3e2 - e3g2 - 7e3 [0X
    [4X e3e2e3 - e3 [0X
    [4X g1g2g3e1 - e2g3e1 [0X
    [4X g1g3g2e1 - g3e2e1 [0X
    [4X g1g3e2e1 + 7g3e2e1 - g3g2e1 - 7g3e1 [0X
    [4X g1e2g3e1 + 7e2g3e1 - g2g3e1 - 7g3e1 [0X
    [4X g1e3g2e1 - e3e2e1 [0X
    [4X g1e3e2e1 + 7e3e2e1 - e3g2e1 - 7e1e3 [0X
    [4X g3g2g1g3 - g2g3g2g1 [0X
    [4X g3g2g1e3 - e2g1e3 [0X
    [4X g3g2e1e3 - e2e1e3 [0X
    [4X g3e1g2e3 - e1e2e3 [0X
    [4X g3e1e2e3 + 7e1e2e3 - e1g2e3 - 7e1e3 [0X
    [4X g3e2g1g3 - g2e3g2g1 - 7e3g2g1 + 7e2g1g3 + 7g3e2g1 - 7g2g1e3 + 49e2g1 - 49g1e3\[0X
    [4X [0X
    [4X g3e2g1e3 + 7e2g1e3 - g2g1e3 - 7g1e3 [0X
    [4X g3e2e1e3 + 7e2e1e3 - g2e1e3 - 7e1e3 [0X
    [4X e1g2g3g2 - g3e1g2g3 [0X
    [4X e1g2g3e1 - 11g3e1 [0X
    [4X e1g2e3g2 - g3e1e2g3 + 7e1e3g2 - 7e1e2g3 + 7e1g2e3 - 7g3e1e2 + 49e1e3 - 49e1e2\[0X
    [4X [0X
    [4X e1e2g3e1 - g3e1 [0X
    [4X e1e3g2g1 - e1e3e2 [0X
    [4X e1e3g2e1 - 11e1e3 [0X
    [4X e1e3e2g1 + 7e1e3e2 - e1e3g2 - 7e1e3 [0X
    [4X e1e3e2e1 - e1e3 [0X
    [4X e2g3e1e2 - e2g1e3e2 [0X
    [4X e2e1e3e2 + 7e2g1e3e2 - e2g1g3e2 - 77e2 [0X
    [4X e3g2g1g3 - e3e2g1 [0X
    [4X e3g2g1e3 - 11g1e3 [0X
    [4X e3g2e1e3 - 11e1e3 [0X
    [4X e3e2g1g3 + 7e3e2g1 - e3g2g1 - 7g1e3 [0X
    [4X e3e2g1e3 - g1e3 [0X
    [4X e3e2e1e3 - e1e3 [0X
    [4X g1g2g1g3e2 - g2g1e3e2 [0X
    [4X g1g2g1e3e2 + 7g2g1e3e2 - g2g1g3e2 - 7e1e2 [0X
    [4X g1g2g3g2e1 - g2e3g2e1 - 7e3g2e1 + 7e2g3e1 + 7g3e2e1 - 7g2e1e3 + 49e2e1 - 49e1\[0X
    [4Xe3 [0X
    [4X g1g2e3g2e1 + 7g2e3g2e1 - g2g3g2e1 + 7e3e2e1 + 49e3g2e1 + 7e2e1e3 - 7g3g2e1 + \[0X
    [4X49g2e1e3 - 7g2g3e1 + 343e1e3 - 49g3e1 - 49g2e1 - 350e1 [0X
    [4X g1e2g1g3e2 + 7e2g1g3e2 - g2e1e3e2 - 7g2g3e1e2 - 7e1e3e2 - 49g3e1e2 + 77g1e2 +\[0X
    [4X 539e2 [0X
    [4X g1e2g1e3e2 + 7e2g1e3e2 - g2g3e1e2 - 7g3e1e2 [0X
    [4X g2g3e1g2g3 - g1e2g1g3g2 - 7e2g1g3g2 + 7g3e1g2g3 + 7g2g3e1g2 + 49g3e1g2 - 7g1e\[0X
    [4X2e3 - 49e2e3 [0X
    [4X g2g3e1e2g3 - g1e2g1e3g2 - 7e2g1e3g2 + 7g3e1e2g3 + 7g2g3e1e2 - 7g1e2g1e3 - 49e\[0X
    [4X2g1e3 + 49g3e1e2 [0X
    [4X e2g1g3g2g1 - e2g1e3g2 [0X
    [4X e2g1g3e2g1 - e2e1e3g2 - 7e2g3e1g2 + 7e2g1g3e2 - 7e2e1e3 - 49e2g3e1 + 77e2g1 +\[0X
    [4X 539e2 [0X
    [4X e2g1e3g2g1 + 7e2g1e3g2 - e2g1g3g2 - 7e2e1 [0X
    [4X e2g1e3e2g1 - e2g3e1g2 + 7e2g1e3e2 - 7e2g3e1 [0X
    [4X e2g3e1g2g3 + 7e2g3e1g2 - e2g1g3g2 - 7e2e3 [0X
  [4X------------------------------------------------------------------[0X
  
  Now  calculate the dimension of the quotient algebra with [2XDimQA[0m ([14X3.5-2[0m) (the
  second argument is the number of symbols):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> DimQA(GB,6);[0X
    [4X105[0X
  [4X------------------------------------------------------------------[0X
  
  The conclusion is that the BMW algebra of type A3 has dimension 105.
  
  
  [1XA.9 The Birman-Murakami-Wenzl algebra of type A_2[0X
  
  The trace variant (see sections [14X2.5[0m and [14X3.7[0m) will be used for a presentation
  of the Birman-Murakami-Wenzl algebra of type A_2 by generators and relations
  in order to find a proof that the algebra has dimension 15.
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 1
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 1 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[0X
  [4X------------------------------------------------------------------[0X
  
  The  variables  are  g_1, g_2, e_1, e_2, in this order. In order to have the
  results printed out with these symbols, we invoke [2XGBNP.ConfigPrint[0m ([14X3.2-2[0m)
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBNP.ConfigPrint("g1","g2","e1","e2");[0X
  [4X------------------------------------------------------------------[0X
  
  Unlike Example [14XA.8[0m, we work with a field of rational functions.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> ll := Indeterminate(Rationals,"l");[0X
    [4Xl[0X
    [4Xgap> mm := Indeterminate(Rationals,"m");[0X
    [4Xm[0X
    [4Xgap> F := Field(ll,mm);[0X
    [4X<field in characteristic 0>[0X
    [4Xgap> gens := GeneratorsOfField(F);[0X
    [4X[ l, m ][0X
    [4Xgap> l := gens[1];;[0X
    [4Xgap> m := gens[2];[0X
    [4Xm[0X
    [4Xgap> F1 := One(F);;[0X
    [4Xgap> Print("identity element of F: ",F1,"\n");[0X
    [4Xidentity element of F: 1[0X
  [4X------------------------------------------------------------------[0X
  
  Now enter the relations. This will be done in NP form.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> #relations Theorem 1.1[0X
    [4Xgap> k1 := [[[3],[1,1],[1],[]],[F1,-l/m,-l,l/m]];;[0X
    [4Xgap> k2 := [[[4],[2,2],[2],[]],[F1,-l/m,-l,l/m]];;[0X
    [4X[0X
    [4Xgap> #relations B1[0X
    [4Xgap> #empty set here[0X
    [4X[0X
    [4Xgap> #relations B2:[0X
    [4Xgap> k3 := [[[1,2,1],[2,1,2]],[F1,-F1]];;[0X
    [4X[0X
    [4Xgap> #relations R1[0X
    [4Xgap> k4 := [[[1,3],[3]],[F1,-1/l]];;[0X
    [4Xgap> k5 := [[[2,4],[4]],[F1,-1/l]];;[0X
    [4X[0X
    [4Xgap> #relations R2:[0X
    [4Xgap> k6 := [[[3,2,3],[3]],[F1,-l]];;[0X
    [4Xgap> k7 := [[[4,1,4],[4]],[F1,-l]];;[0X
    [4Xgap> k8 := [[[3,4,3],[3]],[F1,-F1]];;[0X
    [4Xgap> k9 := [[[4,3,4],[4]],[F1,-F1]];;[0X
    [4X[0X
    [4Xgap> KI := [k1,k2,k3,k4,k5,k6,k7,k8,k9];;[0X
  [4X------------------------------------------------------------------[0X
  
  The input can be displayed with [2XPrintNPList[0m ([14X3.2-3[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(KI);[0X
    [4X e1 + -l/mg1^2 + -lg1 + l/m [0X
    [4X e2 + -l/mg2^2 + -lg2 + l/m [0X
    [4X g1g2g1 + -1g2g1g2 [0X
    [4X g1e1 + -1/le1 [0X
    [4X g2e2 + -1/le2 [0X
    [4X e1g2e1 + -le1 [0X
    [4X e2g1e2 + -le2 [0X
    [4X e1e2e1 + -1e1 [0X
    [4X e2e1e2 + -1e2 [0X
  [4X------------------------------------------------------------------[0X
  
  Now  calculate  the GrÃ¶bner basis with trace information, using the function
  [2XSGrobnerTrace[0m ([14X3.7-5[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB := SGrobnerTrace(KI);;[0X
    [4X#I  number of entered polynomials is 9[0X
    [4X#I  number of polynomials after reduction is 9[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  List of todo lengths is [ 8, 7, 6, 5, 4, 6, 4, 4, 4, 3, 3, 2, 1, 0 ][0X
    [4X#I  End of phase III[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 1092 msecs.[0X
  [4X------------------------------------------------------------------[0X
  
  The  full  trace  can be printed with [2XPrintTraceList[0m ([14X3.7-2[0m), while printing
  only  the  relations  (and  no  trace)  can  be  invoked by [2XPrintNPListTrace[0m
  ([14X3.7-4[0m).   Since   the   total   trace   is   very   long  we  do  not  call
  [10XPrintTraceList(GB)[0m  here  but  only show two polynomial expressions from the
  GrÃ¶bner basis with [2XPrintTracePol[0m ([14X3.7-3[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPListTrace(GB);[0X
    [4X g1^2 + m/-le1 + mg1 + -1 [0X
    [4X g1e1 + -1/le1 [0X
    [4X g2^2 + m/-le2 + mg2 + -1 [0X
    [4X g2e2 + -1/le2 [0X
    [4X e1g1 + 1/-le1 [0X
    [4X e1^2 + (l^2-l*m-1)/(l*m)e1 [0X
    [4X e2g2 + 1/-le2 [0X
    [4X e2^2 + (l^2-l*m-1)/(l*m)e2 [0X
    [4X g1g2e1 + -1e2e1 [0X
    [4X g1e2e1 + me2e1 + -1g2e1 + -me1 [0X
    [4X g2g1g2 + 1/-1g1g2g1 [0X
    [4X g2g1e2 + -1e1e2 [0X
    [4X g2e1g2 + -1g1e2g1 + -me2g1 + me1g2 + mg2e1 + -mg1e2 + -m^2e2 + m^2e1 [0X
    [4X g2e1e2 + me1e2 + -1g1e2 + -me2 [0X
    [4X e1g2g1 + -1e1e2 [0X
    [4X e1g2e1 + -le1 [0X
    [4X e1e2g1 + me1e2 + -1e1g2 + -me1 [0X
    [4X e1e2e1 + -1e1 [0X
    [4X e2g1g2 + -1e2e1 [0X
    [4X e2g1e2 + -le2 [0X
    [4X e2e1g2 + me2e1 + -1e2g1 + -me2 [0X
    [4X e2e1e2 + -1e2 [0X
    [4Xgap> PrintTracePol(GB[1]);[0X
    [4X m/-lG(1) [0X
    [4Xgap> PrintTracePol(GB[10]);[0X
    [4X -l*m/(-l*m-1)G(1)g1e2e1 + -l*m/(l*m+1)g1G(1)e2e1 + l^2*m/(-l*m-1)G([0X
    [4X1)g2g1e1 + l*m^2/(-l*m-1)G(1)g2g1e2e1 + -l/(-l*m-1)g2G([0X
    [4X1)g1e2e1 + -l/(l*m+1)g2g1G(1)e2e1 + l^2/(-l*m-1)g2G([0X
    [4X1)g2g1e1 + l*m/(-l*m-1)g2G(1)g2g1e2e1 + -l*m/(-l*m-1)e1g2G([0X
    [4X1)g2g1e1 + -l/(-l*m-1)g2e1g2G(1)g2g1e1 + -m/-lG([0X
    [4X2)g1e2e1 + -l^2*m/(-l*m-1)g2g1G(2)e1 + -l^2/(-l*m-1)g2^2g1G([0X
    [4X2)e1 + m^2/(-l*m-1)e1G(2)g1e2e1 + m/(-l*m-1)g2e1G([0X
    [4X2)g1e2e1 + -l*m/(l*m+1)e1g2^2g1G(2)e1 + -l/(l*m+1)g2e1g2^2g1G([0X
    [4X2)e1 + l^3*m/(-l*m-1)G(3)e1 + l^3/(-l*m-1)g1G(3)e1 + l^3/(-l*m-1)G([0X
    [4X3)g2e1 + l^3/(-l*m-1)g2G(3)e1 + l^2*m^2/(-l*m-1)G(3)e2e1 + l^2*m/(-l*m-1)g1G([0X
    [4X3)e2e1 + l^3/(-l*m^2-m)g2g1G(3)e1 + l^3/(-l*m^2-m)g2G([0X
    [4X3)g2e1 + l^2*m/(-l*m-1)G(3)g2e2e1 + l^2*m/(-l*m-1)g2G([0X
    [4X3)e2e1 + -l^2*m/(-l*m-1)e1g2G(3)e1 + l^2/(-l*m-1)g2g1G([0X
    [4X3)e2e1 + l^2/(-l*m-1)g2G(3)g2e2e1 + -l^2/(-l*m-1)g2e1g2G([0X
    [4X3)e1 + -l^2/(-l*m-1)e1g2g1G(3)e1 + -l^2/(-l*m-1)e1g2G([0X
    [4X3)g2e1 + -l^2/(-l*m^2-m)g2e1g2g1G(3)e1 + -l^2/(-l*m^2-m)g2e1g2G([0X
    [4X3)g2e1 + -l*m/(-l*m-1)G(4)e2e1 + -l/(-l*m-1)g2G(4)e2e1 + -l*mg2g1G([0X
    [4X5)e1 + l^2*m/(-l*m-1)g2g1g2G(5)e1 + -lg2^2g1G(5)e1 + l^2/(-l*m-1)g2^2g1g2G([0X
    [4X5)e1 + l*m/(-l*m-1)G(6)g2g1e1 + l/(-l*m-1)g2G(6)g2g1e1 + m/-lG([0X
    [4X7)e1 + -m^2/(-l*m-1)e1G(7)e1 + -m/(-l*m-1)g2e1G(7)e1 + mG(8) + g2G(8) [0X
  [4X------------------------------------------------------------------[0X
  
  In  order  to  test  whether  the expression for [10XGB[10][0m is as claimed we use
  [2XEvalTrace[0m  ([14X3.7-1[0m),  For  each  traced  polynomial  [10Xx[0m  in  [10XGB[0m, we equate the
  evaluated  expression  [10Xx.trace[0m, in which each occurrence of [10XG(i)[0m is replaced
  by [10XKI[i][0m by use of [2XEvalTrace[0m ([14X3.7-1[0m), with [10Xx.pol[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> ForAll(GB,x->EvalTrace(x,KI)=x.pol);[0X
    [4Xfalse[0X
  [4X------------------------------------------------------------------[0X
  
  As  a  result  the  dimension of the quotient algebra can be calculated with
  [2XDimQA[0m ([14X3.5-2[0m) and the quotient algebra itself with [2XBaseQA[0m ([14X3.5-1[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB_pols:=List(GB,x->x.pol);;[0X
    [4Xgap> PrintNPList(GB_pols);[0X
    [4X g1^2 + m/-le1 + mg1 + -1 [0X
    [4X g1e1 + -1/le1 [0X
    [4X g2^2 + m/-le2 + mg2 + -1 [0X
    [4X g2e2 + -1/le2 [0X
    [4X e1g1 + 1/-le1 [0X
    [4X e1^2 + (l^2-l*m-1)/(l*m)e1 [0X
    [4X e2g2 + 1/-le2 [0X
    [4X e2^2 + (l^2-l*m-1)/(l*m)e2 [0X
    [4X g1g2e1 + -1e2e1 [0X
    [4X g1e2e1 + me2e1 + -1g2e1 + -me1 [0X
    [4X g2g1g2 + 1/-1g1g2g1 [0X
    [4X g2g1e2 + -1e1e2 [0X
    [4X g2e1g2 + -1g1e2g1 + -me2g1 + me1g2 + mg2e1 + -mg1e2 + -m^2e2 + m^2e1 [0X
    [4X g2e1e2 + me1e2 + -1g1e2 + -me2 [0X
    [4X e1g2g1 + -1e1e2 [0X
    [4X e1g2e1 + -le1 [0X
    [4X e1e2g1 + me1e2 + -1e1g2 + -me1 [0X
    [4X e1e2e1 + -1e1 [0X
    [4X e2g1g2 + -1e2e1 [0X
    [4X e2g1e2 + -le2 [0X
    [4X e2e1g2 + me2e1 + -1e2g1 + -me2 [0X
    [4X e2e1e2 + -1e2 [0X
    [4Xgap> DimQA(GB_pols,2);[0X
    [4X6[0X
    [4Xgap> B:=BaseQA(GB_pols,2,0);;[0X
    [4Xgap> PrintNPList(B);[0X
    [4X 1 [0X
    [4X g1 [0X
    [4X g2 [0X
    [4X g1g2 [0X
    [4X g2g1 [0X
    [4X g1g2g1 [0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.10 A commutative example by Mora[0X
  
  Here  we  present a commutative example from page 339 of "An introduction to
  commutative  and  non-commutative  GrÃ¶bner  Bases",  by Teo Mora [Mor94]. It
  involves  the  seven  variables  a,b,c,d,e,f,g.  In order to force commuting
  between  each pair from a,b,c,d,e,f,g, we let part of the input equations be
  the  homogeneous  binomials  of  the  form  xy  -  yx.  GBNP  is  built  for
  non-commutative  polynomial  arithmetic,  and  should handle the commutative
  case by means of this forced commutation. But it should not be considered as
  a serious alternative to the well-known GrÃ¶bner bases packages when it comes
  to efficiency.
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 1
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 1 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[0X
  [4X------------------------------------------------------------------[0X
  
  The  relations  will  be entered as GAP polynomials and converted to NP form
  (see [14X2.1[0m) with [2XGP2NPList[0m ([14X3.1-2[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> F:=GF(7);; ef:=One(F);;[0X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(F, "a", "b", "c", "d", "e", "f", "g");[0X
    [4X<algebra-with-one over GF(7), with 7 generators>[0X
    [4Xgap> gens:=GeneratorsOfAlgebra(A);[0X
    [4X[ (Z(7)^0)*<identity ...>, (Z(7)^0)*a, (Z(7)^0)*b, (Z(7)^0)*c, (Z(7)^0)*d, [0X
    [4X  (Z(7)^0)*e, (Z(7)^0)*f, (Z(7)^0)*g ][0X
    [4Xgap> a:=gens[2];; b:=gens[3];; c:=gens[4];; d:=gens[5];; e:=gens[6];; f:=gens[7];;[0X
    [4Xgap> g:=gens[8];; ea:=gens[1];;[0X
    [4X[0X
    [4Xgap> rels := [ a^3 + f*a, [0X
    [4X> 	a^9 + c*a^3 + g*a,[0X
    [4X> 	a^81 + c*a^9 + d*a^3,[0X
    [4X> 	c*a^81 + d*a^9 + e*a^3,[0X
    [4X> 	a^27 + d*a^81 + e*a^9 + f*a^3,[0X
    [4X> 	b + c*a^27 + e*a^81 + f*a^9 + g*a^3,[0X
    [4X> 	c*b + d*a^27 + f*a^81 + g*a^9,[0X
    [4X> 	a + d*b + e*a^27 + g*a^81,[0X
    [4X> 	c*a + e*b + f*a^27,[0X
    [4X> 	d*a + f*b + g*a^27,[0X
    [4X> 	e*a + g*b,[0X
    [4X> 	b^3 - b ];;[0X
  [4X------------------------------------------------------------------[0X
  
  Some relations added to enforce commutativity.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> for i in [1..6] do[0X
    [4X>     for j in [i+1..7] do[0X
    [4X>         Add(rels,gens[i+1]*gens[j+1]-gens[j+1]*gens[i+1]);[0X
    [4X>     od;[0X
    [4X> od;[0X
  [4X------------------------------------------------------------------[0X
  
  Now  the  relations  are  converted  to  NP form (see [14X2.1[0m) with the function
  [2XGP2NPList[0m ([14X3.1-2[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> KI:=GP2NPList(rels);;[0X
  [4X------------------------------------------------------------------[0X
  
  The  GrÃ¶bner  basis can be calculated with [2XSGrobner[0m ([14X3.4-2[0m) and printed with
  [2XPrintNPList[0m ([14X3.2-3[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB := SGrobner(KI);;[0X
    [4X#I  number of entered polynomials is 33[0X
    [4X#I  number of polynomials after reduction is 33[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  End of phase III[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 49047 msecs.[0X
    [4Xgap> PrintNPList(GB);[0X
    [4X a [0X
    [4X b [0X
    [4X dc + Z(7)^3cd [0X
    [4X ec + Z(7)^3ce [0X
    [4X ed + Z(7)^3de [0X
    [4X fc + Z(7)^3cf [0X
    [4X fd + Z(7)^3df [0X
    [4X fe + Z(7)^3ef [0X
    [4X gc + Z(7)^3cg [0X
    [4X gd + Z(7)^3dg [0X
    [4X ge + Z(7)^3eg [0X
    [4X gf + Z(7)^3fg [0X
  [4X------------------------------------------------------------------[0X
  
  To  determine  whether  the quotient algebra is finite dimensional we invoke
  [2XFinCheckQA[0m  ([14X3.6-2[0m),  using  as arguments the leading monomials of [10XGB[0m and 7,
  the  number  of variables involved. The leading monomials of [10XGB[0m are obtained
  by [2XLMonsNP[0m ([14X3.3-10[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> F := LMonsNP(GB);;[0X
    [4Xgap> FinCheckQA(F,7);[0X
    [4Xfalse[0X
  [4X------------------------------------------------------------------[0X
  
  Thus,  the quotient algebra turns out to be infinite dimensional. This is no
  surprise  as  the  GrÃ¶bner  basis  shows it is actually the free commutative
  algebra  generated  by c,d,e,f,g. In particular, it has polynomial growth of
  degree  5.  This  is  confirmed by application of [2XDetermineGrowthQA[0m ([14X3.6-1[0m),
  with  the  first  two  arguments  as for [10XFinCheckQA[0m above and third argument
  [10Xfalse[0m,  indicating  that an interval for the degree of the polynomial degree
  will suffice.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> DetermineGrowthQA(F,7,false);[0X
    [4X5[0X
  [4X------------------------------------------------------------------[0X
  
  It  turns  out  that  this quick version already gives an exact answer. More
  time consuming would be the algorithm run with third argument equal to [10Xtrue[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> DetermineGrowthQA(F,7,true);[0X
    [4X5[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.11 Tracing an example by Mora[0X
  
  This  example of a non-commutative GrÃ¶bner basis computation is from page 18
  of  "An  introduction  to commutative and non-commutative GrÃ¶bner Bases", by
  Teo  Mora  [Mor94].  The  traced  version of the algorithm will be used. The
  input is xyx-y,yxy-y. The answer should be yy-xy,yx-xy,xxy-y.
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 2
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 1 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,2);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[0X
  [4X------------------------------------------------------------------[0X
  
  Let  the  variables  be  printed  as  x and y instead of a and b by means of
  [2XGBNP.ConfigPrint[0m ([14X3.2-2[0m)
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBNP.ConfigPrint("x","y");[0X
  [4X------------------------------------------------------------------[0X
  
  Next  we  input  the  relations in NP format (see Section [14X2.1[0m). They will be
  assigned to [10XKI[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> xyx := [[[1,2,1],[2]],[1,-1]];;[0X
    [4Xgap> yxy := [[[2,1,2],[2]],[1,-1]];;[0X
    [4Xgap> KI:=[xyx,yxy];;[0X
  [4X------------------------------------------------------------------[0X
  
  The relations can be shown with [2XPrintNPList[0m ([14X3.2-3[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(KI);[0X
    [4X xyx - y [0X
    [4X yxy - y [0X
  [4X------------------------------------------------------------------[0X
  
  The  GrÃ¶bner  basis  with  trace  can  now  be calculated with [2XSGrobnerTrace[0m
  ([14X3.7-5[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB := SGrobnerTrace(KI);[0X
    [4X#I  number of entered polynomials is 2[0X
    [4X#I  number of polynomials after reduction is 2[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  j =2[0X
    [4X#I  Current number of elements in todo is 1[0X
    [4X#I  j =3[0X
    [4X#I  Current number of elements in todo is 0[0X
    [4X#I  List of todo lengths is [ 2, 1, 0 ][0X
    [4X#I  End of phase III[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 8 msecs.[0X
    [4X[ rec( pol := [ [ [ 2, 1 ], [ 1, 2 ] ], [ 1, -1 ] ], [0X
    [4X      trace := [ [ [  ], 1, [ 2 ], -1 ], [ [ 2 ], 1, [  ], 1 ], [0X
    [4X          [ [ 1 ], 2, [  ], 1 ], [ [  ], 2, [ 1 ], -1 ] ] ), [0X
    [4X  rec( pol := [ [ [ 2, 2 ], [ 1, 2 ] ], [ 1, -1 ] ], [0X
    [4X      trace := [ [ [ 2 ], 1, [  ], -1 ], [ [  ], 1, [ 2 ], -1 ], [0X
    [4X          [ [ 2 ], 1, [  ], 1 ], [ [  ], 2, [ 1 ], 1 ], [ [ 1 ], 2, [  ], 1 ],[0X
    [4X          [ [  ], 2, [ 1 ], -1 ] ] ), [0X
    [4X  rec( pol := [ [ [ 1, 1, 2 ], [ 2 ] ], [ 1, -1 ] ], [0X
    [4X      trace := [ [ [  ], 1, [  ], 1 ], [ [ 1 ], 1, [ 2 ], 1 ], [0X
    [4X          [ [ 1, 2 ], 1, [  ], -1 ], [ [ 1, 1 ], 2, [  ], -1 ], [0X
    [4X          [ [ 1 ], 2, [ 1 ], 1 ] ] ) ][0X
  [4X------------------------------------------------------------------[0X
  
  The GrÃ¶bner basis can be printed with [2XPrintNPListTrace[0m ([14X3.7-4[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPListTrace(GB);[0X
    [4X yx - xy [0X
    [4X y^2 - xy [0X
    [4X x^2y - y [0X
  [4X------------------------------------------------------------------[0X
  
  The trace of the GrÃ¶bner basis can be printed with [2XPrintTraceList[0m ([14X3.7-2[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintTraceList(GB);[0X
    [4X- G(1)y + yG(1) - G(2)x + xG(2) [0X
    [4X[0X
    [4X- G(1)y + xG(2) [0X
    [4X[0X
    [4X G(1) + xG(1)y - xyG(1) + xG(2)x - x^2G(2) [0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.12 Finiteness of the Weyl group of type E_6[0X
  
  This example extends [14XA.5[0m, which computes the order of the Weyl group of type
  E_6.
  
  Here, before the dimension is calculated, it is checked whether the quotient
  algebra   is  finite  dimensional  or  infinite  dimensional.  The  function
  [2XFinCheckQA[0m   ([14X3.6-2[0m)   is   used  for  this  computation.  For  the  use  of
  [2XPreprocessAnalysisQA[0m ([14X3.6-4[0m) to speed up the check, see Example [14XA.13[0m.
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 1
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 2 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,2);[0X
  [4X------------------------------------------------------------------[0X
  
  Then  input  the  relations  in  NP  format  (see Section [14X2.1[0m). They will be
  assigned to [10XKI[0m. These relations are the same as those in Example 3.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> k1 := [[[1,3,1],[3,1,3]],[1,-1]];;[0X
    [4Xgap> k2 := [[[4,3,4],[3,4,3]],[1,-1]];;[0X
    [4Xgap> k3 := [[[4,2,4],[2,4,2]],[1,-1]];;[0X
    [4Xgap> k4 := [[[4,5,4],[5,4,5]],[1,-1]];;[0X
    [4Xgap> k5 := [[[6,5,6],[5,6,5]],[1,-1]];;[0X
    [4Xgap> k6 := [[[1,2],[2,1]],[1,-1]];;[0X
    [4Xgap> k7 := [[[1,4],[4,1]],[1,-1]];;[0X
    [4Xgap> k8 := [[[1,5],[5,1]],[1,-1]];;[0X
    [4Xgap> k9 := [[[1,6],[6,1]],[1,-1]];;[0X
    [4Xgap> k10 := [[[2,3],[3,2]],[1,-1]];;[0X
    [4Xgap> k11 := [[[2,5],[5,2]],[1,-1]];;[0X
    [4Xgap> k12 := [[[2,6],[6,2]],[1,-1]];;[0X
    [4Xgap> k13 := [[[3,5],[5,3]],[1,-1]];;[0X
    [4Xgap> k14 := [[[3,6],[6,3]],[1,-1]];;[0X
    [4Xgap> k15 := [[[4,6],[6,4]],[1,-1]];;[0X
    [4Xgap> k16 := [[[1,1],[]],[1,-1]];;[0X
    [4Xgap> k17 := [[[2,2],[]],[1,-1]];;[0X
    [4Xgap> k18 := [[[3,3],[]],[1,-1]];;[0X
    [4Xgap> k19 := [[[4,4],[]],[1,-1]];;[0X
    [4Xgap> k20 := [[[5,5],[]],[1,-1]];;[0X
    [4Xgap> k21 := [[[6,6],[]],[1,-1]];;[0X
    [4Xgap> KI := [k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,[0X
    [4X>        k11,k12,k13,k14,k15,k16,k17,k18,k19,k20,k21[0X
    [4X>       ];;[0X
  [4X------------------------------------------------------------------[0X
  
  The GrÃ¶bner basis can now be calculated with [2XSGrobner[0m ([14X3.4-2[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB := SGrobner(KI);;[0X
    [4X#I  number of entered polynomials is 21[0X
    [4X#I  number of polynomials after reduction is 21[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  End of phase III[0X
    [4X#I  Time needed to clean G :0[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 220 msecs.[0X
  [4X------------------------------------------------------------------[0X
  
  We will check whether the quotient algebra is finite dimensional or infinite
  dimensional.  The  function  [2XFinCheckQA[0m ([14X3.6-2[0m) exists for this purpose. Its
  first  argument  is the list of leading monomials of a GrÃ¶bner basis and its
  second  argument  the  number  of  symbols.  The  leading  monomials  can be
  calculated with [2XLMonsNP[0m ([14X3.3-10[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> L:=LMonsNP(GB);;[0X
    [4Xgap> FinCheckQA(L,6);[0X
    [4Xtrue[0X
    [4Xgap> time;[0X
    [4X84[0X
  [4X------------------------------------------------------------------[0X
  
  If a quotient algebra is finite dimensional, the dimension can be calculated
  with [2XDimQA[0m ([14X3.5-2[0m), the arguments are the GrÃ¶bner basis [10XGB[0m and the number of
  symbols [10X6[0m. Since [2XInfoGBNPTime[0m ([14X4.3-1[0m) is set to 2, we get timing information
  from [2XDimQA[0m ([14X3.5-2[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> dim := DimQA(GB,6);[0X
    [4X#I  The computation took 272 msecs.[0X
    [4X51840[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.13 Preprocessing for Weyl group computations[0X
  
  This  example  extends  Example  [14XA.5[0m  with  the  following action: after the
  GrÃ¶bner  basis computation, we first check if the quotient algebra is finite
  dimensional  or  infinite dimensional before we possibly try to compute that
  dimension. Preprocessing of the set of leading terms of the GrÃ¶bner basis is
  used  to  speed up the check. The functions [2XPreprocessAnalysisQA[0m ([14X3.6-4[0m) and
  [2XFinCheckQA[0m ([14X3.6-2[0m) are used for the computations. Even without preprocessing
  this  already  goes  fast.  Still,  preprocessing can speed up more involved
  cases.  For  instance,  after  adapting this example to run for E7, we found
  that preprocessing speeds up the computation from 400 secs to about 40 secs.
  (Be aware that GrÃ¶bner basis computation will take a while for E7.)
  
  More  information  about the preprocessing can be found in the preprint "The
  dimensionality   of   quotient  algebras"  [Kro03]  which  is  part  of  the
  documentation.
  
  Note:  there  is  no  information  on  the  amount of preprocessing which is
  optimal,  but in general for big examples, even full preprocessing is better
  than using no preprocessing at all.
  
  Note: Example [14XA.12[0m also determines if the quotient algebra appearing here is
  finite or infinite dimensional but does not use preprocessing.
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 0
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 2 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,0);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,2);[0X
  [4X------------------------------------------------------------------[0X
  
  Then  input  the  relations  in  NP  format  (see Section [14X2.1[0m). They will be
  assigned to [10XKI[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> k1 := [[[1,3,1],[3,1,3]],[1,-1]];;[0X
    [4Xgap> k2 := [[[4,3,4],[3,4,3]],[1,-1]];;[0X
    [4Xgap> k3 := [[[4,2,4],[2,4,2]],[1,-1]];;[0X
    [4Xgap> k4 := [[[4,5,4],[5,4,5]],[1,-1]];;[0X
    [4Xgap> k5 := [[[6,5,6],[5,6,5]],[1,-1]];;[0X
    [4Xgap> k6 := [[[1,2],[2,1]],[1,-1]];;[0X
    [4Xgap> k7 := [[[1,4],[4,1]],[1,-1]];;[0X
    [4Xgap> k8 := [[[1,5],[5,1]],[1,-1]];;[0X
    [4Xgap> k9 := [[[1,6],[6,1]],[1,-1]];;[0X
    [4Xgap> k10 := [[[2,3],[3,2]],[1,-1]];;[0X
    [4Xgap> k11 := [[[2,5],[5,2]],[1,-1]];;[0X
    [4Xgap> k12 := [[[2,6],[6,2]],[1,-1]];;[0X
    [4Xgap> k13 := [[[3,5],[5,3]],[1,-1]];;[0X
    [4Xgap> k14 := [[[3,6],[6,3]],[1,-1]];;[0X
    [4Xgap> k15 := [[[4,6],[6,4]],[1,-1]];;[0X
    [4Xgap> k16 := [[[1,1],[]],[1,-1]];;[0X
    [4Xgap> k17 := [[[2,2],[]],[1,-1]];;[0X
    [4Xgap> k18 := [[[3,3],[]],[1,-1]];;[0X
    [4Xgap> k19 := [[[4,4],[]],[1,-1]];;[0X
    [4Xgap> k20 := [[[5,5],[]],[1,-1]];;[0X
    [4Xgap> k21 := [[[6,6],[]],[1,-1]];;[0X
    [4Xgap> KI := [k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,[0X
    [4X>        k11,k12,k13,k14,k15,k16,k17,k18,k19,k20,k21[0X
    [4X>       ];;[0X
  [4X------------------------------------------------------------------[0X
  
  The GrÃ¶bner basis can now be calculated with [2XSGrobner[0m ([14X3.4-2[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB := SGrobner(KI);;[0X
    [4X#I  Time needed to clean G :0[0X
    [4X#I  The computation took 220 msecs.[0X
  [4X------------------------------------------------------------------[0X
  
  Check  the  dimensionality of the quotient algebra. We will check whether it
  is   finite   dimensional   or  infinite  dimensional.  In  case  of  finite
  dimensionality we can compute this dimension.
  
  The   function   [2XFinCheckQA[0m   ([14X3.6-2[0m),   which   is  used  to  check  finite
  dimensionality  has  as  first  argument  the list of leading monomials of a
  GrÃ¶bner  basis  and  as second argument the number of symbols. The monomials
  can  be  calculated  with  [2XLMonsNP[0m  ([14X3.3-10[0m). They then will be preprocessed
  using  4 recursions. If you want full preprocessing, use 0 instead of 4 as a
  parameter for the number of recursions.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> L:=LMonsNP(GB);;[0X
    [4Xgap> L:=PreprocessAnalysisQA(L,6,4);;[0X
    [4Xgap> time;[0X
    [4X12[0X
    [4Xgap> fd:=FinCheckQA(L,6);[0X
    [4Xtrue[0X
    [4Xgap> time;[0X
    [4X8[0X
  [4X------------------------------------------------------------------[0X
  
  If a quotient algebra is finite dimensional, the dimension can be calculated
  with [2XDimQA[0m ([14X3.5-2[0m), the arguments are the GrÃ¶bner basis [10XGB[0m and the number of
  symbols [10X6[0m. Since [2XInfoGBNPTime[0m ([14X4.3-1[0m) is set to 2, we get timing information
  from [2XDimQA[0m ([14X3.5-2[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> dim := DimQA(GB,6);[0X
    [4X#I  The computation took 276 msecs.[0X
    [4X51840[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.14 A quotient algebra with exponential growth[0X
  
  This  example  demonstrates  an  instance  in  which the quotient algebra is
  infinite   dimensional  and  has  exponential  growth.  We  start  out  with
  [10XKI[0m:=[y^4-y^2,x^2y-xy]   and  obtain  a  GrÃ¶bner  basis  with  leading  terms
  [xxy,yyy].  The quotient algebra will thus have exponential growth since the
  cycles  (xyyx)^n and (xy)^m intersect in the common subwords xy (and in yx).
  This is explained in [Kro03]. The function [2XDetermineGrowthQA[0m ([14X3.6-1[0m) is used
  for the computation.
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 2
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 1 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,2);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[0X
  [4X------------------------------------------------------------------[0X
  
  Let  the  variables  be  printed  as  x and y instead of a and b by means of
  [2XGBNP.ConfigPrint[0m ([14X3.2-2[0m)
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBNP.ConfigPrint("x","y");[0X
  [4X------------------------------------------------------------------[0X
  
  Then  input  the  relations  in  NP  format  (see Section [14X2.1[0m). They will be
  assigned to [10XKI[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> k1 := [[[2,2,2,2],[2,2]],[1,-1]];;[0X
    [4Xgap> k2 := [[[1,1,2],[1,2]],[1,-1]];;[0X
    [4Xgap> KI := [k1,k2];;[0X
    [4Xgap> PrintNPList(KI);[0X
    [4X y^4 - y^2 [0X
    [4X x^2y - xy [0X
  [4X------------------------------------------------------------------[0X
  
  We  calculate the GrÃ¶bner basis with the function [2XSGrobner[0m ([14X3.4-2[0m) and print
  it with [2XPrintNPList[0m ([14X3.2-3[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB := SGrobner(KI);;[0X
    [4X#I  number of entered polynomials is 2[0X
    [4X#I  number of polynomials after reduction is 2[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  List of todo lengths is [ 0 ][0X
    [4X#I  End of phase III[0X
    [4X#I  G: Cleaning finished, 0 polynomials reduced[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 8 msecs.[0X
    [4Xgap> PrintNPList(GB);[0X
    [4X x^2y - xy [0X
    [4X y^4 - y^2 [0X
  [4X------------------------------------------------------------------[0X
  
  Next  we  check the dimensionality of the quotient algebra with the function
  [2XFinCheckQA[0m   ([14X3.6-2[0m)   or  the  function  [2XDetermineGrowthQA[0m  ([14X3.6-1[0m).  These
  functions  expect  as  first argument a list [3XF[0m of leading terms of a GrÃ¶bner
  basis,  which  can  be  calculated with the function [2XLMonsNP[0m ([14X3.3-10[0m) and as
  second  argument  the  number  of  symbols  (here  equal to 2). The function
  [2XDetermineGrowthQA[0m  ([14X3.6-1[0m)  will  not only report whether a GrÃ¶bner basis is
  finite, but will also provide information about its growth.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> L:=LMonsNP(GB);[0X
    [4X[ [ 1, 1, 2 ], [ 2, 2, 2, 2 ] ][0X
    [4Xgap> fd:=FinCheckQA(L,2);[0X
    [4Xfalse[0X
    [4Xgap> fd:=DetermineGrowthQA(L,2,false);[0X
    [4X"exponential growth"[0X
  [4X------------------------------------------------------------------[0X
  
  Although the quotient algebra is infinite dimensional, multiplication of two
  elements can be carried out by [2XMulQA[0m ([14X3.5-5[0m). We print three positive powers
  of x+y.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> w := [[[1],[2]],[1,1]];;[0X
    [4Xgap> hlp := [[[]],[1]];;[0X
    [4Xgap> for i in [3..5] do [0X
    [4X>   hlp := MulQA(hlp, w, GB);[0X
    [4X>   Print("\n (x+y)^",i," = \n"); [0X
    [4X>   PrintNP(hlp);[0X
    [4X> od;[0X
    [4X[0X
    [4X (x+y)^3 = [0X
    [4X y + x [0X
    [4X[0X
    [4X (x+y)^4 = [0X
    [4X y^2 + yx + xy + x^2 [0X
    [4X[0X
    [4X (x+y)^5 = [0X
    [4X y^3 + y^2x + yxy + yx^2 + xy^2 + xyx + x^3 + xy [0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.15 A commutative quotient algebra of polynomial growth[0X
  
  This  example extends [14XA.7[0m, a commutative example from Some Tapas of Computer
  Algebra [CCS99], page 339.
  
  The  result  of the GrÃ¶bner basis computation should be the union of a,b and
  the  set of 6 homogeneous binomials (that is, polynomials with two terms) of
  degree  2  forcing  commuting  between  c,  d,  e,  and  f, as before. After
  computation  of the GrÃ¶bner basis, the quotient algebra is studied and found
  to  be  infinite  dimensional of polynomial growth of degree 4. The function
  [2XDetermineGrowthQA[0m  ([14X3.6-1[0m)  is  used  for this computation. Then part of its
  Hilbert series is computed. The function [2XHilbertSeriesQA[0m ([14X3.6-3[0m) is used for
  the computations.
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 2
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 1 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,2);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[0X
  [4X------------------------------------------------------------------[0X
  
  Now  define some functions which will help in the construction of relations.
  The  function  [10Xpowermon(i, exp)[0m will return the monomial i^exp. The function
  [10Xcomm(aa,  bb)[0m  will  return a relation forcing commutativity between its two
  arguments [10Xaa[0m and [10Xbb[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> powermon := function(base, exp)[0X
    [4X>  local ans,i;[0X
    [4X>  ans := [];[0X
    [4X>  for i in [1..exp] do ans :=  Concatenation(ans,[base]); od;[0X
    [4X>  return ans;[0X
    [4X> end;;[0X
    [4X[0X
    [4Xgap> comm := function(aa,bb)[0X
    [4X>   return [[[aa,bb],[bb,aa]],[1,-1]];[0X
    [4X> end;;[0X
  [4X------------------------------------------------------------------[0X
  
  Now the relations are entered:
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> p1 := [[[5,1]],[1]];;[0X
    [4Xgap> p2 := [[powermon(1,3),[6,1]],[1,1]];;[0X
    [4Xgap> p3 := [[powermon(1,9),Concatenation([3],powermon(1,3))],[1,1]];;[0X
    [4Xgap> p4 := [[powermon(1,81),Concatenation([3],powermon(1,9)),Concatenation([4],[0X
    [4X> 	powermon(1,3))],[1,1,1]];;[0X
    [4Xgap> p5 := [[Concatenation([3],powermon(1,81)),Concatenation([4],powermon(1,9)),[0X
    [4X> 	Concatenation([5],powermon(1,3))],[1,1,1]];;[0X
    [4Xgap> p6 := [[powermon(1,27),Concatenation([4],powermon(1,81)),Concatenation([5],[0X
    [4X> 	powermon(1,9)),Concatenation([6],powermon(1,3))],[1,1,1,1]];;[0X
    [4Xgap> p7 := [[powermon(2,1),Concatenation([3],powermon(1,27)),Concatenation([5],[0X
    [4X> 	powermon(1,81)),Concatenation([6],powermon(1,9))],[1,1,1,1]];;[0X
    [4Xgap> p8 := [[Concatenation([3],powermon(2,1)),Concatenation([4],powermon(1,27)),[0X
    [4X> 	Concatenation([6],powermon(1,81))],[1,1,1]];;[0X
    [4Xgap> p9 := [[Concatenation([],powermon(1,1)),Concatenation([4],powermon(2,1)),[0X
    [4X> 	Concatenation([5],powermon(1,27))],[1,1,1]];;[0X
    [4Xgap> p10 := [[Concatenation([3],powermon(1,1)),Concatenation([5],powermon(2,1)),[0X
    [4X> 	Concatenation([6],powermon(1,27))],[1,1,1]];;[0X
    [4Xgap> p11 := [[Concatenation([4],powermon(1,1)),Concatenation([6],powermon(2,1))],[0X
    [4X> 	[1,1]];;[0X
    [4Xgap> p12 := [[Concatenation([],powermon(2,3)),Concatenation([],powermon(2,1))],[0X
    [4X> 	[1,-1]];;[0X
    [4Xgap> KI := [p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12];;[0X
    [4Xgap> for i in [1..5] do[0X
    [4X>     for j in [i+1..6] do[0X
    [4X>         Add(KI,comm(i,j));[0X
    [4X>     od;[0X
    [4X> od;[0X
  [4X------------------------------------------------------------------[0X
  
  The relations can be shown with [2XPrintNPList[0m ([14X3.2-3[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(KI);[0X
    [4X ea [0X
    [4X a^3 + fa [0X
    [4X a^9 + ca^3 [0X
    [4X a^81 + ca^9 + da^3 [0X
    [4X ca^81 + da^9 + ea^3 [0X
    [4X a^27 + da^81 + ea^9 + fa^3 [0X
    [4X b + ca^27 + ea^81 + fa^9 [0X
    [4X cb + da^27 + fa^81 [0X
    [4X a + db + ea^27 [0X
    [4X ca + eb + fa^27 [0X
    [4X da + fb [0X
    [4X b^3 - b [0X
    [4X ab - ba [0X
    [4X ac - ca [0X
    [4X ad - da [0X
    [4X ae - ea [0X
    [4X af - fa [0X
    [4X bc - cb [0X
    [4X bd - db [0X
    [4X be - eb [0X
    [4X bf - fb [0X
    [4X cd - dc [0X
    [4X ce - ec [0X
    [4X cf - fc [0X
    [4X de - ed [0X
    [4X df - fd [0X
    [4X ef - fe [0X
  [4X------------------------------------------------------------------[0X
  
  It  is  usually  easier  to  use  the function [2XGP2NP[0m ([14X3.1-1[0m) or the function
  [2XGP2NPList[0m  ([14X3.1-2[0m)  to  enter relations. Entering the first twelve relations
  and then converting them with [2XGP2NPList[0m ([14X3.1-2[0m) is demonstrated in example 6
  ([14XA.7[0m). More about converting can be read in Section [14X3.1[0m.
  
  The  GrÃ¶bner  basis  can now be calculated with [2XSGrobner[0m ([14X3.4-2[0m) and printed
  with [2XPrintNPList[0m ([14X3.2-3[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB := SGrobner(KI);[0X
    [4X#I  number of entered polynomials is 27[0X
    [4X#I  number of polynomials after reduction is 8[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  List of todo lengths is [ 0 ][0X
    [4X#I  End of phase III[0X
    [4X#I  G: Cleaning finished, 0 polynomials reduced[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 1224 msecs.[0X
    [4X[ [ [ [ 1 ] ], [ 1 ] ], [ [ [ 2 ] ], [ 1 ] ], [0X
    [4X  [ [ [ 4, 3 ], [ 3, 4 ] ], [ 1, -1 ] ], [ [ [ 5, 3 ], [ 3, 5 ] ], [ 1, -1 ] ][0X
    [4X    , [ [ [ 5, 4 ], [ 4, 5 ] ], [ 1, -1 ] ], [0X
    [4X  [ [ [ 6, 3 ], [ 3, 6 ] ], [ 1, -1 ] ], [ [ [ 6, 4 ], [ 4, 6 ] ], [ 1, -1 ] ][0X
    [4X    , [ [ [ 6, 5 ], [ 5, 6 ] ], [ 1, -1 ] ] ][0X
    [4Xgap> PrintNPList(GB);[0X
    [4X a [0X
    [4X b [0X
    [4X dc - cd [0X
    [4X ec - ce [0X
    [4X ed - de [0X
    [4X fc - cf [0X
    [4X fd - df [0X
    [4X fe - ef [0X
  [4X------------------------------------------------------------------[0X
  
  The  growth  of  the  quotient algebra can be studied with [2XDetermineGrowthQA[0m
  ([14X3.6-1[0m).  The  first argument is the list of leading monomials, which can be
  calculated  with  [2XLMonsNP[0m  ([14X3.3-10[0m).  The second argument is the size of the
  alphabet.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> L:=LMonsNP(GB);;[0X
    [4Xgap> DetermineGrowthQA(L,6,false);[0X
    [4X4[0X
    [4Xgap> time;[0X
    [4X0[0X
  [4X------------------------------------------------------------------[0X
  
  Now  compute  the  first 10 terms of the Hilbert Series with [2XHilbertSeriesQA[0m
  ([14X3.6-3[0m) (note that trailing zeroes are removed):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> HilbertSeriesQA(L,6,10);[0X
    [4X[ 1, 4, 10, 20, 35, 56, 84, 120, 165, 220, 286 ][0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.16 An algebra over a finite field[0X
  
  A  small example over a field other than the rationals, using the conversion
  functions from [14X3.1[0m. The input relations define the symmetric group of degree
  3, denoted S_3.
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 2
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 1 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,2);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[0X
  [4X------------------------------------------------------------------[0X
  
  Let [10XF[0m be the field GF(2). The relations can be entered as elements of a free
  associative      algebra      with      one      [10XA[0m      (see      [14XReference:
  FreeAssociativeAlgebraWithOne[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> F:=GF(2);;[0X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(F,"a","b");[0X
    [4X<algebra-with-one over GF(2), with 2 generators>[0X
    [4Xgap> g:=GeneratorsOfAlgebraWithOne(A);[0X
    [4X[ (Z(2)^0)*a, (Z(2)^0)*b ][0X
  [4X------------------------------------------------------------------[0X
  
  Enter  the  relations  a^2-1,b^2-1,(ab)^3-1,  convert  them  to NP-form, see
  Section [14X2.1[0m, with [2XGP2NPList[0m ([14X3.1-2[0m) and print them with [2XPrintNPList[0m ([14X3.2-3[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> KI_GP := [ g[1]^2-g[1]^0, g[2]^2-g[1]^0, (g[1]*g[2])^3-g[1]^0];[0X
    [4X[ (Z(2)^0)*<identity ...>+(Z(2)^0)*a^2, (Z(2)^0)*<identity ...>+(Z(2)^0)*b^2, [0X
    [4X  (Z(2)^0)*<identity ...>+(Z(2)^0)*a*b*a*b*a*b ][0X
    [4Xgap> KI:=GP2NPList(KI_GP);;[0X
    [4Xgap> PrintNPList(KI);[0X
    [4X a^2 + Z(2)^0 [0X
    [4X b^2 + Z(2)^0 [0X
    [4X ababab + Z(2)^0 [0X
  [4X------------------------------------------------------------------[0X
  
  Now  calculate  the  GrÃ¶bner  basis  with [2XSGrobner[0m ([14X3.4-2[0m) and print it with
  [2XPrintNPList[0m ([14X3.2-3[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB:=SGrobner(KI);;[0X
    [4X#I  number of entered polynomials is 3[0X
    [4X#I  number of polynomials after reduction is 3[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  length of G =3[0X
    [4X#I  length of todo is 2[0X
    [4X#I  length of G =3[0X
    [4X#I  length of todo is 1[0X
    [4X#I  length of G =3[0X
    [4X#I  length of todo is 0[0X
    [4X#I  List of todo lengths is [ 2, 2, 1, 0 ][0X
    [4X#I  End of phase III[0X
    [4X#I  G: Cleaning finished, 0 polynomials reduced[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 8 msecs.[0X
    [4Xgap> PrintNPList(GB);[0X
    [4X a^2 + Z(2)^0 [0X
    [4X b^2 + Z(2)^0 [0X
    [4X bab + aba [0X
  [4X------------------------------------------------------------------[0X
  
  Now  calculate  the  dimension of the quotient algebra with [2XDimQA[0m ([14X3.5-2[0m) (2
  symbols)  and  a  base with [2XBaseQA[0m ([14X3.5-1[0m) (2 symbols, 0 for whole base) and
  print the base. This will give a list of elements of the group.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> DimQA(GB,2);[0X
    [4X6[0X
    [4Xgap> B:=BaseQA(GB,2,0);;[0X
    [4Xgap> PrintNPList(B);[0X
    [4X Z(2)^0 [0X
    [4X a [0X
    [4X b [0X
    [4X ab [0X
    [4X ba [0X
    [4X aba [0X
  [4X------------------------------------------------------------------[0X
  
  We  can  print  the  GrÃ¶bner  basis  and  the basis of the quotient algebra,
  converted back to GAP polynomials with [2XNP2GPList[0m ([14X3.1-4[0m). The functions used
  to  convert  the  polynomials  also  require the algebra as an argument. The
  result is useful for further computations in A.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> NP2GPList(GB,A);[0X
    [4X[ (Z(2)^0)*a^2+(Z(2)^0)*<identity ...>, (Z(2)^0)*b^2+(Z(2)^0)*<identity ...>, [0X
    [4X  (Z(2)^0)*b*a*b+(Z(2)^0)*a*b*a ][0X
    [4Xgap> NP2GPList(B,A);[0X
    [4X[ (Z(2)^0)*<identity ...>, (Z(2)^0)*a, (Z(2)^0)*b, (Z(2)^0)*a*b, [0X
    [4X  (Z(2)^0)*b*a, (Z(2)^0)*a*b*a ][0X
  [4X------------------------------------------------------------------[0X
  
  The  matrix of right multiplication with the image of the first variable can
  be computed by [2XMatrixQA[0m ([14X3.5-3[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> Display(MatrixQA(1,B,GB));[0X
    [4X . 1 . . . .[0X
    [4X 1 . . . . .[0X
    [4X . . . . 1 .[0X
    [4X . . . . . 1[0X
    [4X . . 1 . . .[0X
    [4X . . . 1 . .[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.17 The dihedral group of order 8[0X
  
  In this example (Example 1 from Linton [Lin93]) the two-sided relations give
  the  group algebra of the group with presentation < a,b | a^4=b^2=(ab)^2=1>,
  the  dihedral  group  of  order 8. It is possible to construct a permutation
  module  of  degree 4, over a field [10Xk[0m. In this example [10Xk[0m will be the field of
  rational numbers.
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 1
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 1 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[0X
  [4X------------------------------------------------------------------[0X
  
  Now  enter  the  relations  as GAP polynomials. It is possible to enter them
  with  and  without  module  generators.  First  it is shown how to enter the
  relations  without  using a module. It is possible to enter them with a free
  associative algebra with one over the field (the rational numbers) (see also
  [14XReference:   FreeAssociativeAlgebraWithOne[0m).  For  convenience  we  use  the
  variables [10Xa[0m and [10Xb[0m for the generators of the algebra and [10Xe[0m for the one of the
  algebra.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(Rationals, "a", "b");[0X
    [4X<algebra-with-one over Rationals, with 2 generators>[0X
    [4Xgap> a:=A.a;;b:=A.b;;e:=One(A);;[0X
  [4X------------------------------------------------------------------[0X
  
  Now the relations are entered:
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> twosidrels:=[a^4-e,b^2-e,(a*b)^2-e];;[0X
    [4Xgap> prefixrels:=[b-e];;[0X
  [4X------------------------------------------------------------------[0X
  
  First  the  relations  are  converted into NP format, see Section [14X2.1[0m, after
  which  the  function [2XSGrobnerModule[0m ([14X3.9-1[0m) is called to calculate a GrÃ¶bner
  basis record.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBR:=SGrobnerModule(GP2NPList(prefixrels),GP2NPList(twosidrels));;[0X
    [4X#I  number of entered polynomials is 3[0X
    [4X#I  number of polynomials after reduction is 3[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  End of phase III[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 8 msecs.[0X
    [4X#I  number of entered polynomials is 7[0X
    [4X#I  number of polynomials after reduction is 7[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  End of phase III[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 0 msecs.[0X
  [4X------------------------------------------------------------------[0X
  
  The  record  GBR  has  two  members:  the two-sided relations [10XGBR.ts[0m and the
  prefix  relations  [10XGBR.p[0m.  It  is possible to print these using the function
  [2XPrintNPList[0m ([14X3.2-3[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(GBR.ts);[0X
    [4X b^2 - 1 [0X
    [4X aba - b [0X
    [4X ba^2 - a^2b [0X
    [4X bab - a^3 [0X
    [4X a^4 - 1 [0X
    [4X a^3b - ba [0X
    [4Xgap> PrintNPList(GBR.p);[0X
    [4X[ b - 1 ][0X
    [4X[ a^3 - ab ][0X
    [4X[ a^2b - a^2 ][0X
  [4X------------------------------------------------------------------[0X
  
  It  is  now  possible to calculate the standard basis of the quotient module
  with the function [2XBaseQM[0m ([14X3.9-2[0m). This function has as arguments the GrÃ¶bner
  basis record [10XGBR[0m, the number of generators of the algebra (2), the number of
  generators  of  the  module  (1), and a variable [10Xmaxno[0m for returning partial
  bases (0 means full basis).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> B:=BaseQM(GBR,2,1,0);;[0X
    [4Xgap> PrintNPList(B);[0X
    [4X[ 1 ][0X
    [4X[ a ][0X
    [4X[ a^2 ][0X
    [4X[ ab ][0X
  [4X------------------------------------------------------------------[0X
  
  It  is  also  possible  to  use  a  module with one generator to enter these
  relations:
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> D:=A^1;;[0X
    [4Xgap> gd:=GeneratorsOfLeftModule(D);;[0X
    [4Xgap> prefixrelsdom:=[gd[1]*(b-e)];;[0X
  [4X------------------------------------------------------------------[0X
  
  It  is  possible  to  use  the  two-sided  GrÃ¶bner  basis  which was already
  calculated.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBR:=SGrobnerModule(GP2NPList(prefixrelsdom),GBR.ts);;[0X
    [4X#I  number of entered polynomials is 6[0X
    [4X#I  number of polynomials after reduction is 6[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  End of phase III[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 4 msecs.[0X
    [4X#I  number of entered polynomials is 7[0X
    [4X#I  number of polynomials after reduction is 7[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  End of phase III[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 0 msecs.[0X
    [4Xgap> PrintNPList(GBR.p);;[0X
    [4X[ b - 1 ][0X
    [4X[ a^3 - ab ][0X
    [4X[ a^2b - a^2 ][0X
    [4Xgap> B:=BaseQM(GBR,2,1,0);;[0X
    [4Xgap> PrintNPList(B);[0X
    [4X[ 1 ][0X
    [4X[ a ][0X
    [4X[ a^2 ][0X
    [4X[ ab ][0X
  [4X------------------------------------------------------------------[0X
  
  To   compute  the  image  of  right  multiplication  of  the  basis  element
  [10XB[Length(B)][0m  of  the module with the quotient algebra element corresponding
  to  ab  we  use  the  function  [2XMulQM[0m  ([14X3.9-4[0m)  with arguments [10XB[Length(B)][0m,
  [10XGB2NP(a*b)[0m,  and  [10XGBR[0m  We  subsequently  use  [2XPrintNP[0m ([14X3.2-1[0m) to display the
  result as a 1-dimensional vector with an entry from A.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> v := MulQM(B[Length(B)],GP2NP(a*b),GBR);[0X
    [4X[ [ [ -1 ] ], [ 1 ] ][0X
    [4Xgap> PrintNP(v);[0X
    [4X[ 1 ][0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.18 The dihedral group of order 8 on another module[0X
  
  In this example (Example 2 from Linton [Lin93]) the two-sided relations give
  the  group  algebra of the group with presentation < a,b| a^4=b^2=(ab)^2=1>,
  the dihedral group of order 8. This module relation fixes the all-one vector
  of Example [14XA.17[0m: 1 + a(1+a+b).
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 0
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 0 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,0);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,0);[0X
  [4X------------------------------------------------------------------[0X
  
  We  will  enter  the  relations  as GAP polynomials. It is possible to enter
  these  with  and  without  a  module.  How  to do this is shown in [14XA.17[0m. The
  relations  here  are  entered  without  a  module,  since the module is only
  one-dimensional.  It  is  possible  to  enter  them using a free associative
  algebra  with one over the field (the rational numbers) (see also [14XReference:
  FreeAssociativeAlgebraWithOne[0m). For convenience we use the variables [10Xa[0m and [10Xb[0m
  for the generators of the algebra and [10Xe[0m for the one of the algebra.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(Rationals, "a", "b");[0X
    [4X<algebra-with-one over Rationals, with 2 generators>[0X
    [4Xgap> g:=GeneratorsOfAlgebra(A);;[0X
    [4Xgap> a:=g[2];;b:=g[3];;e:=g[1];;[0X
  [4X------------------------------------------------------------------[0X
  
  Now the relations are entered:
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> twosidrels:=[a^4-e,b^2-e,(a*b)^2-e];;[0X
    [4Xgap> prefrels:=[ b-e, e + a * (e + a + b) ];;[0X
  [4X------------------------------------------------------------------[0X
  
  First  the  relations are converted into NP format (see [14X2.1[0m) after which the
  function  [2XSGrobnerModule[0m  ([14X3.9-1[0m)  is  called  to  calculate a GrÃ¶bner basis
  record.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBR:=SGrobnerModule(GP2NPList(prefrels),GP2NPList(twosidrels));;[0X
  [4X------------------------------------------------------------------[0X
  
  The  record  GBR  has  two  members:  the two-sided relations [10XGBR.ts[0m and the
  prefix  relations  [10XGBR.p[0m.  It  is possible to print these using the function
  [2XPrintNPList[0m ([14X3.2-3[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(GBR.ts);[0X
    [4X b^2 - 1 [0X
    [4X aba - b [0X
    [4X ba^2 - a^2b [0X
    [4X bab - a^3 [0X
    [4X a^4 - 1 [0X
    [4X a^3b - ba [0X
    [4Xgap> PrintNPList(GBR.p);[0X
    [4X[ b - 1 ][0X
    [4X[ ab + a^2 + a + 1 ][0X
    [4X[ a^3 + a^2 + a + 1 ][0X
    [4X[ a^2b - a^2 ][0X
  [4X------------------------------------------------------------------[0X
  
  It  is  now  possible to calculate the standard basis of the quotient module
  with the function [2XBaseQM[0m ([14X3.9-2[0m). This function has as arguments the GrÃ¶bner
  basis  record  [10XGBR[0m,  the number of generators of the algebra (here it is 2),
  the  number of generators of the mdoule (here it is 1), and a variable [10Xmaxno[0m
  for returning partial bases (0 means full basis).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> B:=BaseQM(GBR,2,1,0);;[0X
    [4Xgap> PrintNPList(B);[0X
    [4X[ 1 ][0X
    [4X[ a ][0X
    [4X[ a^2 ][0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.19 The dihedral group on a non-cyclic module[0X
  
  In  this  example  (Example  3 from Linton [Lin93]), the two-sided relations
  give   the   group   algebra   of   the   group  with  presentation  <  a,b|
  a^4=b^2=(ab)^2=1>,   the  dihedral  group  of  order  8.  The  module  under
  construction  is  a  non-cyclic module, obtained by taking two copies of the
  representation of Example [14XA.17[0m and fusing their one-dimensional submodules.
  
  Load  the  package  and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 1 and
  the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 1 (for more information about the
  info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[0X
  [4X------------------------------------------------------------------[0X
  
  Create the free associative algebra to enter the relations in:
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(Rationals, "a", "b");[0X
    [4X<algebra-with-one over Rationals, with 2 generators>[0X
    [4Xgap> g:=GeneratorsOfAlgebra(A);;[0X
    [4Xgap> a:=g[2];;b:=g[3];;e:=g[1];;[0X
  [4X------------------------------------------------------------------[0X
  
  Now the relations are entered:
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> twosidrels:=[a^4-e,b^2-e,(a*b)^2-e];;[0X
    [4Xgap> D:=A^2;;[0X
    [4Xgap> y:=GeneratorsOfLeftModule(D);;[0X
    [4Xgap> modrels:=[y[1]*b-y[1], y[2]*b-y[2], y[1]+y[1]*a*(e+a+b) -y[2]-y[2]*a*(e+a+b)];;[0X
  [4X------------------------------------------------------------------[0X
  
  First the relations are converted into NP format (see [14X2.1[0m) with the function
  [2XGP2NPList[0m  ([14X3.1-2[0m).  They are printed in raw form and subsequently in a more
  legible format.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> modrelsNP:=GP2NPList(modrels);[0X
    [4X[ [ [ [ -1, 2 ], [ -1 ] ], [ 1, -1 ] ], [ [ [ -2, 2 ], [ -2 ] ], [ 1, -1 ] ], [0X
    [4X  [ [ [ -1, 1, 2 ], [ -1, 1, 1 ], [ -2, 1, 2 ], [ -2, 1, 1 ], [ -1, 1 ], [0X
    [4X          [ -2, 1 ], [ -1 ], [ -2 ] ], [ 1, 1, -1, -1, 1, -1, 1, -1 ] ] ][0X
    [4Xgap> PrintNPList(modrelsNP);[0X
    [4X[ b - 1 , 0][0X
    [4X[ 0, b - 1 ][0X
    [4X[ ab + a^2 + a + 1 , - ab - a^2 - a - 1 ][0X
  [4X------------------------------------------------------------------[0X
  
  Next  the  function  [2XSGrobnerModule[0m ([14X3.9-1[0m) is called to calculate a GrÃ¶bner
  basis record (see [14X2.8[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBR:=SGrobnerModule(modrelsNP,GP2NPList(twosidrels));;[0X
    [4X#I  number of entered polynomials is 3[0X
    [4X#I  number of polynomials after reduction is 3[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  End of phase III[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 8 msecs.[0X
    [4X#I  number of entered polynomials is 9[0X
    [4X#I  number of polynomials after reduction is 9[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  End of phase III[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 4 msecs.[0X
  [4X------------------------------------------------------------------[0X
  
  The  record  [10XGBR[0m  has  two  members:  the two-sided relations [10XGBR.ts[0m and the
  prefix  relations  [10XGBR.p[0m.  It  is possible to print these using the function
  [2XPrintNPList[0m ([14X3.2-3[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(GBR.ts);[0X
    [4X b^2 - 1 [0X
    [4X aba - b [0X
    [4X ba^2 - a^2b [0X
    [4X bab - a^3 [0X
    [4X a^4 - 1 [0X
    [4X a^3b - ba [0X
    [4Xgap> PrintNPList(GBR.p);[0X
    [4X[ 0, b - 1 ][0X
    [4X[ b - 1 , 0][0X
    [4X[ ab + a^2 + a + 1 , - ab - a^2 - a - 1 ][0X
    [4X[ 0, a^3 - ab ][0X
    [4X[ 0, a^2b - a^2 ][0X
    [4X[ a^3 + a^2 + a + 1 , - ab - a^2 - a - 1 ][0X
    [4X[ a^2b - a^2 , 0][0X
  [4X------------------------------------------------------------------[0X
  
  It  is  now  possible to calculate the standard basis of the quotient module
  with the function [2XBaseQM[0m ([14X3.9-2[0m). This function has as arguments the GrÃ¶bner
  basis  record [10XGBR[0m, the number of generators of the algebra (in this case 2),
  the  number  of  generators  of  the module (in this case 2), and a variable
  [10Xmaxno[0m for returning partial bases (0 means full basis).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> B:=BaseQM(GBR,2,2,0);;[0X
    [4Xgap> PrintNPList(B);[0X
    [4X[ 0, 1 ][0X
    [4X[ 1 , 0][0X
    [4X[ 0, a ][0X
    [4X[ a , 0][0X
    [4X[ 0, a^2 ][0X
    [4X[ 0, ab ][0X
    [4X[ a^2 , 0][0X
  [4X------------------------------------------------------------------[0X
  
  It  is  also possible to convert each member of the list [10XB[0m of polynomials in
  NP  form to GAP polynomials to do further calculations within the algebra or
  module. This can be done with the function [2XNP2GPList[0m ([14X3.1-4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> NP2GPList(B,D);[0X
    [4X[ [ <zero> of ..., (1)*<identity ...> ], [ (1)*<identity ...>, <zero> of ... ][0X
    [4X    , [ <zero> of ..., (1)*a ], [ (1)*a, <zero> of ... ], [0X
    [4X  [ <zero> of ..., (1)*a^2 ], [ <zero> of ..., (1)*a*b ], [0X
    [4X  [ (1)*a^2, <zero> of ... ] ][0X
  [4X------------------------------------------------------------------[0X
  
  Individual  GAP polynomials can be obtained from polynomials in NP form with
  the  function [2XNP2GP[0m ([14X3.1-3[0m). This also holds for elements of the free module
  [10XD[0m in NP form.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> Display(NP2GP(B[Length(B)],D));[0X
    [4X[ (1)*a^2, <zero> of ... ][0X
  [4X------------------------------------------------------------------[0X
  
  Next  we  write  down the matrices for the right action of the generators on
  the module by means of [2XMatrixQA[0m ([14X3.5-3[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> Display(MatrixQA(1,B,GBR));[0X
    [4X[ [   0,   0,   1,   0,   0,   0,   0 ],[0X
    [4X  [   0,   0,   0,   1,   0,   0,   0 ],[0X
    [4X  [   0,   0,   0,   0,   1,   0,   0 ],[0X
    [4X  [   0,   0,   0,   0,   0,   0,   1 ],[0X
    [4X  [   0,   0,   0,   0,   0,   1,   0 ],[0X
    [4X  [   1,   0,   0,   0,   0,   0,   0 ],[0X
    [4X  [   1,  -1,   1,  -1,   1,   1,  -1 ] ][0X
    [4Xgap> Display(MatrixQA(2,B,GBR)); [0X
    [4X[ [   1,   0,   0,   0,   0,   0,   0 ],[0X
    [4X  [   0,   1,   0,   0,   0,   0,   0 ],[0X
    [4X  [   0,   0,   0,   0,   0,   1,   0 ],[0X
    [4X  [   1,  -1,   1,  -1,   1,   1,  -1 ],[0X
    [4X  [   0,   0,   0,   0,   1,   0,   0 ],[0X
    [4X  [   0,   0,   1,   0,   0,   0,   0 ],[0X
    [4X  [   0,   0,   0,   0,   0,   0,   1 ] ][0X
  [4X------------------------------------------------------------------[0X
  
  In  order to compute the image of the vector 2y[1]+3y[2] of the two standard
  generators  of  the  module  under  the  action  of  the element aab, we use
  [2XStrongNormalFormNPM[0m  ([14X3.9-5[0m).  Its first argument will be the vector and its
  second  the GrÃ¶bner basis. The transformation [2XGP2NP[0m ([14X3.1-1[0m) to the NP format
  needs to be applied to the vector before it can be used as an argument.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> v:=StrongNormalFormNPM(GP2NP((y[1]*2+y[2]*3)*a*a*b), GBR);;[0X
    [4Xgap> PrintNP(v);[0X
    [4X[ 2a^2 , 3a^2 ][0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.20 The icosahedral group[0X
  
  In  this example the two-sided relations give the group algebra of the group
  with   presentation   <  a,b,c  |  a^2=b^2=c^2=(ab)^3=(bc)^5=(ac)^2=1>,  the
  icosahedral  group  of order 120. This is the Coxeter group of type H_3. The
  module under construction is a 3-dimensional reflection representation,
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 1
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 1 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[0X
  [4X------------------------------------------------------------------[0X
  
  Create the field containing the golden ratio [10Xtau[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> x := Indeterminate(Rationals,"x");[0X
    [4Xx[0X
    [4Xgap> p := x^2+ x-1;[0X
    [4Xx^2+x-1[0X
    [4Xgap> K := AlgebraicExtension(Rationals,p);[0X
    [4X<algebraic extension over the Rationals of degree 2>[0X
    [4Xgap> tau:=RootOfDefiningPolynomial(K);[0X
    [4X(a)[0X
  [4X------------------------------------------------------------------[0X
  
  Create the free algebra with three generators over this field:
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(K, "a", "b", "c");[0X
    [4X<algebra-with-one over <algebraic extension over the Rationals of degree [0X
    [4X2>, with 3 generators>[0X
    [4Xgap> e:=One(A);; a:=A.a;; b:=A.b;; c:=A.c;;[0X
  [4X------------------------------------------------------------------[0X
  
  The  ideal  for a quotient of the icosahedral group algebra over this field,
  in which [10Xb[0m*[10Xc[0m has a quadratic minimal polynomial involving [10Xtau[0m:
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> #(b*c)^2-tau*b*c+e[0X
    [4Xgap> Irels:=[a^2-e,b^2-e,c^2-e,a*b*a-b*a*b,((b*c)^2-tau*b*c+e)*(b*c-e),a*c-c*a];[0X
    [4X[ (!-1)*<identity ...>+(!1)*a^2, (!-1)*<identity ...>+(!1)*b^2, [0X
    [4X  (!-1)*<identity ...>+(!1)*c^2, (!1)*a*b*a+(!-1)*b*a*b, [0X
    [4X  (!-1)*<identity ...>+((1+a))*b*c+((-1-1*a))*b*c*b*c+(!1)*b*c*b*c*b*c, [0X
    [4X  (!1)*a*c+(!-1)*c*a ][0X
  [4X------------------------------------------------------------------[0X
  
  We  now  give  module  relations. The first two describe group elements of a
  vector  stabilizer,  the  third  forces  the  central  element (abc)^5 to be
  nontrivial.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> Mrels:=[b*c-e,b-e,(a*b*c)^5+e];;[0X
  [4X------------------------------------------------------------------[0X
  
  First the relations are converted into NP format (see [14X2.1[0m) with the function
  [2XGP2NPList[0m  ([14X3.1-2[0m).  Next  the  function [2XSGrobnerModule[0m ([14X3.9-1[0m) is called to
  calculate a GrÃ¶bner basis record (see [14X2.8[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBR:=SGrobnerModule(GP2NPList(Mrels),GP2NPList(Irels));;[0X
    [4X#I  number of entered polynomials is 6[0X
    [4X#I  number of polynomials after reduction is 6[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  End of phase III[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 28 msecs.[0X
    [4X#I  number of entered polynomials is 12[0X
    [4X#I  number of polynomials after reduction is 12[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  End of phase III[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 136 msecs.[0X
    [4Xgap> PrintNPList(GBR.ts);;[0X
    [4X a^2 + !-1 [0X
    [4X b^2 + !-1 [0X
    [4X ca + !-1ac [0X
    [4X c^2 + !-1 [0X
    [4X bab + !-1aba [0X
    [4X cbc + !-1bcb + (-1-1*a)c + (1+a)b [0X
    [4X bcba + !-1acba + !-1abcb + abac + cb + !-1bc + (-2-1*a)ba + (2+a)ab [0X
    [4X cbac + !-1acba + !-1abcb + abac + cb + !-1bc + !-1ba + (-1-1*a)ac + (2+a)ab [0X
    [4X bacba + abacb + !-1cba + !-1bcb + !-1abc + (-2-1*a)aba + c + (2+a)a [0X
    [4Xgap> PrintNPList(GBR.p);;[0X
    [4X[ b + !-1 ][0X
    [4X[ c + !-1 ][0X
    [4X[ ac + !-1a ][0X
    [4X[ aba + !-1ab ][0X
    [4X[ abc + ab + (-1*a)a + (-1*a) ][0X
  [4X------------------------------------------------------------------[0X
  
  It  is  now possible to calculate the basis of the quotient algebra with the
  function  [2XBaseQM[0m  ([14X3.9-2[0m).  This function has as arguments the GrÃ¶bner basis
  record  [10XGBR[0m,  the  number of generators of the algebra (in this case 3), the
  number  of generators of the free module in which the vectors are chosen (in
  this  case  1), and a variable [10Xmaxno[0m for returning partial quotient algebras
  (0 means full basis).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> B:=BaseQM(GBR,3,1,0);;[0X
    [4Xgap> PrintNPList(B);[0X
    [4X[ !1 ][0X
    [4X[ a ][0X
    [4X[ ab ][0X
  [4X------------------------------------------------------------------[0X
  
  Calculate  the  dimension  of  the  quotient algebra with the function [2XDimQM[0m
  ([14X3.9-3[0m).  This  function  has as arguments the GrÃ¶bner basis record [10XGBR[0m, the
  number  of  generators  of  the  algebra  (in this case 3) and the number of
  generators of the module (in this case 1).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> DimQM(GBR,3,1);[0X
    [4X3[0X
  [4X------------------------------------------------------------------[0X
  
  Next  we  write  down the matrices for the right action of the generators on
  the module by means of [2XMatrixQA[0m ([14X3.5-3[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> aa := MatrixQA(1,B,GBR);;[0X
    [4Xgap> Display(aa);[0X
    [4X[ [  !0,  !1,  !0 ],[0X
    [4X  [  !1,  !0,  !0 ],[0X
    [4X  [  !0,  !0,  !1 ] ][0X
    [4Xgap> bb := MatrixQA(2,B,GBR);;[0X
    [4Xgap> Display(bb);[0X
    [4X[ [  !1,  !0,  !0 ],[0X
    [4X  [  !0,  !0,  !1 ],[0X
    [4X  [  !0,  !1,  !0 ] ][0X
    [4Xgap> cc := MatrixQA(3,B,GBR);;[0X
    [4Xgap> Display(cc);[0X
    [4X[ [   !1,   !0,   !0 ],[0X
    [4X  [   !0,   !1,   !0 ],[0X
    [4X  [  (a),  (a),  !-1 ] ][0X
  [4X------------------------------------------------------------------[0X
  
  Finally  we  check  the  defining relations for the icosahedral group on the
  three  new matrix generators. This can be done by verifying if the result is
  equal to the identity matrix or with the function [2XIsOne[0m ([14XReference: IsOne[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> ee := IdentityMat(3,K);;[0X
    [4Xgap> Display(ee);[0X
    [4X[ [  !1,  !0,  !0 ],[0X
    [4X  [  !0,  !1,  !0 ],[0X
    [4X  [  !0,  !0,  !1 ] ][0X
    [4Xgap> aa^2 = ee;[0X
    [4Xtrue[0X
    [4Xgap> IsOne(aa^2);[0X
    [4Xtrue[0X
    [4Xgap> IsOne(bb^2);[0X
    [4Xtrue[0X
    [4Xgap> IsOne(cc^2);[0X
    [4Xtrue[0X
    [4Xgap> IsOne((aa*bb)^3);[0X
    [4Xtrue[0X
    [4Xgap> IsOne((aa*cc)^2);[0X
    [4Xtrue[0X
    [4Xgap> IsOne((bb*cc)^5);[0X
    [4Xtrue[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.21 The symmetric inverse monoid for a set of size four[0X
  
  The  algebra  we  will  consider  is from Example 4 from Linton [Lin93]. Its
  monomials  form  the  symmetric  inverse  monoid, that is, the monoid of all
  partial  bijections on a given set, for a set of size four. The presentation
  is   <   s_1,s_2,s_3,e|   s_i^2=(s_1s_2)^3=(s_2s_3)^3=(s_1s_3)^2=1,   e^2=e,
  s_1e=es_1,s_2e=es_2,es_3e=(es_3)^2=(s_3e)^2>.  The  dimension  of the monoid
  algebra is 209. The monoid has a natural representation of degree 4 by means
  of  partial  permutation  matrices,  which  can be obtained by taking prefix
  relations e,s_1-1, s_2-1, s_3e-s_3.
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 1
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 1 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[0X
  [4X------------------------------------------------------------------[0X
  
  Now enter the relations as GAP polynomials. The module is one dimensional so
  it  is  possible to enter it with and without a module. In Example 18 ([14XA.17[0m)
  both  ways  are  shown. Here the relations will be entered without a module,
  with  a  free  associative  algebra  with  one  over the field (the rational
  numbers)    (see   also   [14XReference:   FreeAssociativeAlgebraWithOne[0m).   For
  convenience we use the variables [10Xs1[0m, [10Xs2[0m, [10Xs3[0m, and [10Xe[0m for the generators of the
  algebra, and [10Xo[0m for the identity element of the algebra.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(Rationals, "s1", "s2", "s3", "e");[0X
    [4X<algebra-with-one over Rationals, with 4 generators>[0X
    [4Xgap> g:=GeneratorsOfAlgebra(A);;[0X
    [4Xgap> s1:=g[2];;s2:=g[3];;s3:=g[4];;e:=g[5];;o:=g[1];;[0X
  [4X------------------------------------------------------------------[0X
  
  It  is possible to print symbols like they are printed in the algebra [10XA[0m with
  the function [2XGBNP.ConfigPrint[0m ([14X3.2-2[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBNP.ConfigPrint(A);[0X
  [4X------------------------------------------------------------------[0X
  
  Now the relations are entered:
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> twosidrels:=[s1^2-o,s2^2-o,s3^2-o,(s1*s2)^3-o,(s2*s3)^3-o,(s1*s3)^2-o,[0X
    [4X> 	e^2-e,s1*e-e*s1,s2*e-e*s2,e*s3*e-(e*s3)^2,e*s3*e-(s3*e)^2];[0X
    [4X[ (-1)*<identity ...>+(1)*s1^2, (-1)*<identity ...>+(1)*s2^2, [0X
    [4X  (-1)*<identity ...>+(1)*s3^2, (-1)*<identity ...>+(1)*s1*s2*s1*s2*s1*s2, [0X
    [4X  (-1)*<identity ...>+(1)*s2*s3*s2*s3*s2*s3, [0X
    [4X  (-1)*<identity ...>+(1)*s1*s3*s1*s3, (-1)*e+(1)*e^2, (1)*s1*e+(-1)*e*s1, [0X
    [4X  (1)*s2*e+(-1)*e*s2, (1)*e*s3*e+(-1)*e*s3*e*s3, (1)*e*s3*e+(-1)*s3*e*s3*e ][0X
    [4Xgap> prefixrels:=[e,s1-o,s2-o,s3*e-s3];[0X
    [4X[ (1)*e, (-1)*<identity ...>+(1)*s1, (-1)*<identity ...>+(1)*s2, [0X
    [4X  (-1)*s3+(1)*s3*e ][0X
  [4X------------------------------------------------------------------[0X
  
  First  the  relations  are  converted  into NP format (see [14X2.1[0m) and next the
  function  [2XSGrobnerModule[0m  ([14X3.9-1[0m)  is  called  to  calculate a GrÃ¶bner basis
  record.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBR:=SGrobnerModule(GP2NPList(prefixrels),GP2NPList(twosidrels));;[0X
    [4X#I  number of entered polynomials is 11[0X
    [4X#I  number of polynomials after reduction is 11[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  End of phase III[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 36 msecs.[0X
    [4X#I  number of entered polynomials is 42[0X
    [4X#I  number of polynomials after reduction is 42[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  End of phase III[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 24 msecs.[0X
  [4X------------------------------------------------------------------[0X
  
  The  record  GBR  has  two  members:  the two-sided relations [10XGBR.ts[0m and the
  prefix  relations  [10XGBR.p[0m.  We  print  these  using  the function [2XPrintNPList[0m
  ([14X3.2-3[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(GBR.ts);[0X
    [4X s1^2 - 1 [0X
    [4X s2^2 - 1 [0X
    [4X s3s1 - s1s3 [0X
    [4X s3^2 - 1 [0X
    [4X es1 - s1e [0X
    [4X es2 - s2e [0X
    [4X e^2 - e [0X
    [4X s2s1s2 - s1s2s1 [0X
    [4X s3s2s3 - s2s3s2 [0X
    [4X s3s2s1s3 - s2s3s2s1 [0X
    [4X s3es3e - es3e [0X
    [4X es3es3 - es3e [0X
    [4X s3es3s2e - es3s2e [0X
    [4X s2s3s2es3e - s3s2es3e [0X
    [4X s3es3s2s1e - es3s2s1e [0X
    [4X es3s2es3s2 - es3s2es3 [0X
    [4X s2s3s2s1es3e - s3s2s1es3e [0X
    [4X s2s3s2es3s2e - s3s2es3s2e [0X
    [4X s2es3s2es3e - es3s2es3e [0X
    [4X s1s2s1s3s2es3e - s2s1s3s2es3e [0X
    [4X s2s3s2s1es3s2e - s3s2s1es3s2e [0X
    [4X s2s3s2es3s2s1e - s3s2es3s2s1e [0X
    [4X s2es3s2s1es3e - es3s2s1es3e [0X
    [4X es3s2s1es3s2s1 - es3s2s1es3s2 [0X
    [4X s1s2s1s3s2s1es3e - s2s1s3s2s1es3e [0X
    [4X s1s2s1s3s2es3s2e - s2s1s3s2es3s2e [0X
    [4X s1s2s1es3s2es3e - s2s1es3s2es3e [0X
    [4X s2s3s2s1es3s2s1e - s3s2s1es3s2s1e [0X
    [4X s2es3s2s1es3s2e - es3s2s1es3s2e [0X
    [4X s1s2s1s3s2s1es3s2e - s2s1s3s2s1es3s2e [0X
    [4X s1s2s1s3s2es3s2s1e - s2s1s3s2es3s2s1e [0X
    [4X s1s2s1es3s2s1es3e - s2s1es3s2s1es3e [0X
    [4X s1s3s2s1es3s2es3e - s3s2s1es3s2es3e [0X
    [4X s1s2s1s3s2s1es3s2s1e - s2s1s3s2s1es3s2s1e [0X
    [4X s1s2s1es3s2s1es3s2e - s2s1es3s2s1es3s2e [0X
    [4X s1s3s2s1es3s2s1es3e - s3s2s1es3s2s1es3e [0X
    [4X s1es3s2s1es3s2es3e - es3s2s1es3s2es3e [0X
    [4X s1s3s2s1es3s2s1es3s2e - s3s2s1es3s2s1es3s2e [0X
    [4Xgap> PrintNPList(GBR.p);[0X
    [4X[ s1 - 1 ][0X
    [4X[ s2 - 1 ][0X
    [4X[ e ][0X
    [4X[ s3e - s3 ][0X
    [4X[ s3s2e - s3s2 ][0X
    [4X[ s3s2s1e - s3s2s1 ][0X
  [4X------------------------------------------------------------------[0X
  
  It  is  now  possible to calculate the standard basis of the quotient module
  with the function [2XBaseQM[0m ([14X3.9-2[0m). This function has as arguments the GrÃ¶bner
  basis  record [10XGBR[0m, the number of generators of the algebra (here this is 4),
  the  number  of  generators  of  the module (here this is 1), and a variable
  [10Xmaxno[0m for returning partial bases (0 means full basis).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> B:=BaseQM(GBR,4,1,0);;[0X
    [4Xgap> PrintNPList(B);[0X
    [4X[ 1 ][0X
    [4X[ s3 ][0X
    [4X[ s3s2 ][0X
    [4X[ s3s2s1 ][0X
  [4X------------------------------------------------------------------[0X
  
  Next  we  write  down the matrices for the right action of the generators on
  the  module. First by means of the list command [2XMatricesQA[0m ([14X3.5-4[0m), next one
  by one by means of [2XMatrixQA[0m ([14X3.5-3[0m) within a loop.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> MatricesQA(4,B,GBR);[0X
    [4X[ [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 0, 1 ], [ 0, 0, 1, 0 ] ], [0X
    [4X  [ [ 1, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 0, 1 ] ], [0X
    [4X  [ [ 0, 1, 0, 0 ], [ 1, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ], [0X
    [4X  [ [ 0, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ] ][0X
    [4Xgap> for i in [1..4] do [0X
    [4X>   Display(MatrixQA(i,B,GBR)); Print("\n");[0X
    [4X> od;[0X
    [4X[ [  1,  0,  0,  0 ],[0X
    [4X  [  0,  1,  0,  0 ],[0X
    [4X  [  0,  0,  0,  1 ],[0X
    [4X  [  0,  0,  1,  0 ] ][0X
    [4X[0X
    [4X[ [  1,  0,  0,  0 ],[0X
    [4X  [  0,  0,  1,  0 ],[0X
    [4X  [  0,  1,  0,  0 ],[0X
    [4X  [  0,  0,  0,  1 ] ][0X
    [4X[0X
    [4X[ [  0,  1,  0,  0 ],[0X
    [4X  [  1,  0,  0,  0 ],[0X
    [4X  [  0,  0,  1,  0 ],[0X
    [4X  [  0,  0,  0,  1 ] ][0X
    [4X[0X
    [4X[ [  0,  0,  0,  0 ],[0X
    [4X  [  0,  1,  0,  0 ],[0X
    [4X  [  0,  0,  1,  0 ],[0X
    [4X  [  0,  0,  0,  1 ] ][0X
    [4X[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.22 A module of the Hecke algebra of type A_3 over GF(3)[0X
  
  This  example is an extension of Example 5 from Linton, [Lin93]. It concerns
  the  Hecke  Algebra of type A_3. By reducing mod 3 but without evaluating at
  q=1  it  is  possible  to  obtain  the following representation of the Hecke
  algebra     of     type     A_3     over     GF(3):     <     x,    y,    z|
  x^2+(1-q)*x-q,y^2+(1-q)*y-q,z^2+(1-q)*z-q,y*x*y-x*y*x,          z*y*z-y*z*y,
  z*x-x*z>.  It  has a natural representation of the same dimension as the Lie
  algebra  of type A_3, namely 4. This representation can be obtained with the
  module relations x+1,y+1.
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 1
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 1 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[0X
  [4X------------------------------------------------------------------[0X
  
  Now enter the relations as GAP polynomials. The module is one dimensional so
  it  is  possible  to  enter  it  with and without a module. Both are used in
  Example  [14XA.17[0m.  Here  the  relations will be entered without using a module.
  First  a free associative algebra with one is created over the field (GF(3))
  (see  also [14XReference: FreeAssociativeAlgebraWithOne[0m). For convenience we use
  the variables [10Xa[0m and [10Xb[0m for the generators of the algebra and [10Xe[0m for the one of
  the algebra.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> q:=Indeterminate(GF(3),"q");[0X
    [4Xq[0X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(Field(q), "x", "y", "z");;[0X
    [4Xgap> g:=GeneratorsOfAlgebra(A);;[0X
    [4Xgap> x:=g[2];;y:=g[3];;z:=g[4];;e:=g[1];;q:=q*e;;[0X
  [4X------------------------------------------------------------------[0X
  
  In  order to print the variables like they are printed in the algebra [10XA[0m with
  the function [2XGBNP.ConfigPrint[0m ([14X3.2-2[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBNP.ConfigPrint(A);[0X
  [4X------------------------------------------------------------------[0X
  
  Now the relations are entered:
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> twosidrels:=[x^2+(e-q)*x-q,y^2+(e-q)*y-q,z^2+(e-q)*z-q,[0X
    [4X>   y*x*y-x*y*x,z*y*z-y*z*y,z*x-x*z];[0X
    [4X[ (-q)*<identity ...>+(-q+Z(3)^0)*x+(Z(3)^0)*x^2, [0X
    [4X  (-q)*<identity ...>+(-q+Z(3)^0)*y+(Z(3)^0)*y^2, [0X
    [4X  (-q)*<identity ...>+(-q+Z(3)^0)*z+(Z(3)^0)*z^2, [0X
    [4X  (-Z(3)^0)*x*y*x+(Z(3)^0)*y*x*y, (-Z(3)^0)*y*z*y+(Z(3)^0)*z*y*z, [0X
    [4X  (-Z(3)^0)*x*z+(Z(3)^0)*z*x ][0X
    [4Xgap> prefixrels:=[x+e,y+e];[0X
    [4X[ (Z(3)^0)*<identity ...>+(Z(3)^0)*x, (Z(3)^0)*<identity ...>+(Z(3)^0)*y ][0X
  [4X------------------------------------------------------------------[0X
  
  First  the  relations are converted into NP format (see [14X2.1[0m) after which the
  function  [2XSGrobnerModule[0m  ([14X3.9-1[0m)  is  called  to  calculate a GrÃ¶bner basis
  record.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBR:=SGrobnerModule(GP2NPList(prefixrels),GP2NPList(twosidrels));;[0X
    [4X#I  number of entered polynomials is 6[0X
    [4X#I  number of polynomials after reduction is 6[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  End of phase III[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 16 msecs.[0X
    [4X#I  number of entered polynomials is 9[0X
    [4X#I  number of polynomials after reduction is 9[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  End of phase III[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 8 msecs.[0X
  [4X------------------------------------------------------------------[0X
  
  The record GBR has three members: the two-sided relations [10XGBR.ts[0m, the prefix
  relations  [10XGBR.p[0m, and the number [10XGBR.pg[0m of generators of the free module. It
  is possible to print the first two using the function [2XPrintNPList[0m ([14X3.2-3[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPList(GBR.ts);[0X
    [4X x^2 + -q+Z(3)^0x + -q [0X
    [4X y^2 + -q+Z(3)^0y + -q [0X
    [4X zx + -Z(3)^0xz [0X
    [4X z^2 + -q+Z(3)^0z + -q [0X
    [4X yxy + -Z(3)^0xyx [0X
    [4X zyz + -Z(3)^0yzy [0X
    [4X zyxz + -Z(3)^0yzyx [0X
    [4Xgap> PrintNPList(GBR.p);[0X
    [4X[ x + Z(3)^0 ][0X
    [4X[ y + Z(3)^0 ][0X
  [4X------------------------------------------------------------------[0X
  
  It  is  now  possible to calculate the standard basis of the quotient module
  with the function [2XBaseQM[0m ([14X3.9-2[0m). This function has as arguments the GrÃ¶bner
  basis  record [10XGBR[0m, the number of generators of the algebra (here this is 3),
  the  number  of  generators  of  the module (here this is 1), and a variable
  [10Xmaxno[0m for returning partial bases (0 means full basis).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> B:=BaseQM(GBR,3,1,0);;[0X
    [4Xgap> PrintNPList(B);[0X
    [4X[ Z(3)^0 ][0X
    [4X[ z ][0X
    [4X[ zy ][0X
    [4X[ zyx ][0X
  [4X------------------------------------------------------------------[0X
  
  Next  we  write  down the matrices for the right action of the generators on
  the module, by means of the command [2XMatricesQA[0m ([14X3.5-4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> MM := MatricesQA(3,B,GBR);;[0X
    [4Xgap> for i in [1..Length(MM)] do [0X
    [4X> Display(MM[i]); Print("\n"); [0X
    [4X> od;[0X
    [4X[ [   -Z(3)^0,    0*Z(3),    0*Z(3),    0*Z(3) ],[0X
    [4X  [    0*Z(3),   -Z(3)^0,    0*Z(3),    0*Z(3) ],[0X
    [4X  [    0*Z(3),    0*Z(3),    0*Z(3),    Z(3)^0 ],[0X
    [4X  [    0*Z(3),    0*Z(3),         q,  q-Z(3)^0 ] ][0X
    [4X[0X
    [4X[ [   -Z(3)^0,    0*Z(3),    0*Z(3),    0*Z(3) ],[0X
    [4X  [    0*Z(3),    0*Z(3),    Z(3)^0,    0*Z(3) ],[0X
    [4X  [    0*Z(3),         q,  q-Z(3)^0,    0*Z(3) ],[0X
    [4X  [    0*Z(3),    0*Z(3),    0*Z(3),   -Z(3)^0 ] ][0X
    [4X[0X
    [4X[ [    0*Z(3),    Z(3)^0,    0*Z(3),    0*Z(3) ],[0X
    [4X  [         q,  q-Z(3)^0,    0*Z(3),    0*Z(3) ],[0X
    [4X  [    0*Z(3),    0*Z(3),   -Z(3)^0,    0*Z(3) ],[0X
    [4X  [    0*Z(3),    0*Z(3),    0*Z(3),   -Z(3)^0 ] ][0X
    [4X[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.23 Generalized Temperley-Lieb algebras[0X
  
  This example shows how the dimension of a Generalized Temperley-Lieb Algebra
  of  type  A,  D,  or  E can be calculated. For textrmA_n-1 this is the usual
  Temperley-Lieb  Algebra  on n strands with dimension textrmdim TL(A_n-1)={2n
  choose n}/(n+1). For more information see [Gra95].
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 0
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 1 (for more information about
  timing; see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,0);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[0X
  [4X------------------------------------------------------------------[0X
  
  The  relations  are  generated  automatically from the Coxeter diagram. This
  example can be easily adapted by specifying the number of points and the set
  of  edges  describing  another  Coxeter  diagram.  First enter the number of
  points, [10Xnumpoints[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> numpoints:=8;[0X
    [4X8[0X
  [4X------------------------------------------------------------------[0X
  
  Now  define  some  edges describing the diagrams of textrmE_n, (these can be
  easily   extended).  In  this  example  the  dimension  of  the  Generalized
  Temperley-Lieb   algebra   of   type   textrmE_8  will  be  calculated.  For
  textrmA_1... 10 the command
  
  [10Xedges:=[[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10]];[0m
  
  can be used. For textrmD_1... 10 the command
  
  [10Xedges:=[[1,3],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10]];[0m can
  
  be used.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> edges:=[[1,3],[2,4],[3,4],[4,5],[5,6],[6,7],[7,8]]; # for E6..8[0X
    [4X[ [ 1, 3 ], [ 2, 4 ], [ 3, 4 ], [ 4, 5 ], [ 5, 6 ], [ 6, 7 ], [ 7, 8 ] ][0X
  [4X------------------------------------------------------------------[0X
  
  Now enter the relations as GAP polynomials. First a free associative algebra
  with  identity  element  is  created over the Rationals (see also [14XReference:
  FreeAssociativeAlgebraWithOne[0m). For convenience the generators are stored in
  [10Xgens[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(Rationals,numpoints,"e");;[0X
    [4Xgap> e := GeneratorsOfAlgebraWithOne(A);[0X
    [4X[ (1)*e.1, (1)*e.2, (1)*e.3, (1)*e.4, (1)*e.5, (1)*e.6, (1)*e.7, (1)*e.8 ][0X
  [4X------------------------------------------------------------------[0X
  
  It  is possible to print symbols like they are printed in the algebra [10XA[0m with
  the function [2XGBNP.ConfigPrint[0m ([14X3.2-2[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBNP.ConfigPrint(A);[0X
  [4X------------------------------------------------------------------[0X
  
  Now the relations are generated automatically. For this we need to make sure
  the edges are sorted and converted to a set.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> edges:=Set(edges, x->SortedList(x));[0X
    [4X[ [ 1, 3 ], [ 2, 4 ], [ 3, 4 ], [ 4, 5 ], [ 5, 6 ], [ 6, 7 ], [ 7, 8 ] ][0X
  [4X------------------------------------------------------------------[0X
  
  Now the relations can be generated. The relations are e_i*e_i=e_i, for all i
  and  e_i*e_j*e_i=e_i  for  all i,j that are connected in the Coxeter diagram
  and  e_i*e_j=e_j*e_i  for  all  i,  j  that are not connected in the Coxeter
  diagram.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> rels:=[];;[0X
    [4Xgap> for i in [1..numpoints] do[0X
    [4X>   for j in [1..numpoints] do[0X
    [4X>     if (i=j) then[0X
    [4X>       # if i=j then add e.i*e.i=e.i[0X
    [4X>       Add(rels, e[i]*e[i]-e[i]);[0X
    [4X>     elif ([i,j] in edges) or ([j,i] in edges) then[0X
    [4X>       # if {i,j} is an edge then add e.i*e.j*e.i=e.i [0X
    [4X>       Add(rels, e[i]*e[j]*e[i]- e[i]);[0X
    [4X>     else[0X
    [4X>       # if {i,j} is not an edge then add e.i*e.j=e.j*e.i [0X
    [4X>       # (note: this causes double rules, but that's ok)[0X
    [4X>       Add(rels, e[i]*e[j]- e[j]*e[i]);[0X
    [4X>     fi;[0X
    [4X>   od;[0X
    [4X> od;[0X
  [4X------------------------------------------------------------------[0X
  
  Then  the  relations  are converted into NP format (see [14X2.1[0m) after which the
  function [2XSGrobner[0m ([14X3.4-2[0m) is called to calculate a GrÃ¶bner basis.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> relsNP:=GP2NPList(rels);;[0X
    [4Xgap> GB:=SGrobner(relsNP);;[0X
    [4X#I  The computation took 396 msecs.[0X
  [4X------------------------------------------------------------------[0X
  
  It  is  now possible to calculate the dimension of the quotient algebra with
  the function [2XDimQA[0m ([14X3.5-2[0m). This function has as arguments the GrÃ¶bner basis
  [10XGB[0m  and the number of generators of the algebra (here this is [10Xnumpoints[0m). To
  get the full basis the function [2XBaseQA[0m ([14X3.5-1[0m) can be used.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> DimQA(GB,numpoints);[0X
    [4X10846[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.24 The universal enveloping algebra of a Lie algebra[0X
  
  Consider  the Lie algebra with generators e, f and h, and relations [e,f]=h,
  [e,h]=-2e,  [f,h]=2f.  This  is  the  well-known Lie algebra of type A_1. We
  construct the corresponding universal enveloping algebra of this Lie algebra
  and show how one can prove that f^2 belongs to the ideal generated by e^2 in
  that associative algebra. The example is from Knopper's report [Kno04].
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 0
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 0 (for more information about
  the info level, see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP");[0X
    [4X-----------------------------------------------------------------------------[0X
    [4XLoading  GBNP 1.0.1 (Non-commutative GrÃ¶bner bases)[0X
    [4Xby A.M. Cohen (http://www.win.tue.nl/~amc) and[0X
    [4X   J.W. Knopper (J.W.Knopper@tue.nl).[0X
    [4X-----------------------------------------------------------------------------[0X
    [4Xtrue[0X
    [4X[0X
    [4Xgap> SetInfoLevel(InfoGBNP,0);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,0);[0X
  [4X------------------------------------------------------------------[0X
  
  Then define the algebra and enter the relations as polynomials in GAP.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(Rationals, "e", "f", "h");[0X
    [4X<algebra-with-one over Rationals, with 3 generators>[0X
    [4Xgap> e:=A.e;; f:=A.f;; h:=A.h;; o:=One(A);;[0X
    [4Xgap> uerels:=[f*e-e*f+h,h*e-e*h-2*e,h*f-f*h+2*f];[0X
    [4X[ (1)*h+(-1)*e*f+(1)*f*e, (-2)*e+(-1)*e*h+(1)*h*e, (2)*f+(-1)*f*h+(1)*h*f ][0X
  [4X------------------------------------------------------------------[0X
  
  The  relations  can  be  converted  to NP format (see [14X2.1[0m) with the function
  [2XGP2NPList[0m  ([14X3.1-2[0m)  and  can  be  subsequently  displayed  with  [2XPrintNPList[0m
  ([14X3.2-3[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> uerelsNP:=GP2NPList(uerels);;[0X
    [4Xgap> PrintNPList(uerelsNP);[0X
    [4X ba - ab + c [0X
    [4X ca - ac - 2a [0X
    [4X cb - bc + 2b [0X
  [4X------------------------------------------------------------------[0X
  
  Now  configure  printing  in  such  a way that this algebra is used with the
  function [2XGBNP.ConfigPrint[0m ([14X3.2-2[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBNP.ConfigPrint(A);[0X
  [4X------------------------------------------------------------------[0X
  
  The  set  is actually a GrÃ¶bner basis, as can be verified by calculating the
  GrÃ¶bner basis with [2XSGrobner[0m ([14X3.4-2[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB:=SGrobner(uerelsNP);;[0X
    [4Xgap> PrintNPList(GB);[0X
    [4X fe - ef + h [0X
    [4X he - eh - 2e [0X
    [4X hf - fh + 2f [0X
  [4X------------------------------------------------------------------[0X
  
  Determine  whether  the  quotient  algebra is finite dimensional by means of
  [2XFinCheckQA[0m  ([14X3.6-2[0m),  with  arguments the leading monomials of [10XGB[0m and 3, the
  number  of  variables  involved.  The  leading  monomials of [10XGB[0m are found by
  invoking [2XLMonsNP[0m ([14X3.3-10[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> F:=LMonsNP(GB);[0X
    [4X[ [ 2, 1 ], [ 3, 1 ], [ 3, 2 ] ][0X
    [4Xgap> FinCheckQA(F,3);[0X
    [4Xfalse[0X
  [4X------------------------------------------------------------------[0X
  
  Adding the relation e^2=0 results in a finite quotient algebra.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> extendedrels:=[f*e-e*f+h,h*e-e*h-2*e,h*f-f*h+2*f,e^2];[0X
    [4X[ (1)*h+(-1)*e*f+(1)*f*e, (-2)*e+(-1)*e*h+(1)*h*e, (2)*f+(-1)*f*h+(1)*h*f, [0X
    [4X  (1)*e^2 ][0X
    [4Xgap> extendedrelsNP:=GP2NPList(extendedrels);;[0X
  [4X------------------------------------------------------------------[0X
  
  With  the  function  [2XSGrobnerTrace[0m  ([14X3.7-5[0m)  it  is  possible to calculate a
  GrÃ¶bner basis with trace information.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB:=SGrobnerTrace(extendedrelsNP);;[0X
  [4X------------------------------------------------------------------[0X
  
  The GrÃ¶bner basis can now be displayed with [2XPrintNPListTrace[0m ([14X3.7-4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPListTrace(GB);[0X
    [4X e^2 [0X
    [4X eh + e [0X
    [4X fe - ef + h [0X
    [4X f^2 [0X
    [4X fh - f [0X
    [4X he - e [0X
    [4X hf + f [0X
    [4X h^2 - 2ef + h [0X
  [4X------------------------------------------------------------------[0X
  
  Note  the  fourth  relation: f^2=0. To view a trace one can use the function
  [2XPrintTracePol[0m ([14X3.7-3[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintTracePol(GB[4]);[0X
    [4X- 1/12G(1)f^2 + 1/12f^2G(1) + 1/12f^2G(1)h - 1/6fG(1)hf + 1/12G(1)hf^2 + 1/[0X
    [4X24G(1)ef^3 + 1/24eG(1)f^3 - 1/8fG(1)ef^2 - 1/8feG(1)f^2 + 1/8f^2G(1)ef + 1/[0X
    [4X8f^2eG(1)f - 1/24f^3G(1)e - 1/24f^3eG(1) - 1/24G(2)f^3 + 1/8fG(2)f^2 - 1/[0X
    [4X8f^2G(2)f + 1/24f^3G(2) + 1/4G(3)f + 1/4fG(3) + 1/12fG(3)h + 1/12fhG(3) - 1/[0X
    [4X12G(3)hf - 1/12hG(3)f - 1/12eG(3)f^2 + 1/6feG(3)f - 1/12f^2eG(3) + 1/24G([0X
    [4X4)f^4 - 1/6fG(4)f^3 + 1/4f^2G(4)f^2 - 1/6f^3G(4)f + 1/24f^4G(4) [0X
  [4X------------------------------------------------------------------[0X
  
  This proves that f^2=0 is a consequence of e^2=0 in the universal enveloping
  algebra of the simple Lie algebra of type A_1.
  
  The  function  [2XStrongNormalFormTraceDiff[0m  ([14X3.7-6[0m)  can  be used to trace the
  difference  between  an  element  and its strong normal form in the terms of
  [10Xextendedrels[0m.  Apparently,  in the first example the strong normal form of [10Xr[0m
  is [10Xr - s.pol=0[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> r := [[[2,2,2,2,1,1,1,1]],[1]];;[0X
    [4Xgap> s := StrongNormalFormTraceDiff(r, GB);;[0X
    [4X[0X
    [4Xgap> PrintNP(s.pol);[0X
    [4X f^4e^4 [0X
    [4Xgap> PrintTracePol(s);[0X
    [4X f^4G(4)e^2 [0X
    [4Xgap> PrintNP(AddNP(r,s.pol,1,-1));[0X
    [4X 0[0X
  [4X------------------------------------------------------------------[0X
  
  One more example where the strong normal form is not zero.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> r := [[[3,3,3]],[1]];;[0X
    [4Xgap> s := StrongNormalFormTraceDiff(r, GB);;[0X
    [4X[0X
    [4Xgap> PrintNP(s.pol);[0X
    [4X h^3 - h [0X
    [4Xgap> PrintTracePol(s);[0X
    [4X- G(1) - 1/2G(1)ef - 1/6eG(1)f + 1/3efG(1) + 1/2fG(1)e + 1/2feG(1) + G([0X
    [4X1)h^2 + 1/2G(1)efh + 1/2eG(1)fh + 1/3efG(1)h - 1/3eG(1)hf - 1/2fG(1)eh - 1/[0X
    [4X2feG(1)h - 1/6eG(1)ef^2 - 1/6e^2G(1)f^2 + 1/3efG(1)ef + 1/3efeG(1)f - 1/[0X
    [4X6ef^2G(1)e - 1/6ef^2eG(1) + 1/2G(2)f - 1/2fG(2) - 1/2G(2)fh + 1/2fG(2)h + 1/[0X
    [4X6eG(2)f^2 - 1/3efG(2)f + 1/6ef^2G(2) - 2/3eG(3)h + 1/3ehG(3) + 1/3e^2G(3)f - [0X
    [4X1/3efeG(3) - 1/2G(4)f^2 + fG(4)f - 1/2f^2G(4) + 1/2G(4)f^2h - fG(4)fh + 1/[0X
    [4X2f^2G(4)h - 1/6eG(4)f^3 + 1/2efG(4)f^2 - 1/2ef^2G(4)f + 1/6ef^3G(4) [0X
    [4Xgap> PrintNP(AddNP(r,s.pol,1,-1));[0X
    [4X h [0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.25 Serre's exercise[0X
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[0X
  [4X------------------------------------------------------------------[0X
  
  In  Serre's book [Ser03] the following exercise can be found: Prove that the
  group  <  a,b,c|  bab^-1a^-2,  cbc^-1b^-2, aca^-1c^-2> is the trivial group.
  Here we solve the exercise by running the trace variant of the GrÃ¶bner basis
  function  with  input  the set of equations ba - a^2 b, cb - b^2c, ac - c^2a
  together  with  relations  forcing  that  a,b,c  are invertible with inverse
  A,B,C.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> KI := [ [[[2,1],[1,1,2]],[1,-1]],[0X
    [4X>         [[[3,2],[2,2,3]],[1,-1]],[0X
    [4X>         [[[1,3],[3,3,1]],[1,-1]],[0X
    [4X>         [[[1,4], []],[1,-1]],[0X
    [4X>         [[[4,1], []],[1,-1]],[0X
    [4X>         [[[2,5], []],[1,-1]],[0X
    [4X>         [[[5,2], []],[1,-1]],[0X
    [4X>         [[[3,6], []],[1,-1]],[0X
    [4X>         [[[6,3], []],[1,-1]],[0X
    [4X>       ];;[0X
    [4Xgap> PrintNPList(KI);[0X
    [4X ba - a^2b [0X
    [4X cb - b^2c [0X
    [4X ac - c^2a [0X
    [4X ad - 1 [0X
    [4X da - 1 [0X
    [4X be - 1 [0X
    [4X eb - 1 [0X
    [4X cf - 1 [0X
    [4X fc - 1 [0X
  [4X------------------------------------------------------------------[0X
  
  We  use  [2XSGrobnerTrace[0m  ([14X3.7-5[0m),  the  trace  variant  of  the GrÃ¶bner basis
  computation,
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB := SGrobnerTrace(KI);;[0X
    [4X#I  number of entered polynomials is 9[0X
    [4X#I  number of polynomials after reduction is 9[0X
    [4X#I  End of phase I[0X
    [4X#I  End of phase II[0X
    [4X#I  List of todo lengths is [ 9, 10, 11, 12, 14, 16, 18, 20, 21, 22, 24, 26, [0X
    [4X  28, 31, 34, 33, 35, 37, 40, 43, 46, 49, 52, 56, 59, 62, 61, 60, 64, 64, 65, [0X
    [4X  65, 68, 71, 76, 76, 80, 88, 93, 94, 99, 110, 115, 117, 131, 139, 146, 150, [0X
    [4X  158, 171, 186, 198, 206, 220, 229, 246, 260, 263, 102, 40, 19, 9, 3, 0 ][0X
    [4X#I  End of phase III[0X
    [4X#I  End of phase IV[0X
    [4X#I  The computation took 209905 msecs.[0X
  [4X------------------------------------------------------------------[0X
  
  The  dimension  of the quotient algebra is 1, showing that the group algebra
  is 1-dimensional. This implies that the group with the above presentation is
  trivial.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBpols := List([1..Length(GB)], x -> GB[x].pol);;[0X
    [4Xgap> PrintNPList(GBpols);[0X
    [4X a - 1 [0X
    [4X b - 1 [0X
    [4X c - 1 [0X
    [4X d - 1 [0X
    [4X e - 1 [0X
    [4X f - 1 [0X
    [4Xgap> DimQA(GBpols,6);[0X
    [4X1[0X
  [4X------------------------------------------------------------------[0X
  
  Since the output is large and might spoil the exercise, we confine ourselves
  to  the  printing first polynomial [10XGB[1][0m and the length of its trace. As the
  trace polynomial expresses [10XGB[1][0m, which is equal to a-1, as a combination of
  the  binomials  in  [10XKI[0m,  it gives a proof that a can be rewritten within the
  group  to  the  trivial element. It is easy to derive from this that b and c
  are also trivial in the group. This justifies the restriction to [10XGB[1][0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNP(GB[1].pol);[0X
    [4X a - 1 [0X
    [4Xgap> Length(GB[1].trace);[0X
    [4X1119[0X
  [4X------------------------------------------------------------------[0X
  
  
  [1XA.26 Baur and Draisma's transformations[0X
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,0);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,0);[0X
  [4X------------------------------------------------------------------[0X
  
  The  paper  [BD04]  by  Baur  and Draisma uses the computation of a quotient
  algebra  of  dimension 37, which we repeat here. The set of equations, after
  specialisation of the scalars to 1, is as follows.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> KI := [ [[[2,2]],[1]],[0X
    [4X>         [[[1,1]],[1]],[0X
    [4X>         [[[3,3]],[1]],[0X
    [4X>         [[[1,2,1],[1]],[1,-1]],[0X
    [4X>         [[[2,1,2],[2]],[1,-1]],[0X
    [4X>         [[[3,2,3],[3]],[1,-1]],[0X
    [4X>         [[[2,3,2],[2]],[1,-1]],[0X
    [4X>         [[[1,3,1],[1]],[1,-1]],[0X
    [4X>         [[[3,1,3],[3]],[1,-1]],[0X
    [4X>         [[[1,2,3,1,2,3,1],[1,3,2,1,3,2,1],[1]],[1,1,-1]],[0X
    [4X>         [[[3,1,2,3,1,2,3],[3,2,1,3,2,1,3],[3]],[1,1,-1]],[0X
    [4X>         [[[2,3,1,2,3,1,2],[2,1,3,2,1,3,2],[2]],[1,1,-1]],[0X
    [4X>       ];;[0X
    [4Xgap> PrintNPList(KI);[0X
    [4X b^2 [0X
    [4X a^2 [0X
    [4X c^2 [0X
    [4X aba - a [0X
    [4X bab - b [0X
    [4X cbc - c [0X
    [4X bcb - b [0X
    [4X aca - a [0X
    [4X cac - c [0X
    [4X abcabca + acbacba - a [0X
    [4X cabcabc + cbacbac - c [0X
    [4X bcabcab + bacbacb - b [0X
  [4X------------------------------------------------------------------[0X
  
  We  carry  out  a  traced  GrÃ¶bner basis computation by use of [2XSGrobnerTrace[0m
  ([14X3.7-5[0m), and form the usual GrÃ¶bner basis by extracting the polynomials from
  the traced polynomials using the field indicator [10X.pol[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBT := SGrobnerTrace(KI);;[0X
    [4Xgap> GB := List([1..Length(GBT)], i -> GBT[i].pol);;[0X
  [4X------------------------------------------------------------------[0X
  
  The dimension of the quotient algebra is computable with [2XDimQA[0m ([14X3.5-2[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> DimQA(GB,3);[0X
    [4X37[0X
  [4X------------------------------------------------------------------[0X
  
  In order to express the last GB element, viz.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNP(GB[Length(GB)]);[0X
    [4X cabcabca + cbacba - ca [0X
  [4X------------------------------------------------------------------[0X
  
  as a combination of elements of [10XKI[0m, we use [2XPrintTracePol[0m ([14X3.7-3[0m):
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintTracePol(GBT[Length(GBT)]);  [0X
    [4X- G(9)bacba + cG(10) [0X
  [4X------------------------------------------------------------------[0X
  
  We  compute  matrices for left multiplication by generators using [2XMatricesQA[0m
  ([14X3.5-4[0m)  and  determine  the  minimal  polynomial  of  the  sum of the three
  matrices.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> B := BaseQA(GB,3,0);;[0X
    [4Xgap> M := MatricesQA(3,B,GB);;[0X
    [4Xgap> f := MinimalPolynomial(Rationals,M[1]+M[2]+M[3]);[0X
    [4Xx_1^7-6*x_1^5+9*x_1^3-3*x_1[0X
    [4Xgap> Factors(f);[0X
    [4X[ x_1, x_1^6-6*x_1^4+9*x_1^2-3 ][0X
  [4X------------------------------------------------------------------[0X
  
  It  turns  out  that  there  are  three non-zero numbers u,v,w such that the
  eigenvalues of the sum are 0,u,v,w,-u,-v,-w. This is the information used in
  [BD04].
  
  
  [1XA.27 The cola gene puzzle[0X
  
  A  prize  question  appearing in the January 2005 issue of the Dutch journal
  "Natuur  en  Techniek"  asked  for  a  DNA change of cows so that they could
  produce  Cola  instead  of milk. A team of genetic manipulators has tools to
  perform  the  following five DNA string operations. (Here the strings before
  and after the equality sign can be interchanged at will.)
  
  operation 1: TCAT = T;
  
  operation 2: GAG = AG;
  
  operation 3: CTC = TC;
  
  operation 4: AGTA = A;
  
  operation 5: TAT = CT.
  
  The  first  question  is  to  show  how  they  can  transform  the milk gene
  TAGCTAGCTAGCT to the cola gene CTGACTGACT.
  
  A  second  question  is  to  show  that  mad cow disease related retro virus
  CTGCTACTGACT can be avoided at all times. Can this be guaranteed?
  
  We  answer  these  questions  using the trace functions of the GrÃ¶bner basis
  package GBNP in Section [14X3.7[0m.
  
  First  load the package and set the standard infolevel [2XInfoGBNP[0m ([14X4.2-1[0m) to 0
  and the time infolevel [2XInfoGBNPTime[0m ([14X4.3-1[0m) to 0 to minimize the printing of
  data  regarding  the computation (for more information about the info level,
  see Chapter [14X4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> LoadPackage("GBNP","0",false);;[0X
    [4Xgap> SetInfoLevel(InfoGBNP,0);[0X
    [4Xgap> SetInfoLevel(InfoGBNPTime,0);[0X
  [4X------------------------------------------------------------------[0X
  
  We  introduce  the  free  algebra [10XALG[0m on the generators corresponding to the
  four  letters  in  the  DNA  code and express the milk gene and cola gene as
  monomials in this algebra.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> ALG:=FreeAssociativeAlgebraWithOne(Rationals, "A", "C", "G", "T");;[0X
    [4Xgap> g:=GeneratorsOfAlgebra(ALG);;[0X
    [4Xgap> A:=g[2];;[0X
    [4Xgap> C:=g[3];;[0X
    [4Xgap> G:=g[4];;[0X
    [4Xgap> T:=g[5];;[0X
    [4X[0X
    [4Xgap> milk := T*A*G*C*T*A*G*C*T*A*G*C*T;;[0X
    [4Xgap> cola := C*T*G*A*C*T*G*A*C*T;;[0X
  [4X------------------------------------------------------------------[0X
  
  We  next  enter  the  set  K  of  binomials  x-y  corresponding  to the five
  operations  x = y listed above. We enter the binomials as members of [10XALG[0m and
  let [10XKNP[0m be the corresponding set of NP polynomials.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> rule1 := T*C*A*T - T;;[0X
    [4Xgap> rule2 :=  G*A*G -  A*G;;[0X
    [4Xgap> rule3 :=  C*T*C - T*C;;[0X
    [4Xgap> rule4 := A*G*T*A - A;;[0X
    [4Xgap> rule5 := T*A*T -  C*T;;[0X
    [4Xgap> K := [rule1,rule2,rule3,rule4,rule5];;[0X
    [4Xgap> KNP := List(K,x-> GP2NP(x));;[0X
  [4X------------------------------------------------------------------[0X
  
  We  stipulate  how  the  variables  will  be  printed  and  print  [10XKNP[0m.  See
  [2XPrintNPList[0m ([14X3.2-3[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GBNP.ConfigPrint("A","C","G","T");[0X
    [4Xgap> PrintNPList(KNP);[0X
    [4X TCAT - T [0X
    [4X GAG - AG [0X
    [4X CTC - TC [0X
    [4X AGTA - A [0X
    [4X TAT - CT [0X
  [4X------------------------------------------------------------------[0X
  
  Now calculate the usual GrÃ¶bner basis with [2XSGrobner[0m ([14X3.4-2[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GB := SGrobner(KNP);;[0X
  [4X------------------------------------------------------------------[0X
  
  Compare milk and cola after taking their strong normal forms with respect to
  [10XGB[0m  using  [2XStrongNormalFormNP[0m  ([14X3.5-6[0m).  We  oberve  that they have the same
  normal  form  and so there is a way to transform the milk gene into the cola
  gene.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> milkNP := GP2NP(milk);;[0X
    [4Xgap> colaNP := GP2NP(cola);;[0X
    [4Xgap> milkRed := NP2GP(StrongNormalFormNP(milkNP,GB),ALG);[0X
    [4X(1)*T[0X
    [4Xgap> colaRed := NP2GP(StrongNormalFormNP(colaNP,GB),ALG);[0X
    [4X(1)*T[0X
  [4X------------------------------------------------------------------[0X
  
  But this information does not yet show us how to perform the transformation.
  To this end we calculate the GrÃ¶bner basis with trace information, using the
  function [2XSGrobnerTrace[0m ([14X3.7-5[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> GTrace := SGrobnerTrace(KNP);;[0X
  [4X------------------------------------------------------------------[0X
  
  The full trace can be printed with [2XPrintTraceList[0m ([14X3.7-2[0m), but we only print
  the relations (and no trace) by invoking [2XPrintNPListTrace[0m ([14X3.7-4[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> PrintNPListTrace(GTrace);[0X
    [4X CT - T [0X
    [4X GA - A [0X
    [4X AGT - AT [0X
    [4X ATA - A [0X
    [4X TAT - T [0X
    [4X TCA - TA [0X
  [4X------------------------------------------------------------------[0X
  
  In  order  to  display  a  proof  that milk-cola belongs to the ideal we use
  [2XStrongNormalFormTraceDiff[0m ([14X3.7-6[0m), The result is a record, [10Xp[0m say, containing
  [10Xmilk-cola[0m  in  the  field [10Xp.pol[0m (the normal form will be subtracted from the
  argument  [10Xmilk-cola[0m to obtain [10Xp.pol[0m, but the normal form is zero because the
  argument belongs to the ideal generated by [10XK[0m). The other field of the record
  [10Xp[0m  is  [10Xp.trace[0m,  the  traced  polynomial,  which is best displayed by use of
  [2XPrintTracePol[0m ([14X3.7-3[0m).
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> p := StrongNormalFormTraceDiff(CleanNP(GP2NP(milk-cola)),GTrace);;[0X
    [4Xgap> NP2GP(p.pol,ALG);[0X
    [4X(1)*T*A*G*C*T*A*G*C*T*A*G*C*T+(-1)*C*T*G*A*C*T*G*A*C*T[0X
    [4Xgap> PrintTracePol(p);[0X
    [4X- TGATGAG(1) + TAGG(1)ATAT - TATATAGG(1) - TGAG(1)GACT + TGATGACG(1) - G([0X
    [4X1)GACTGACT - TAGCG(1)ATAT - TATAGG(1)AGT + TATATAGCG(1) + TGACG(1)GACT + CG([0X
    [4X1)GACTGACT - TAGG(1)AGTAGT + TAGTAGTAGG(1) + TATAGCG(1)AGT + TAGCG([0X
    [4X1)AGTAGT + TAGTAGG(1)AGCT - TAGTAGTAGCG(1) + TAGG(1)AGCTAGCT - TAGTAGCG([0X
    [4X1)AGCT - TAGCG(1)AGCTAGCT - TATG(2)TAT - TG(2)TATGAT - TGATGAG(3)AT + TAGG([0X
    [4X3)ATATAT - TATATAGG(3)AT - TGAG(3)ATGACT - G(3)ATGACTGACT - TATAGG([0X
    [4X3)ATAGT - TAGG(3)ATAGTAGT + TAGTAGTAGG(3)AT + TAGTAGG(3)ATAGCT + TAGG([0X
    [4X3)ATAGCTAGCT - TATG(4)T + TG(4)TAT + TATGG(4)T - TG(4)TGAT + TATATG(4)T + TGG([0X
    [4X4)TGAT - TG(4)TATAT + TATG(4)TAGT + TG(4)TAGTAGT + TAGG(5)ATAT - TATATAGG([0X
    [4X5) - TATAGG(5)AGT - TAGG(5)AGTAGT [0X
  [4X------------------------------------------------------------------[0X
  
  In  order  to  give a precise answer to the first question we need to work a
  little  on  [10Xp.trace[0m.  To  do  so, we introduce the following function, which
  creates  the  NP polynomial corresponding to the [10Xi[0m-th term in the expression
  [10Xp.trace[0m  of  [10Xp.pol[0m  as a linear combination of members of [10XKNP[0m. It is used to
  obtain the list [10XEvalList[0m of polynomials for all [10Xi[0m.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> EvalTracePol := function(i,p,KNP)[0X
    [4X>   local x,pi;[0X
    [4X>   pi := p.trace[i];[0X
    [4X>   x := BimulNP(pi[1],KNP[pi[2]],pi[3]);[0X
    [4X>   return  [x[1],pi[4]*x[2]];[0X
    [4X> end;;[0X
    [4X[0X
    [4Xgap> lev :=  Length(p.trace);;[0X
    [4Xgap> EvalList := List([1..lev], y -> CleanNP(EvalTracePol(y,p,KNP)));;[0X
  [4X------------------------------------------------------------------[0X
  
  In order to find the rewrite from the milk gene to the cola gene as required
  for an answer to the first question, we match leading terms recursively.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> UnusedIndices := Set([1..lev]);;[0X
    [4Xgap> RunningTerm :=  milkNP[1][1];;[0X
    [4Xgap> stepno := 0;;[0X
    [4Xgap> NP2GP(milkNP,ALG);[0X
    [4X(1)*T*A*G*C*T*A*G*C*T*A*G*C*T[0X
    [4Xgap> while Length(UnusedIndices) > 0 do[0X
    [4X>   i := 0;[0X
    [4X>   notfnd := true;[0X
    [4X>   while i < lev and notfnd do [0X
    [4X>     i := i+1;[0X
    [4X>     if EvalList[i][1][1] = RunningTerm and i in UnusedIndices then [0X
    [4X>        notfnd := false;[0X
    [4X>        RemoveSet(UnusedIndices, i);[0X
    [4X>        RunningTerm :=  EvalList[i][1][2];[0X
    [4X>        stepno := stepno+1;[0X
    [4X>     elif EvalList[i][1][2] = RunningTerm and i in UnusedIndices then [0X
    [4X>        notfnd := false;[0X
    [4X>        RemoveSet(UnusedIndices, i);[0X
    [4X>        RunningTerm :=  EvalList[i][1][1];[0X
    [4X>        stepno := stepno+1;[0X
    [4X>     fi; [0X
    [4X>   od;[0X
    [4X>   if i = lev and notfnd = true then Print("error not fnd in"); fi;[0X
    [4X>   Print(" -(",stepno,")- ");[0X
    [4X>   PrintNP([[p.trace[i][1]],[1]]);[0X
    [4X>   Print("         K[",p.trace[i][2],"]\n        ");[0X
    [4X>   PrintNP([[p.trace[i][3]],[1]]);[0X
    [4X>   Print(" --> ");[0X
    [4X>   PrintNP([[EvalList[i][1][2]],[1]]);[0X
    [4X> od;;[0X
    [4X -(1)-  TAGC [0X
    [4X         K[1][0X
    [4X         AGCTAGCT [0X
    [4X -->  TAGCTAGCTAGCT [0X
    [4X -(2)-  TAG [0X
    [4X         K[3][0X
    [4X         ATAGCTAGCT [0X
    [4X -->  TAGTCATAGCTAGCT [0X
    [4X -(3)-  TAG [0X
    [4X         K[1][0X
    [4X         AGCTAGCT [0X
    [4X -->  TAGTAGCTAGCT [0X
    [4X -(4)-  TAGTAGC [0X
    [4X         K[1][0X
    [4X         AGCT [0X
    [4X -->  TAGTAGCTAGCT [0X
    [4X -(5)-  TAGTAG [0X
    [4X         K[3][0X
    [4X         ATAGCT [0X
    [4X -->  TAGTAGTCATAGCT [0X
    [4X -(6)-  TAGTAG [0X
    [4X         K[1][0X
    [4X         AGCT [0X
    [4X -->  TAGTAGTAGCT [0X
    [4X -(7)-  TAGTAGTAGC [0X
    [4X         K[1][0X
    [4X         1 [0X
    [4X -->  TAGTAGTAGCT [0X
    [4X -(8)-  TAGTAGTAG [0X
    [4X         K[3][0X
    [4X         AT [0X
    [4X -->  TAGTAGTAGTCAT [0X
    [4X -(9)-  TAGTAGTAG [0X
    [4X         K[1][0X
    [4X         1 [0X
    [4X -->  TAGTAGTAGT [0X
    [4X -(10)-  TAG [0X
    [4X         K[1][0X
    [4X         AGTAGT [0X
    [4X -->  TAGTAGTAGT [0X
    [4X -(11)-  TAG [0X
    [4X         K[3][0X
    [4X         ATAGTAGT [0X
    [4X -->  TAGTCATAGTAGT [0X
    [4X -(12)-  TAGC [0X
    [4X         K[1][0X
    [4X         AGTAGT [0X
    [4X -->  TAGCTAGTAGT [0X
    [4X -(13)-  TAG [0X
    [4X         K[5][0X
    [4X         AGTAGT [0X
    [4X -->  TAGCTAGTAGT [0X
    [4X -(14)-  T [0X
    [4X         K[4][0X
    [4X         TAGTAGT [0X
    [4X -->  TATAGTAGT [0X
    [4X -(15)-  TATAG [0X
    [4X         K[1][0X
    [4X         AGT [0X
    [4X -->  TATAGTAGT [0X
    [4X -(16)-  TATAG [0X
    [4X         K[3][0X
    [4X         ATAGT [0X
    [4X -->  TATAGTCATAGT [0X
    [4X -(17)-  TATAGC [0X
    [4X         K[1][0X
    [4X         AGT [0X
    [4X -->  TATAGCTAGT [0X
    [4X -(18)-  TATAG [0X
    [4X         K[5][0X
    [4X         AGT [0X
    [4X -->  TATAGCTAGT [0X
    [4X -(19)-  TAT [0X
    [4X         K[4][0X
    [4X         TAGT [0X
    [4X -->  TATATAGT [0X
    [4X -(20)-  TATATAG [0X
    [4X         K[1][0X
    [4X         1 [0X
    [4X -->  TATATAGT [0X
    [4X -(21)-  TATATAG [0X
    [4X         K[3][0X
    [4X         AT [0X
    [4X -->  TATATAGTCAT [0X
    [4X -(22)-  TATATAGC [0X
    [4X         K[1][0X
    [4X         1 [0X
    [4X -->  TATATAGCT [0X
    [4X -(23)-  TATATAG [0X
    [4X         K[5][0X
    [4X         1 [0X
    [4X -->  TATATAGCT [0X
    [4X -(24)-  TATAT [0X
    [4X         K[4][0X
    [4X         T [0X
    [4X -->  TATATAT [0X
    [4X -(25)-  T [0X
    [4X         K[4][0X
    [4X         TATAT [0X
    [4X -->  TATATAT [0X
    [4X -(26)-  TAG [0X
    [4X         K[5][0X
    [4X         ATAT [0X
    [4X -->  TAGCTATAT [0X
    [4X -(27)-  TAGC [0X
    [4X         K[1][0X
    [4X         ATAT [0X
    [4X -->  TAGCTATAT [0X
    [4X -(28)-  TAG [0X
    [4X         K[3][0X
    [4X         ATATAT [0X
    [4X -->  TAGTCATATAT [0X
    [4X -(29)-  TAG [0X
    [4X         K[1][0X
    [4X         ATAT [0X
    [4X -->  TAGTATAT [0X
    [4X -(30)-  T [0X
    [4X         K[4][0X
    [4X         TAT [0X
    [4X -->  TATAT [0X
    [4X -(31)-  TAT [0X
    [4X         K[4][0X
    [4X         T [0X
    [4X -->  TATAT [0X
    [4X -(32)-  TAT [0X
    [4X         K[2][0X
    [4X         TAT [0X
    [4X -->  TATAGTAT [0X
    [4X -(33)-  TATG [0X
    [4X         K[4][0X
    [4X         T [0X
    [4X -->  TATGAT [0X
    [4X -(34)-  T [0X
    [4X         K[4][0X
    [4X         TGAT [0X
    [4X -->  TATGAT [0X
    [4X -(35)-  T [0X
    [4X         K[2][0X
    [4X         TATGAT [0X
    [4X -->  TAGTATGAT [0X
    [4X -(36)-  TG [0X
    [4X         K[4][0X
    [4X         TGAT [0X
    [4X -->  TGATGAT [0X
    [4X -(37)-  TGATGA [0X
    [4X         K[1][0X
    [4X         1 [0X
    [4X -->  TGATGAT [0X
    [4X -(38)-  TGATGA [0X
    [4X         K[3][0X
    [4X         AT [0X
    [4X -->  TGATGATCAT [0X
    [4X -(39)-  TGATGAC [0X
    [4X         K[1][0X
    [4X         1 [0X
    [4X -->  TGATGACT [0X
    [4X -(40)-  TGA [0X
    [4X         K[1][0X
    [4X         GACT [0X
    [4X -->  TGATGACT [0X
    [4X -(41)-  TGA [0X
    [4X         K[3][0X
    [4X         ATGACT [0X
    [4X -->  TGATCATGACT [0X
    [4X -(42)-  TGAC [0X
    [4X         K[1][0X
    [4X         GACT [0X
    [4X -->  TGACTGACT [0X
    [4X -(43)-  1 [0X
    [4X         K[1][0X
    [4X         GACTGACT [0X
    [4X -->  TGACTGACT [0X
    [4X -(44)-  1 [0X
    [4X         K[3][0X
    [4X         ATGACTGACT [0X
    [4X -->  TCATGACTGACT [0X
    [4X -(45)-  C [0X
    [4X         K[1][0X
    [4X         GACTGACT [0X
    [4X -->  CTGACTGACT [0X
    [4Xgap> NP2GP(colaNP,ALG);[0X
    [4X(1)*C*T*G*A*C*T*G*A*C*T[0X
  [4X------------------------------------------------------------------[0X
  
  And now the second question regarding the retro virus.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> retro := C*T*G*C*T*A*C*T*G*A*C*T;;[0X
  [4X------------------------------------------------------------------[0X
  
  We  compute  the Strong Normal Form [2XStrongNormalFormNP[0m ([14X3.5-6[0m) of [10Xretro[0m with
  respect  to [10XGB[0m. As it is [10XTGT[0m, distinct to [10XT[0m, the strong normal form of milk,
  there is no transformation from milk to retro.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> NP2GP(StrongNormalFormNP(CleanNP(GP2NP(retro)),GB), ALG);[0X
    [4X(1)*T*G*T[0X
  [4X------------------------------------------------------------------[0X
  
  Of   course,   here   too   we   can  verify  the  reduction,  by  computing
  [2XStrongNormalFormTraceDiff[0m ([14X3.7-6[0m) with input the NP polynomial corresponding
  to  [10Xretro[0m  and  with  respect to [10XK[0m; it is called [10XretroTrace[0m. The symbol [10XG[0m in
  expression  like  [10XG(2)[0m  are  not  to  be  confused with the single symbols [10XG[0m
  representing the DNA element.
  
  [4X------------------------------------------------------------------[0X
    [4Xgap> retroTrace := StrongNormalFormTraceDiff(CleanNP(GP2NP(retro)),GTrace);;[0X
    [4Xgap> PrintTracePol(retroTrace);[0X
    [4X TGG(1) - TGC^2G(1) - TGTAG(1) + TGTACG(1) + TGTAGG(1)AT + TGTATGAG([0X
    [4X1) + TGTAG(1)GACT - TGTAGCG(1)AT - TGTATGACG(1) + TGG(1)ACTGACT - TGTACG([0X
    [4X1)GACT + G(1)GCTACTGACT - TGCG(1)ACTGACT - CG(1)GCTACTGACT + TGTATG([0X
    [4X2)TAT + TGG(3)AT + TGCG(3)AT - TGTAG(3)AT + TGTAGG(3)ATAT + TGTATGAG([0X
    [4X3)AT + TGTAG(3)ATGACT + TGG(3)ATACTGACT + G(3)ATGCTACTGACT + TGTG([0X
    [4X4)T + TGTATG(4)T - TGTG(4)TAT - TGTATGG(4)T + TGCG(5) + TGG(5)AT - TGTAG([0X
    [4X5) + TGTAGG(5)AT [0X
  [4X------------------------------------------------------------------[0X
  
