% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}
\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}
\definecolor{FuncColor}{rgb}{1.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,1.0}

\usepackage{fancyvrb}

\usepackage{pslatex}

\usepackage[pdftex=true,
        a4paper=true,bookmarks=false,pdftitle={Written with GAPDoc},
        pdfcreator={LaTeX with hyperref package / GAPDoc},
        colorlinks=true,backref=page,breaklinks=true,linkcolor=RoyalBlue,
        citecolor=RoyalGreen,filecolor=RoyalRed,
        urlcolor=RoyalRed,pagecolor=RoyalBlue]{hyperref}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages


\newcommand{\GAP}{\textsf{GAP}}

\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\begin{center}{\Huge \textbf{Documentation on the \textsf{GBNP} package\mbox{}}}\\[1cm]
\hypersetup{pdftitle=Documentation on the \textsf{GBNP} package}
\markright{\scriptsize \mbox{}\hfill Documentation on the \textsf{GBNP} package \hfill\mbox{}}
{Version 1.0.1\mbox{}}\\[1cm]
{12 May 2010\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\large \textbf{Arjeh M. Cohen \mbox{}}}\\
{\large \textbf{Jan Willem Knopper \mbox{}}}\\
\hypersetup{pdfauthor=Arjeh M. Cohen ; Jan Willem Knopper }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{Arjeh M. Cohen } --- Email: \href{mailto://A.M.Cohen@tue.nl} {\texttt{A.M.Cohen@tue.nl}}}\\
{\mbox{}\\
\small \noindent \textbf{Jan Willem Knopper } --- Email: \href{mailto://J.W.Knopper@tue.nl} {\texttt{J.W.Knopper@tue.nl}}}\\

\noindent \textbf{Address: }\begin{minipage}[t]{8cm}\noindent
TU/e,\\
 POB 513, 5600 MB Eindhoven, the Netherlands \end{minipage}
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Abstract}
\logpage{[ 0, 0, 1 ]}
 We provide algorithms, written in the \textsf{GAP} 4 programming language, for computing Gr{\"o}bner bases of non-commutative
polynomials, and some variations, such as a weighted and truncated version and
a tracing facility. In addition, there are algorithms for analyzing the
quotient of a non-commutative polynomial algebra by a 2-sided ideal generated
by a set of polynomials whose Gr{\"o}bner basis has been determined and for
computing quotient modules of free modules over quotient algebras. 

 The notion of algorithm is interpreted loosely: in general one cannot expect a
non-commutative Gr{\"o}bner basis algorithm to terminate, as it would imply
solvability of the word problem for finitely presented (semi)groups. 

 This documentation gives a short description of the mathematical content,
explains the functions of the package, and provides more than twenty worked
out examples. \mbox{}}\\[1cm]
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 2 ]}
 
\begin{itemize}
\item The package is based on an earlier version by Rosane Ushirobira.
\item The bulk of the package is written by Arjeh M. Cohen and Di{\a'e} A.H.
Gijsbers.
\item The theory is mainly taken from literature by Teo Mora \cite{TCS::Mora1994:131} and Edward L. Green \cite{Green1997}.
\item From Version 0.8.3 on the package has three additional files (\texttt{fincheck.g}, \texttt{tree.g} \texttt{graphs.g}) with routines for finding the Hilbert function and testing finite
dimensionality when given a Gr{\"o}bner basis by Chris Krook \cite{Krook2003}, based on work by Victor Ufnarovski \cite{MR91d:16053}.
\item From Version 0.9 on the package is enriched with support for fields
implemented in GAP and additional prefix rules for quotient modules, as well
as some speed improvements by Jan Willem Knopper. Knopper has also formatted
the documentation in GAPDoc \cite{GAPDoc}. 
\item From Version 1.0 on the package is extended with NMO (for Noncommutative
Monomial Orderings) by Randall Cone. This enables the GBNP user to choose a
wider selection of monomial orderings than the standard one built into GBNP
itself. Documentation on NMO can be found in the NMO manual \cite{NMODoc}. 
\end{itemize}
 {\nobreakspace}  \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 3 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Introduction}}\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
 This package, named GBNP for Gr{\"o}bner Bases for Non-commutative
Polynomials, is intended for computing in (associative) non-commutative
algebras with a finite presentation. Starting from a free algebra $A$ on a finite number of generating variables, the reader can specify a finite
set $G$ of polynomials in these variables, in order to study the quotient algebra of $A$ by the (2-sided) ideal of $A$ generated by $G$. 

 This documentation gives a short description of the mathematical content in
Chapter \ref{Description}, explains the functions of the package in Chapter \ref{Functions}, and provides more than twenty four worked out examples in Appendix \ref{Examples}. It is available as an HTML document at \href{http://mathdox.org/products/gbnp/} {\texttt{http://mathdox.org/products/gbnp/}} and as an pdf document at \href{http://mathdox.org/products/gbnp/manual.pdf} {\texttt{http://mathdox.org/products/gbnp/manual.pdf}}. 
\section{\textcolor{Chapter }{Installation}}\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X8360C04082558A12}{}
{
 To install GBNP, first download it from \href{http://mathdox.org/products/gbnp/GBNP-1.0.1.tar.gz} {\texttt{http://mathdox.org/products/gbnp/GBNP-1.0.1.tar.gz}}, then unpack \texttt{GBNP-1.0.1.tar.gz} in the \texttt{pkg} subdirectory of your \textsf{GAP} installation (or in the \texttt{pkg} subdirectory of any other \textsf{GAP} root directory, for example one added with the \texttt{-l} argument) with the following command: \texttt{tar -xvzf GBNP-1.0.1.tar.gz}. 

 GBNP is then loaded with the GAP command 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage( "GBNP" ); 
\end{Verbatim}
 

 Those who want to download this documentation can find it at \href{http://mathdox.org/products/gbnp/GBNPdoc-1.0.1.tar.gz} {\texttt{http://mathdox.org/products/gbnp/GBNPdoc-1.0.1.tar.gz}} and extract it with \texttt{tar -xvzf GBNPdoc-1.0.1.tar.gz}. It is also included in the package. }

 
\section{\textcolor{Chapter }{Using the package}}\label{intro}
\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X78629CD778BE8C5D}{}
{
 If you wish to compute a Gr{\"o}bner basis, create a list of NPs
(non-commutative polynomials in NP format), as described in Section \ref{NP}. This can be done either directly or by use of the transition functions
described in Section \ref{TransitionFunctions}. To run the standard algorithm use the functions from Section \ref{grobner}. With these functions, you can try and find a Gr{\"o}bner basis. The word try
is included because the algorithm for computing Gr{\"o}bner bases is not
guaranteed to terminate. Printing issues for polynomials in NP format are
discussed in Section \ref{printing}. If the Gr{\"o}bner basis is found and the dimension of the quotient algebra $Q$ (see Section \ref{QuotientAlgs}) is finite, you can find a basis of monomials for $Q$ with the functions in Section \ref{QA}. For a more advanced analysis of $Q$, such as a proof of finite or infinite dimensionality, or for determining its
growth or its partial Hilbert series, use the functions from Section \ref{finiteness} . 

 There are three variants of the Gr{\"o}bner basis algorithm, the truncated
version, the trace version, and the module version. In the (weighted)
homogeneous case (described in Section \ref{trunc}), the truncated version, given by the functions described in Section \ref{truncfun},  computes the part of a Gr{\"o}bner basis up to an indicated weight. The trace
version (described in Section \ref{trace}), given by the functions described in Section \ref{tracefun},  computes an expression of the polynomials of the Gr{\"o}bner basis found in
terms of the original generators. The module version (described in Sections \ref{NPM}, \ref{PrefixRels}, and \ref{GBR}), given by the functions described in Section \ref{NPMs},  computes a Gr{\"o}bner basis for a submodule of a free $Q$-module of finite rank. 

 Read the example files in Chapter \ref{Examples} for inspiration. The source of the files can be perused for auxiliary
functions, which are often used in the main functions but not deemed necessary
for a first time user. }

 
\section{\textcolor{Chapter }{Further documentation}}\logpage{[ 1, 3, 0 ]}
\hyperdef{L}{X7DDEF24284C861D8}{}
{
 The reports \cite{CohenGijsbersEtAl2007}, \cite{Krook2003}, and \cite{Knopper2004} can be downloaded from the web at these addresses: 

 The report ``Non-commutative polynomial computations'', by Arjeh M. Cohen (with support of Di{\a'e} Gijsbers, Jan Willem Knopper,
and Chris Krook) can be downloaded from \href{http://mathdox.org/products/gbnp/gbnp.pdf} {\texttt{http://mathdox.org/products/gbnp/gbnp.pdf}}. 

 The report ``Dimensionality of quotient algebras'', by Chris Krook can be downloaded from \href{http://mathdox.org/products/gbnp/dqa.pdf} {\texttt{http://mathdox.org/products/gbnp/dqa.pdf}}. 

 The report ``GBNP and vector enumeration'', by Jan Willem Knopper can be downloaded from \href{http://mathdox.org/products/gbnp/knopper.pdf} {\texttt{http://mathdox.org/products/gbnp/knopper.pdf}}. }

 }

 
\chapter{\textcolor{Chapter }{Description}}\label{Description}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7BBCB13F82ACC213}{}
{
 
\section{\textcolor{Chapter }{Non-commutative Polynomials (NPs)}}\label{NP}
\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X7FDF3E5E7F33D3A2}{}
{
 The main datatype of the GBNP package is a list of non-commutative polynomials
(NPs). The data type for a \emph{non-commutative polynomial}, referred to as its NP format, is a list of two lists: 
\begin{itemize}
\item The first list is a list \texttt{m} of monomials.
\item The second list is a list \texttt{c} of coefficients of these monomials.
\end{itemize}
 The two lists have the same length. The polynomial represented by the ordered
pair \texttt{[m,c]} is $\sum_i c_i m_i$. 

 A monomial is a list of positive integers. They are interpreted as the indices
of the variables. So, if \texttt{k = [1,2,3,2,1]} and the variables are $x$,$y$,$z$ (in this order), then \texttt{k} represents the monomial $xyzyx$. By the way, the name of the variables has no meaning. There are various ways
to print these but the default is $a$,$b$,$c$,$\ldots$ (see below). 

 The zero polynomial is represented by \texttt{[[],[]]}. The polynomial 1 is represented by \texttt{[[[]],[1]]}. 

 The algorithms work for the algebra $\mathbb F\langle\langle x_1,x_2,\ldots,x_t\rangle\rangle$ of non-commutative polynomials in \mbox{\texttt{\slshape t}} variables over the field $\mathbb F$. Accordingly, the list \texttt{c} should contain elements of $\mathbb F$. It is not always easy to recover $\mathbb F$ from the list \texttt{c}. The GAP functions \texttt{One} and \texttt{Zero} can be of some help.  

 In order to facilitate viewing the polynomials, we provide the function \texttt{PrintNP} (\ref{PrintNP}). For instance 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  PrintNP([[[1,2],[2,1]],[3,-1]]);
\end{Verbatim}
 yields 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  3ab - ba
\end{Verbatim}
 Indeed, we have the names: \texttt{a}, \texttt{b}, \texttt{c}, $\ldots$ for $x_1$, $x_2$, $x_3$, $\ldots$, except that everything beyond $l$ (the 12-th letter) is called $x$. This can be easily changed by calling the function \texttt{GBNP.ConfigPrint}, which can be found in Section \ref{printing}. 

 The function \texttt{PrintNPList} (\ref{PrintNPList}) is available for printing a list of NPs (=non-commutative polynomials). 

 In order to facilitate testing whether two data structures represent the same
NP, we use the convention that polynomials are ``clean''. This means that they look as if they are output of the function \texttt{CleanNP} (\ref{CleanNP}). In other words: 
\begin{itemize}
\item each monomial occurs at most once in the list of monomials,
\item no monomials occur whose coefficients are zero,
\item the monomials are ordered (total degree first, then lexicographically) from
big to small.
\end{itemize}
 An advantage of the ordering is that the leading monomial of an NP \texttt{p} is just \texttt{p[1][1]} and that its leading coefficient is \texttt{p[2][1]}. Users who want to work with other orderings can use the functions defined in
the NMO extension \cite{NMODoc} to GBNP. }

 
\section{\textcolor{Chapter }{Non-commutative Polynomials for Modules (NPMs)}}\label{NPM}
\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X7B27E2D1784538DE}{}
{
 In Section \ref{NP} the NP format for elements of a free algebra $A$ of non-commutative polynomials in a fixed number of variables is described.
This format can be adjusted slightly to allow the use of a free right module $A^n$ of finite rank $n$ over $A$. The internal format of an element of the module is similar to that of a
non-commutative polynomial. The only change is that each monomial will start
with a negative number. The absolute value of this number is the index of the
standard basis vector of the free module. 

 For example in the free $\mathbb F\langle\langle x_1, x_2,\ldots, x_t\rangle\rangle$-module of rank 3, the expression \texttt{[[[-1]],[1]]} represents $[1,0,0]$ and \texttt{[[[-1,1,2],[-1,2,1],[-3,2,2,2]],[6,-7,9]]} represents $[6x_1x_2-7x_2x_1,0,9x_2^3]$. The zero vector is the represented in the same way as its NP format
counterpart in \ref{NP} and the only one without a negative entry: \texttt{[[],[]]}. We refer to this format as the NPM format. 

 Elements of modules are printed as vectors. See Section \ref{NPMs} on how to use modules. Examples \ref{Example20}, \ref{Example21}, and \ref{Example04} are also recommended. }

 
\section{\textcolor{Chapter }{Core functions}}\logpage{[ 2, 3, 0 ]}
\hyperdef{L}{X84BD98F5811EAC45}{}
{
 The core function is \texttt{SGrobner} (\ref{SGrobner}) (which is short for Strong Gr{\"o}bner, as we use the Strong Normal Form,
discussed in Section \texttt{StrongNormalFormNPM} (\ref{StrongNormalFormNPM}), most of the time). It takes a list of NPs in a free algebra $A$ and prepares two lists for treatment in a loop: 
\begin{itemize}
\item  First the list itself, called \texttt{G}. Before entering the loop, \texttt{G} is cleaned, ordered, and its elements are made monic, that is, multiplied by a
scalar so that the leading coefficient becomes one. The ordering is done by
comparison of leading monomials. The ordering on leading monomials is length
lexicographic. For other orderings, the functions of the NMO extension can be
used; see \cite{NMODoc}. 
\item Second the list of all normal forms with respect to \texttt{G} of S-polynomials of elements of \texttt{G}. This list is called \texttt{D}. For a Gr{\"o}bner basis, the S-polynomials of polynomials in \texttt{D} (possibly with an element of \texttt{G}) need to be computed. If \texttt{D} is empty then \texttt{G} is a Gr{\"o}bner basis.
\end{itemize}
 Then, the function calls the routine \texttt{GBNP.SGrobnerLoop} on the arguments \texttt{G}, \texttt{D} which are changed in an attempt to modify \texttt{G} while still preserving the following two properties. 
\begin{enumerate}
\item \texttt{G} generates the same two-sided ideal $I$ in $A$ as before.
\item \texttt{D} contains all normal forms with respect to \texttt{G} of S-polynomials of elements from \texttt{G} that need to reduce to zero for the basis to be a Gr{\"o}bner basis.
\end{enumerate}
 The importance of this feature is that, in case of huge computations, the user
may store \texttt{G} and \texttt{D} at almost any time and resume the computation by reloading \texttt{G} and \texttt{D} and calling the loop function \texttt{GBNP.SGrobnerLoop} whenever convenient. The only technical detail to handle is that the last
element of the list \texttt{G} should be copied into the \texttt{D} list. The loop itself performs a step towards making \texttt{G} more like a Gr{\"o}bner basis of $I$. As in the commutative case, the progress can be indicated by use of an
ordering on the set of leading monomials of the elements of \texttt{G}. 

 In contrast to the commutative case, however, this ordering is not well
founded, and there is no a priori guarantee that the loop will be exited after
a finite number of iterations. The loop ends when the list \texttt{D} is empty, in which case the work is essentially done: after some internal
cleaning and a bit of further rewriting, the computation is over. 

 There is also a \texttt{Grobner} (\ref{Grobner}) function. It uses (at some places) the Normal Form instead of the Strong
Normal Form algorithm. In most of our applications, this usually led to slower
performance, so we are not very keen to use it. 

 In many of our own applications, the full polynomial ring modulo the two-sided
ideal $I$ generated by \texttt{G} is a finite-dimensional quotient algebra. In such cases, one would like to
know the dimension (whence the function \texttt{DimQA} (\ref{DimQA}), QA for Quotient Algebra), find a basis (whence the function \texttt{BaseQA} (\ref{BaseQA})), or just the monomials up to a certain degree that are not divisible by a
leading term of \texttt{G} (whence the function \texttt{GBNP.NondivMons}). Actually by use of \texttt{MulQA} (\ref{MulQA}), you can even multiply elements of the quotient algebra. In case it is
unknown whether the quotient algebra is finite or infinite, one can use the
functions \texttt{FinCheckQA} (\ref{FinCheckQA}) and \texttt{DetermineGrowthQA} (\ref{DetermineGrowthQA}). When the quotient algebra is infinite dimensional you may want to determine
its partial Hilbert Series. This can be done with the function \texttt{HilbertSeriesQA} (\ref{HilbertSeriesQA}). }

 
\section{\textcolor{Chapter }{About the implementation}}\logpage{[ 2, 4, 0 ]}
\hyperdef{L}{X7EEE260680A64013}{}
{
 Rather than storing all obstructions, the Gr{\"o}bner basis algorithm computes
the (Strong) Normal Form of obstructions from \texttt{G} and puts them into \texttt{D} whenever nonzero. At the beginning of the loop, we take the first element of
the \texttt{D} list and prepare it for addition to \texttt{G}. We are then concerned with two goals: 
\begin{enumerate}
\item to restore the invariant properties,
\item to clean up G (that is, reduce it to a more succinct, shorter set).
\end{enumerate}
 This is mainly done by means of additional S-polynomial and Normal Form
computations. 

 As for data management, we have chosen to work with lists in situ, that is,
not to copy the list but rather perform all operations on one and the same
list. To this end we use operations like \texttt{RemoveElmList} and \texttt{Add}, see  \textbf{Reference: Add}. The idea here is to economize on space for large computations. We do not use
in situ operations everywhere, but have concentrated on the potentially
biggest lists: \texttt{G} and \texttt{D}. 

 For checking whether a monomial can be reduced, an internal tree structure is
used. }

 
\section{\textcolor{Chapter }{Tracing variant}}\label{trace}
\logpage{[ 2, 5, 0 ]}
\hyperdef{L}{X8739B6547BC89505}{}
{
 When computing with small examples, it may be handy to provide the elements of
the Gr{\"o}bner basis with a way of expressing them as elements in \texttt{I}, that is, as combinations of elements of the input. This can be done, not
only for elements of \texttt{G}, but for any element, by the functions in the file \texttt{trace.g}. This file calls the file \texttt{nparith.g} for arithmetic keeping track of the expressions of polynomials as combinations
of elements from the original basis. With respect to a given input basis \texttt{B}, a polynomial \texttt{p} in the traced version is a record, called the traced polynomial, with two
fields. One field, denoted \texttt{p.pol}, is the usual polynomial in NP format. The other, denoted \texttt{p.trace}, is a list of elements indexed by \texttt{B}. Each element of \texttt{p.trace} is a list whose elements are four-tuples \texttt{[ml,i,mr,c]} where \texttt{ml} and \texttt{mr} are monomials, \texttt{i} is an index of an element of \texttt{B} and \texttt{c} is a scalar. The interpretation of this data structure is that \texttt{p.pol} can be written as the sum over all four-tuples \texttt{[ml,i,mr,c]} of $c*ml*B_i*mr$. Functions for printing these expressions in a human understandable way are
described in Section \ref{tracefun}. }

 
\section{\textcolor{Chapter }{Truncation variant}}\label{trunc}
\logpage{[ 2, 6, 0 ]}
\hyperdef{L}{X78CF5C44879D34B6}{}
{
 For computations with large and/or infinite examples, it may be convenient to
truncate everything above a certain degree. In fact, we encountered various
examples where the polynomials are (weighted) homogeneous and then it makes
perfect sense to truncate the polynomials, that is, to disregard everything
above a certain degree. For then the Grobner basis, if it exists, will be also
be homogeneous and the part consisting of all of its polynomials of degree
less than a given degree $d$ is equal to the Grobner basis of the join of the original list of polynomials
with all monomials of degree $d+1$. Here an NP polynomial in $n$ variables is called homogeneous of degree $d$ with respect to $v$, a vector with non-negative integers of length $n$, if, for each of its monomials $[t_1,...,t_k]$, the sum over all $v_{t_i}$ is equal to $d$. The most classical choice for $v$ is the all-one vector in which case one often speaks of homogeneous without
mentioning the all-one vector. If two polynomials are homogeneous with respect
to $v$, then so are their S-polynomials. If $K$ is a list of homogeneous polynomials with respect to $v$, then the normal form with respect to $K$ of any homogeneous polynomial of degree $d$ with respect to $v$ is again homogeneous of degree $d$ with respect to $v$. In particular, the Gr{\"o}bner basis of a list of polynomials that are
homogeneous with respect to $v$, consists of homogeneous polynomials, and those input polynomials
contributing to polynomials in the Gr{\"o}bner basis of degree at most $d$ have degree at most $d$ themselves. These facts enable the computation of the truncated Gr{\"o}bner
basis. The functions of this variant can be found in Section \ref{truncfun}. }

 
\section{\textcolor{Chapter }{Module variant}}\label{PrefixRels}
\logpage{[ 2, 7, 0 ]}
\hyperdef{L}{X86F1F4EE7D4D06B7}{}
{
  Suppose we are given a finite set $G$ of polynomials in a free non-commutative algebra $A$ generated by, say $t$ indeterminates, and a positive integer $s$. Denote by $I$ the two-sided ideal of $A$ generated by $G$. We can work with the free right $A/I$ module $(A/I)^s$. See Section \ref{NPM} on how to represent vectors of $(A/I)^s$ by elements of the free module $A^s$. Given a subset $W$ of $A^s$, whose elements are called prefix relations, let $W'$ be the submodule generated by the image of $W$ in $(A/I)^s$. The function \texttt{SGrobnerModule} (\ref{SGrobnerModule}) is meant to determine the quotient module $(A/I)^s/W'$. If the algorithm terminates, it delivers a Gr{\"o}bner basis for $I$ as well as a suitable set of generators for $W'$, with Gr{\"o}bner like properties. This implies that \texttt{StrongNormalFormNPM} (\ref{StrongNormalFormNPM}), a strong normal form computation, can be used to find the canonical
representative in $A^s$ of an element in $(A/I)^s/W'$. Theoretic details can be found in \cite{CohenGijsbersEtAl2007}. If $(A/I)^s/W'$ is a finite-dimensional vector space over the coefficient field of $A$, then a basis can be found by use of \texttt{BaseQM} (\ref{BaseQM}) and its dimension can be computed by use of \texttt{DimQM} (\ref{DimQM}). }

 
\section{\textcolor{Chapter }{Gr{\"o}bner basis records}}\label{GBR}
\logpage{[ 2, 8, 0 ]}
\hyperdef{L}{X80DAE0A97CFC95DD}{}
{
 The function \texttt{SGrobnerModule} (\ref{SGrobnerModule}) calculates a Gr{\"o}bner basis consisting of some two-sided relations in the
algebra and some prefix or module relations in the vector space. These are
returned in a record \texttt{GBR}. The two-sided relations can be found under the name \texttt{GBR.ts} and the prefix relations under the name \texttt{GBR.p}. Some other information is stored in this record as well. 

 The prefix conditions are in NPM format (see \ref{NPM}) and the two-sided relations are in NP format. }

 
\section{\textcolor{Chapter }{Quotient algebras}}\label{QuotientAlgs}
\logpage{[ 2, 9, 0 ]}
\hyperdef{L}{X85A91A467FF1DE45}{}
{
 Once a Gr{\"o}bner basis of a list $G$ of polynomials in NP format, defining elements of a free algebra $A$, is computed, the quotient algebra $QA$ of $A$ by the two-sided ideal generated by $G$ (or, which amounts to the same, the Gr{\"o}bner basis) can be analyzed. A
number of functions are available to determine whether $QA$ is finite dimensional or not. 

 Elements of $QA$ are represented by elements of $A$. Two elements are equal if and only if their strong normal forms coincide;
see \texttt{StrongNormalFormNP} (\ref{StrongNormalFormNP}). The multiplication is take care of by \texttt{MulQA} (\ref{MulQA}), which is little more than the strong normal form of the product of two
polynomials in NP format representing elements of $QA$. 

 If $QA$ is finite dimensional, a basis of it over the field can be found by \texttt{BaseQA} (\ref{BaseQA}). The size of the base, in other words, the dimension of $QA$, can be computed with \texttt{DimQA} (\ref{DimQA}). Right multiplication by an element of $QA$ is a linear transformation. The matrix of this linear transformation with
respect to the base, in case the element belongs to the base, can be computed
by \texttt{MatrixQA} (\ref{MatrixQA}) or, for all basis elements, \texttt{MatricesQA} (\ref{MatricesQA}). 

 A list of leading terms of the Gr{\"o}bner basis $G$ can be constructed with \texttt{LMonsNP} (\ref{LMonsNP}). The dimension of $QA$ only depends on this list and is computationally easier to work with than $G$. Most functions designed to analyze dimensionality work with a monomial ideal
generated by a strong Gr{\"o}bner basis, which in this case means that no
element divides any other element. 

 The function \texttt{FinCheckQA} (\ref{FinCheckQA}) determines whether $QA$ is finite or infinite dimensional. More generally, the growth of $QA$ can be determined by means of the function \texttt{DetermineGrowthQA} (\ref{DetermineGrowthQA}), which either returns the information that $QA$ is finite dimensional, or that $QA$ has polynomial growth, in which case it gives bounds for the degree of
polynomial growth, or that $QA$ has exponential growth. Finally, with the function \texttt{HilbertSeriesQA} (\ref{HilbertSeriesQA}) one can compute coefficients of the Hilbert series. 

 The purpose of the functions \texttt{FinCheckQA} (\ref{FinCheckQA}) and \texttt{DetermineGrowthQA} (\ref{DetermineGrowthQA}) are closely related. The former is faster, while the latter provides more
information, as illustrated from the following table. 

 \begin{center}
\begin{tabular}{|l|l|l|}\hline
{\nobreakspace}&
\texttt{FinCheckQA}&
\texttt{DetermineGrowthQA}\\
\hline
finite&
\texttt{true}&
\texttt{0}\\
polynomial growth&
\texttt{false}&
\texttt{d} or \texttt{[d1,d2]}\\
exponential growth&
\texttt{false}&
\texttt{"exponential growth"}\\
\hline
\end{tabular}\\[2mm]
\textbf{Table: }dimensionality functions; \texttt{d} stands for degree, \texttt{[d1,d2]} for an interval containing the degree\end{center}

 The function \texttt{DetermineGrowthQA} (\ref{DetermineGrowthQA}) may find the exact degree of polynomial growth (if at hand). If this is the
case, that degree is returned. It may also happen that only an interval \texttt{[d1,d2]} is returned in which the dimension lies. To force an exact answer, its third
argument should be \texttt{true}. 

 With the function \texttt{PreprocessAnalysisQA} (\ref{PreprocessAnalysisQA}), the computations done by these 3 functions can be sped up. Note however that
by applying preprocessing of the data, the set of monomials in the ideal basis
is changed and corresponds no longer to the same quotient algebra (but to a
quotient algebra with the same growth). }

 }

 
\chapter{\textcolor{Chapter }{Functions}}\label{Functions}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X86FA580F8055B274}{}
{
  
\section{\textcolor{Chapter }{Converting polynomials into different formats}}\label{TransitionFunctions}
\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X81ABB91B79E00229}{}
{
 

\subsection{\textcolor{Chapter }{GP2NP}}
\logpage{[ 3, 1, 1 ]}\nobreak
\hyperdef{L}{X7B0EBCBC7857F1AE}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GP2NP({\slshape gp})\index{GP2NP@\texttt{GP2NP}}
\label{GP2NP}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
If \mbox{\texttt{\slshape gp}} is an element of a free algebra, then the polynomial in NP format (see Section \ref{NP}) corresponding to \mbox{\texttt{\slshape gp}}; if \mbox{\texttt{\slshape gp}} is an element of a free module, then the vector in NPM format (see Section \ref{NPM}) corresponding to \mbox{\texttt{\slshape gp}}. 



 This function will convert an element of a free algebra to a polynomial in NP
format and an element of a free right module to a vector in NPM format. 

 \emph{Example:} Let \texttt{A} be the free associative algebra with one over the rationals on the generators \texttt{a} and \texttt{b}. Let \texttt{e} be the one of the algebra. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> A:=FreeAssociativeAlgebraWithOne(Rationals,"a","b");;
  gap> a:=A.a;;
  gap> b:=A.b;;
  gap> e:=One(A);;
  gap> z:=Zero(A);;
\end{Verbatim}
 Now let \texttt{gp} be the polynomial $ba-ab-e$. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> gp:=b*a-a*b-e;
  (-1)*<identity ...>+(-1)*a*b+(1)*b*a
\end{Verbatim}
 The polynomial in NP format, corresponding to \texttt{gp} can now be obtained with GP2NP: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GP2NP(gp);
  [ [ [ 2, 1 ], [ 1, 2 ], [  ] ], [ 1, -1, -1 ] ]
\end{Verbatim}
 Let \texttt{D} be the free associative algebra over \texttt{A} of rank 2. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> D := A^2;;
\end{Verbatim}
 Take the following list \texttt{R} of two elements of \texttt{D}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> R := [ [b-e, z], [e+a*(e+a+b), -e-a*(e+a+b)] ];;
\end{Verbatim}
 Convert the list \texttt{R} to a list of vectors in NPM format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> List(R,GP2NP);
  [ [ [ [ -1, 2 ], [ -1 ] ], [ 1, -1 ] ], 
    [ [ [ -1, 1, 2 ], [ -1, 1, 1 ], [ -2, 1, 2 ], [ -2, 1, 1 ], [ -1, 1 ], 
            [ -2, 1 ], [ -1 ], [ -2 ] ], [ 1, 1, -1, -1, 1, -1, 1, -1 ] ] ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{GP2NPList}}
\logpage{[ 3, 1, 2 ]}\nobreak
\hyperdef{L}{X7CF0ED937DDA5A7E}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GP2NPList({\slshape Lgp})\index{GP2NPList@\texttt{GP2NPList}}
\label{GP2NPList}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
The list of polynomials in NP or NPM format corresponding to elements of a
free algebra or module occurring in the list \mbox{\texttt{\slshape Lgp}}. 



 This function has the same effect as \texttt{List(Lgp,GBNP)}. 

 \emph{Example:} Let \texttt{A} be the free associative algebra with one over the rationals on the generators \texttt{a} and \texttt{b}. Let \texttt{e} be the one of the algebra. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> A:=FreeAssociativeAlgebraWithOne(Rationals,"a","b");;
  gap> a:=A.a;;
  gap> b:=A.b;;
  gap> e:=One(A);;
\end{Verbatim}
 Let \texttt{Lgp} be the list of polynomials $[a^2-e,b^2-e,ba-ab-e]$. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> Lgp:=[a^2-e,b^2-e,b*a-a*b-e];
  [ (-1)*<identity ...>+(1)*a^2, (-1)*<identity ...>+(1)*b^2, 
    (-1)*<identity ...>+(-1)*a*b+(1)*b*a ]
\end{Verbatim}
 The polynomial in NP format corresponding to \texttt{gp} can be obtained with GP2NP: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GP2NPList(Lgp);
  [ [ [ [ 1, 1 ], [  ] ], [ 1, -1 ] ], [ [ [ 2, 2 ], [  ] ], [ 1, -1 ] ], 
    [ [ [ 2, 1 ], [ 1, 2 ], [  ] ], [ 1, -1, -1 ] ] ]
\end{Verbatim}
 The same result is obtained by a simple application of the standard List
function in GAP: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> List(Lgp,GP2NP) = GP2NPList(Lgp);
  true
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{NP2GP}}
\logpage{[ 3, 1, 3 ]}\nobreak
\hyperdef{L}{X86C3912F781ABEDC}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NP2GP({\slshape np, A})\index{NP2GP@\texttt{NP2GP}}
\label{NP2GP}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
The GAP format of the polynomial \mbox{\texttt{\slshape np}} in NP format.



 This function will convert a polynomial in NP format to a GAP polynomial in
the free associative algebra \mbox{\texttt{\slshape A}} and a vector in NPM format to a GAP vector in the free module \mbox{\texttt{\slshape A}}. In case of the NP format, the number of variables should not exceed the rank
of the free algebra \mbox{\texttt{\slshape A}}. In case of the NPM format, the absolute of the negative numbers should not
exceed the rank of the free module \mbox{\texttt{\slshape A}}. 

 \emph{Example:} Let \texttt{A} be the free associative algebra with one over the rationals on the generators \texttt{a} and \texttt{b}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> A:=FreeAssociativeAlgebraWithOne(GF(3),"a","b");;
\end{Verbatim}
 Let \texttt{np} be a polynomial in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> np:=[ [ [ 2, 1 ], [ 1, 2 ], [  ] ], [ Z(3)^0, Z(3), Z(3) ] ];;
\end{Verbatim}
 The polynomial can be converted to the corresponding element of \mbox{\texttt{\slshape A}} with NP2GP: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> NP2GP(np,A);
  (Z(3)^0)*b*a+(Z(3))*a*b+(Z(3))*<identity ...>
\end{Verbatim}
 Note that some information of the coefficient field of a polynomial \texttt{np} in NP format can be obtained from the second list of \texttt{np}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> One(np[2][1]);
  Z(3)^0
\end{Verbatim}
 Now let \texttt{M} be the module \texttt{A\texttt{\symbol{94}}2} and let \texttt{npm} be a polynomial over that module in NPM form. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> M:=A^2;;
  gap> npm:=[ [ [ -1, 1 ], [ -2, 2 ] ], [ Z(3)^0, Z(3)^0 ] ];;
\end{Verbatim}
 The element of \mbox{\texttt{\slshape M}} corresponding to \texttt{npm} is 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> NP2GP(npm,M);
  [ (Z(3)^0)*a, (Z(3)^0)*b ]
\end{Verbatim}
 If \texttt{M} is a module of dimension 2 over \texttt{A} and \texttt{Lnp} a list of polynomials in NPM format, then the polynomials can be converted to
the corresponding polynomials of \texttt{M} as follows: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> M:=A^2;;
  gap> Lnp:=[ [ [ [ -2, 1, 1 ], [ -2, 1 ] ], [ 1, -1 ] ],
  >   [ [ [ -1, 2, 2], [-2, 1 ] ], [ 1, -1 ]*Z(3)^0 ] ];;
  gap> List(Lnp, m -> NP2GP(m,M));
  [ [ <zero> of ..., (Z(3))*a+(Z(3)^0)*a^2 ], [ (Z(3)^0)*b^2, (Z(3))*a ] ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{NP2GPList}}
\logpage{[ 3, 1, 4 ]}\nobreak
\hyperdef{L}{X844A23EA7D97150C}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NP2GPList({\slshape Lnp, A})\index{NP2GPList@\texttt{NP2GPList}}
\label{NP2GPList}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
The list of polynomials corresponding to \mbox{\texttt{\slshape Lnp}} in GAP format. 



 This function will convert the list \mbox{\texttt{\slshape Lnp}} of polynomials in NP format to a list of GAP polynomials in the free
associative algebra \mbox{\texttt{\slshape A}}. 

 \emph{Example:} Let \texttt{A} be the free associative algebra with one over the rationals on the generators \texttt{a} and \texttt{b}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> A:=FreeAssociativeAlgebraWithOne(Rationals,"a","b");;
\end{Verbatim}
 Let \texttt{Lnp} be a list of polynomials in NP format. Then \texttt{Lnp} can be converted to a list of polynomials of \texttt{A} with NP2GPList: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> Lnp:=[ [ [ [ 1, 1, 1 ], [ 1 ] ], [ 1, -1 ] ],
  >   [ [ [ 2, 2 ], [ ] ], [ 1, -1 ] ] ];;
  gap> NP2GPList(Lnp,A);
  [ (1)*a^3+(-1)*a, (1)*b^2+(-1)*<identity ...> ]
\end{Verbatim}
 It has the same effect as the function \texttt{List} applied as follows. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> List(Lnp, p -> NP2GP(p,A));
  [ (1)*a^3+(-1)*a, (1)*b^2+(-1)*<identity ...> ]
\end{Verbatim}
 Now let \texttt{M} be a module of dimension 2 over \texttt{A} and \texttt{Lnp} a list of vectors in NPM format. Then polynomials \texttt{Lnp} can be converted to the corresponding vectors of \texttt{M} with NP2GPList: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> M:=A^2;;
  gap> Lnp:=[ [ [ [ -2, 1, 1 ], [ -2, 1 ] ], [ 1, -1 ] ],
  >   [ [ [ -1, 1 ], [ -2 ] ], [ 1, -1 ] ] ];;
  gap> NP2GPList(Lnp,M);
  [ [ <zero> of ..., (-1)*a+(1)*a^2 ], [ (1)*a, (-1)*<identity ...> ] ]
\end{Verbatim}
 The same result can be obtained by application of the standard List function: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> List(Lnp, m -> NP2GP(m,M)) = NP2GPList(Lnp,M) ;
  true
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Printing polynomials in NP format}}\label{printing}
\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X78F44B01851B1020}{}
{
 

\subsection{\textcolor{Chapter }{PrintNP}}
\logpage{[ 3, 2, 1 ]}\nobreak
\hyperdef{L}{X7B63BEA87A8D6162}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PrintNP({\slshape np})\index{PrintNP@\texttt{PrintNP}}
\label{PrintNP}
}\hfill{\scriptsize (function)}}\\


 This function prints a polynomial \mbox{\texttt{\slshape np}} in NP format, using the letters \texttt{a}, \texttt{b}, \texttt{c}, $\ldots$ for $x_1$, $x_2$, $x_3$, $\ldots$, except that everything beyond $l$ (the 12-th letter) is printed as $x$. 

 This function prints a polynomial \mbox{\texttt{\slshape np}} in NP format as configured by the function \texttt{GBNP.ConfigPrint} (\ref{GBNP.ConfigPrint}). 

 \emph{Example:} Consider the following polynomial in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p := [[[1,1,2],[1,2,2],[]],[1,-2,3]];;
\end{Verbatim}
 It can be printed in the guise of a polynomial in \texttt{a} and \texttt{b} by the function \texttt{PrintNP}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNP(p);
   a^2b - 2ab^2 + 3 
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{GBNP.ConfigPrint}}
\logpage{[ 3, 2, 2 ]}\nobreak
\hyperdef{L}{X7F7510A878045D3A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GBNP.ConfigPrint({\slshape arg})\index{GBNP.ConfigPrint@\texttt{GBNP.ConfigPrint}}
\label{GBNP.ConfigPrint}
}\hfill{\scriptsize (function)}}\\


 By default the generators of the algebra are printed as \texttt{a}, ..., \texttt{l} and everything after the twelfth generator as \texttt{x}. By calling \texttt{ConfigPrint} it is possible to alter this printing convention. The argument(s) will be an
algebra or arguments used for naming algebras in GAP upon creation. More
specifically, we have the following choices. 
\begin{description}
\item[{\emph{no arguments}}] When the function is invoked without arguments the printing is reset to the
default (see above).
\item[{algebra}] When the function is invoked with an algebra as argument, generators will be
printed as they would be in the algebra.
\item[{algebra,integer}] When the function is invoked with an algebra and an integer \mbox{\texttt{\slshape n}} as arguments, generators will be printed as they would be in the algebra and
seperated over the \mbox{\texttt{\slshape n}} dimensions.
\item[{leftmodule}] When the function is invoked with an leftmodule $A^n$ of an associative algebra as argument, generators will be printed as they
would be in the algebra, seperated over the \mbox{\texttt{\slshape n}} dimensions.
\item[{string}] When the function is invoked with a string as its argument, it is assumed that
there is only 1 generator and that this should be named as indicated by the
string.
\item[{integer}] When the function is invoked with an integer as its argument, the \mbox{\texttt{\slshape n}}-th generator will be printed as \texttt{x.{\textless}n{\textgreater}}.
\item[{integer, string}] When the function is invoked with a non-negative integer and a string as its
arguments, generators will be printed as \texttt{{\textless}s{\textgreater}.{\textless}n{\textgreater}}, where \texttt{{\textless}s{\textgreater}} is the string given as argument and \texttt{{\textless}n{\textgreater}} the number of the generator. There is no checking whether the number given as
argument is really the dimension. So it is possible that higher numbers return
in the output. This way of input is useful however, because it is a
distinction from the one-dimensional case and compatible with the way a free
algebra is created.
\item[{string, string, ..., string}] When the function is invoked with a sequence of strings, then generators will
be printed with the corresponding string or \texttt{x} if the sequence is not long enough.
\end{description}
 

 \emph{Example:} Consider the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[1,2,2],[]],[1,-1]];;
\end{Verbatim}
 They can be printed by the function \texttt{PrintNP}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNP(p1);
   a^2b - 1 
  gap> PrintNP(p2);
   ab^2 - 1 
\end{Verbatim}
 We can let the variables be printed as \texttt{x} and \texttt{y} instead of \texttt{a} and \texttt{b} by means of \texttt{GBNP.ConfigPrint}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBNP.ConfigPrint("x","y");
  gap> PrintNP(p1);
   x^2y - 1 
  gap> PrintNP(p2);
   xy^2 - 1 
\end{Verbatim}
 We can also let the variables be printed as \texttt{x.1} and \texttt{x.2} instead of \texttt{a} and \texttt{b} by means of \texttt{GBNP.ConfigPrint}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBNP.ConfigPrint(2,"x");
  gap> PrintNP(p1);
   x.1^2x.2 - 1 
  gap> PrintNP(p2);
   x.1x.2^2 - 1 
\end{Verbatim}
 We can even assign strings to the variables to be printed like \texttt{alice} and \texttt{bob} instead of \texttt{a} and \texttt{b} by means of \texttt{GBNP.ConfigPrint}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBNP.ConfigPrint("alice","bob");
  gap> PrintNP(p1);
   alice^2bob - 1 
  gap> PrintNP(p2);
   alicebob^2 - 1 
\end{Verbatim}
 Alternatively, we can introduce the free algebra \mbox{\texttt{\slshape A}} with two generators, and print the polynomials as members of \mbox{\texttt{\slshape A}}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> A:=FreeAssociativeAlgebraWithOne(Rationals,"a","b");;
  gap> GBNP.ConfigPrint(A);
  gap> PrintNP(p1);
   a^2b - 1 
  gap> PrintNP(p2);
   ab^2 - 1 
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{PrintNPList}}
\logpage{[ 3, 2, 3 ]}\nobreak
\hyperdef{L}{X832103DC79A9E9D0}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PrintNPList({\slshape Lnp})\index{PrintNPList@\texttt{PrintNPList}}
\label{PrintNPList}
}\hfill{\scriptsize (function)}}\\


 This function prints a list \mbox{\texttt{\slshape Lnp}} of polynomials in NP format, using the function \texttt{PrintNP}. 

 \emph{Example:} We put two polynomials in NP format into the list \texttt{Lnp}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[1,2,2],[]],[1,-1]];;
  gap> Lnp := [p1,p2];;
\end{Verbatim}
 We can print the list with \texttt{PrintNPList}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(Lnp);
   a^2b - 1 
   ab^2 - 1 
\end{Verbatim}
 Alternatively, using the function \texttt{GBNP.ConfigPrint} (\ref{GBNP.ConfigPrint}), we can introduce the free algebra \mbox{\texttt{\slshape A}} with two generators, and print the polynomials of the list as members of \mbox{\texttt{\slshape A}}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> A:=FreeAssociativeAlgebraWithOne(Rationals,"a","b");;
  gap> GBNP.ConfigPrint(A);
  gap> PrintNPList(Lnp);
   a^2b - 1 
   ab^2 - 1 
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Calculating with polynomials in NP format}}\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X83DE3F817EA74727}{}
{
 

\subsection{\textcolor{Chapter }{NumAlgGensNP}}
\logpage{[ 3, 3, 1 ]}\nobreak
\hyperdef{L}{X7DB3792385AAA805}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NumAlgGensNP({\slshape np})\index{NumAlgGensNP@\texttt{NumAlgGensNP}}
\label{NumAlgGensNP}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 The minimum number \texttt{t} so that \mbox{\texttt{\slshape np}} belongs to the free algebra on \texttt{t} generators. 



 When called with an NP polynomial \mbox{\texttt{\slshape np}}, this function returns the minimum number of generators needed for the
corresponding algebra to contain the \mbox{\texttt{\slshape np}}. If \mbox{\texttt{\slshape np}} is a polynomial without generators, that is, equivalent to $0$ or $1$, then \texttt{0} is returned. 

 \emph{Example:} Consider the following polynomial in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> np := [[[2,2,2,1,1,1],[4],[3,2,3]],[1,-3,2]];;
  gap> PrintNP(np);
   b^3a^3 - 3d + 2cbc 
  gap> NumAlgGensNP(np);
  4
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{NumAlgGensNPList}}
\logpage{[ 3, 3, 2 ]}\nobreak
\hyperdef{L}{X865548F07C74AB0A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NumAlgGensNPList({\slshape Lnp})\index{NumAlgGensNPList@\texttt{NumAlgGensNPList}}
\label{NumAlgGensNPList}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 The minimum number \texttt{t} so that each polynomial in \mbox{\texttt{\slshape Lnp}} belongs to the free algebra on \texttt{t} generators. 



 When called with a list of NP polynomials \mbox{\texttt{\slshape Lnp}}, this function returns the minimum number of generators needed for the
corresponding algebra to contain the NP polynomials in \mbox{\texttt{\slshape Lnp}}. If \mbox{\texttt{\slshape Lnp}} only contains polynomials without generators, that is equivalent to $0$ and $1$, then \texttt{0} is returned. 

 \emph{Example:} Consider the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2,3,1],[2],[1]],[1,-2,1]];;
  gap> p2 := [[[2,2,1,4,3],[]],[1,-1]];;
  gap> PrintNPList([p1,p2]);
   a^2bca - 2b + a 
   b^2adc - 1 
  gap> NumAlgGensNPList([p1,p2]);
  4
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{NumModGensNP}}
\logpage{[ 3, 3, 3 ]}\nobreak
\hyperdef{L}{X782647C57D148379}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NumModGensNP({\slshape npm})\index{NumModGensNP@\texttt{NumModGensNP}}
\label{NumModGensNP}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 The minimum number \texttt{mt} so that \mbox{\texttt{\slshape npm}} belongs to the free module on \texttt{mt} generators. 



 When called with a polynomial \mbox{\texttt{\slshape npm}} in NPM format, this function returns the minimum number of module generators
needed for the corresponding algebra to contain \mbox{\texttt{\slshape npm}}. If \mbox{\texttt{\slshape npm}} is an NP polynomial that does not contain module generators, then \texttt{0} is returned. 

 \emph{Example:} Consider the following polynomial in NPM format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> np := [[[-1,1,2,3,1],[-2],[-1]],[1,-2,1]];;
  gap> PrintNP(np);
  [ abca + 1 , - 2 ]
  gap> NumModGensNP(np);
  2
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{NumModGensNPList}}
\logpage{[ 3, 3, 4 ]}\nobreak
\hyperdef{L}{X8119282084CA8076}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{NumModGensNPList({\slshape Lnpm})\index{NumModGensNPList@\texttt{NumModGensNPList}}
\label{NumModGensNPList}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 The minimum number \texttt{mt} so that each member of \mbox{\texttt{\slshape npm}} belongs to the free module on \texttt{mt} generators. 



 When called with a list of polynomials \mbox{\texttt{\slshape Lnpm}} in NPM format, this function returns the minimum number of module generators
needed to contain the polynomials in \mbox{\texttt{\slshape Lnpm}}. If there are only polynomials in \mbox{\texttt{\slshape Lnpm}} in NP format, then \texttt{0} is returned. 

 \emph{Example:} Consider the following two polynomials in NPM format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> v1 := [[[-1,1,2,3,1],[-2],[-1]],[1,-2,1]];;
  gap> v2 := [[[-2,2,1,4,3],[-3]],[1,-1]];;
  gap> PrintNPList([v1,v2]);
  [ abca + 1 , - 2 ]
  [ 0, badc , - 1 ]
  gap> NumModGensNPList([v1,v2]);
  3
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{AddNP}}
\logpage{[ 3, 3, 5 ]}\nobreak
\hyperdef{L}{X788E1ACA82A833A8}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{AddNP({\slshape u, v, c, d})\index{AddNP@\texttt{AddNP}}
\label{AddNP}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 \mbox{\texttt{\slshape c}}$*$\mbox{\texttt{\slshape u}}$+$\mbox{\texttt{\slshape d}}$*$\mbox{\texttt{\slshape v}} 



 Computes \mbox{\texttt{\slshape c}}$*$\mbox{\texttt{\slshape u}}$+$\mbox{\texttt{\slshape d}}$*$\mbox{\texttt{\slshape v}} where \mbox{\texttt{\slshape u}} and \mbox{\texttt{\slshape v}} are polynomials in NP format and \mbox{\texttt{\slshape c}} and \mbox{\texttt{\slshape d}} are scalars. 

 \emph{Example:} Consider the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-3]];;
  gap> p2 := [[[1,2,2],[]],[1,-4]];;
\end{Verbatim}
 The second can be subtracted from the first by the function \texttt{AddNP}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNP(AddNP(p1,p2,1,-1));
   - ab^2 + a^2b + 1 
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{BimulNP}}
\logpage{[ 3, 3, 6 ]}\nobreak
\hyperdef{L}{X84FC611A822D808F}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{BimulNP({\slshape ga, np, dr})\index{BimulNP@\texttt{BimulNP}}
\label{BimulNP}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 the polynomial \mbox{\texttt{\slshape ga}}$*$\mbox{\texttt{\slshape np}}$*$\mbox{\texttt{\slshape dr}} in NP format 



 When called with a polynomial \mbox{\texttt{\slshape np}} and two monomials \mbox{\texttt{\slshape ga}}, \mbox{\texttt{\slshape dr}}, the function will return \mbox{\texttt{\slshape ga}}$*$\mbox{\texttt{\slshape np}}$*$\mbox{\texttt{\slshape dr}}. Recall from Section \ref{NP} that monomials are represented as lists. 

 \emph{Example:} Consider the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-3]];;
  gap> p2 := [[[1,2,2],[]],[1,-4]];;
\end{Verbatim}
 Multiplying \texttt{p1} from the right by \texttt{b} and multiplying \texttt{p2} from the left by \texttt{a} is possible with the function \texttt{BimulNP}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNP(BimulNP([],p1,[2]));
   a^2b^2 - 3b 
  gap> PrintNP(BimulNP([1],p2,[]));
   a^2b^2 - 4a 
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{CleanNP}}
\logpage{[ 3, 3, 7 ]}\nobreak
\hyperdef{L}{X855F3D4C783000E3}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CleanNP({\slshape u})\index{CleanNP@\texttt{CleanNP}}
\label{CleanNP}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 The cleaned up version of \mbox{\texttt{\slshape u}} 



 Given a polynomial in NP format, this function collects terms with same
monomial, removes trivial monomials, and orders the monomials, with biggest
one first. 

 \emph{Example:} Consider the following polynomial in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p := [[[1,1,2],[],[1,1,2],[]],[1,-3,-2,3]];;
  gap> PrintNP(p);
   a^2b - 3 - 2a^2b + 3 
\end{Verbatim}
 The monomials \texttt{[1,1,2]} and \texttt{[]} occur twice each. For many functions this representation of a polynomial in NP
format is not allowed. It needs to be cleaned, as by \texttt{CleanNP}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNP(CleanNP(p));
   - a^2b 
\end{Verbatim}
 In order to define a polynomial over $GF(2)$, the coefficients need to be defined over this field. Such a list of
coefficients can be obtained in GAP from a list of integers by multiplying
with the identity element of the field. The resulting polynomial need not be
clean, and so should be made clean again with \texttt{CleanNP}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p := [[[1,1,2],[]],One(GF(2))*[1,-2]];;
  gap> CleanNP(p);
  [ [ [ 1, 1, 2 ] ], [ Z(2)^0 ] ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{GtNP}}
\logpage{[ 3, 3, 8 ]}\nobreak
\hyperdef{L}{X7D05B60E83FDA567}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{GtNP({\slshape u, v})\index{GtNP@\texttt{GtNP}}
\label{GtNP}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 \texttt{true} if $u > v$ and \texttt{false} if $u \leq v$ 



 Greater than function for monomials \mbox{\texttt{\slshape u}} and \mbox{\texttt{\slshape v}} represented as in Section \ref{NP}. It tests whether \mbox{\texttt{\slshape u}}$>$\mbox{\texttt{\slshape v}}. The ordering is done by degree and then lexicographically. 

 \emph{Example:} Consider the following two monomials. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> u := [1,1,2];
  [ 1, 1, 2 ]
  gap> v := [2,2,1];
  [ 2, 2, 1 ]
\end{Verbatim}
 We test whether \texttt{u} is greater than \texttt{v}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GtNP(u,v);
  false
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{LtNP}}
\logpage{[ 3, 3, 9 ]}\nobreak
\hyperdef{L}{X8075AE7E7A8088FF}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LtNP({\slshape u, v})\index{LtNP@\texttt{LtNP}}
\label{LtNP}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 \texttt{true} if $u < v$ and \texttt{false} if $u \geq v$ 



 Less than function for NP monomials, tests whether \mbox{\texttt{\slshape u}}$<$\mbox{\texttt{\slshape v}}. The ordering is done by degree and then lexicographically. 

 \emph{Example:} Consider the following two monomials. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> u := [1,1,2];
  [ 1, 1, 2 ]
  gap> v := [2,2,1];
  [ 2, 2, 1 ]
\end{Verbatim}
 We test whether \texttt{u} is less than \texttt{v}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LtNP(u,v);
  true
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{LMonsNP}}
\logpage{[ 3, 3, 10 ]}\nobreak
\hyperdef{L}{X86ECA4F57C720E45}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{LMonsNP({\slshape Lnp})\index{LMonsNP@\texttt{LMonsNP}}
\label{LMonsNP}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 A list of leading monomials 



 This function returns the leading monomials of a list \mbox{\texttt{\slshape Lnp}} of polynomials in NP format. The polynomials of \mbox{\texttt{\slshape Lnp}} are required to be clean; see Section \ref{CleanNP}. 

 \emph{Example:} We put two polynomials in NP format into the list \texttt{Lnp}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[1,2,2],[]],[1,-1]];;
  gap> Lnp := [p1,p2];;
\end{Verbatim}
 The list of leading monomials is computed by \texttt{LMonsNP}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LMonsNP(Lnp);
  [ [ 1, 1, 2 ], [ 1, 2, 2 ] ]
\end{Verbatim}
 For a nicer printing, the monomials can be converted into polynomials in NP
format, and then submitted to PrintNPList: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(List(LMonsNP(Lnp), q -> [[q],[1]]));
   a^2b 
   ab^2 
\end{Verbatim}
 }

  

\subsection{\textcolor{Chapter }{MkMonicNP}}
\logpage{[ 3, 3, 11 ]}\nobreak
\hyperdef{L}{X878A8C027DA25196}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MkMonicNP({\slshape np})\index{MkMonicNP@\texttt{MkMonicNP}}
\label{MkMonicNP}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 \mbox{\texttt{\slshape np}} made monic 



 This function returns the scalar multiple of a polynomial \mbox{\texttt{\slshape np}} in NP format that is monic, i.e., has leading coefficient equal to 1. 

 \emph{Example:} Consider the following polynomial in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p := [[[1,1,2],[]],[2,-1]];;
  gap> PrintNP(p);
   2a^2b - 1 
\end{Verbatim}
 The coefficient of the leading term is $2$. The function \texttt{MkMonicNP} finds this coefficient and divides all terms by it: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNP(MkMonicNP(p));
   a^2b - 1/2 
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{MulNP}}
\logpage{[ 3, 3, 12 ]}\nobreak
\hyperdef{L}{X7ABA720E87EFF040}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MulNP({\slshape np1, np2})\index{MulNP@\texttt{MulNP}}
\label{MulNP}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 \mbox{\texttt{\slshape np1}}$*$\mbox{\texttt{\slshape np2}} 



 When invoked with two polynomials \mbox{\texttt{\slshape np1}} and \mbox{\texttt{\slshape np2}} in NP format, this function will return the product \mbox{\texttt{\slshape np1}}$*$\mbox{\texttt{\slshape np2}}. 

 \emph{Example:} Consider the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[1,2,2],[]],[1,-1]];;
\end{Verbatim}
 The function \texttt{MulNP} multiplies the two polynomials. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNP(MulNP(p1,p2));
   a^2bab^2 - ab^2 - a^2b + 1 
\end{Verbatim}
 The fact that this multiplication is not commutative is illustrated by the
following comparison, using \texttt{MulNP} twice and \texttt{AddNP} once. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNP(AddNP(MulNP(p1,p2),MulNP(p2,p1),1,-1));
   - ab^2a^2b + a^2bab^2 
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Gr{\"o}bner functions, standard variant}}\label{grobner}
\logpage{[ 3, 4, 0 ]}
\hyperdef{L}{X81381B2D83D2B9A9}{}
{
 

\subsection{\textcolor{Chapter }{Grobner}}
\logpage{[ 3, 4, 1 ]}\nobreak
\hyperdef{L}{X7CD9F9C97B2563E2}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{Grobner({\slshape Lnp[, D][, max]})\index{Grobner@\texttt{Grobner}}
\label{Grobner}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 If the algorithm terminates, a Gr{\"o}bner Basis or a record if \mbox{\texttt{\slshape max}} is specified (see description). 



 For a list \mbox{\texttt{\slshape Lnp}} of polynomials in NP format this function will use Buchberger's algorithm with
normal form to find a Gr{\"o}bner Basis (if possible, the general problem is
unsolvable). 

 When called with the optional argument \mbox{\texttt{\slshape max}}, which should be a positive integer, the calculation will be interrupted if
it has not ended after \mbox{\texttt{\slshape max}} iterations. The return value will be a record containing lists \texttt{G} and \texttt{todo} of polynomials in NP format, a boolean \texttt{completed}, and an integer \texttt{iterations}. Here \texttt{G} and \texttt{todo} form a Gr{\"o}bner pair (see \cite{CohenGijsbersEtAl2007}). The number of performed iterations will be placed in \texttt{iterations}. If the algorithm has terminated, then \texttt{todo} will be the empty list and \texttt{completed} will be equal to \texttt{true}. If the algorithm has not terminated, then \texttt{todo} will be a non-empty list of polynomials in NP format and \texttt{completed} will be \texttt{false}. 

 By use of the optional argument \mbox{\texttt{\slshape D}}, it is possible to resume a previously interrupted calculation. 

 \emph{Example:} Consider the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[1,2,2],[]],[1,-1]];;
  gap> PrintNPList([p1,p2]);
   a^2b - 1 
   ab^2 - 1 
\end{Verbatim}
 Their Gr{\"o}bner basis can be computed by the function \texttt{Grobner}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> G := Grobner([p1,p2]);;
  gap> PrintNPList(G);
   b - a 
   a^3 - 1 
\end{Verbatim}
 One iteration of the Gr{\"o}bner computations is invoked by use of the
parameter \texttt{max}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> R := Grobner([p1,p2],1);;
  gap> PrintNPList(R.G);
   b - a 
  gap> PrintNPList(R.todo);
   a^3 - 1 
  gap> R.iterations;
  1
  gap> R.completed;
  false
\end{Verbatim}
 The above list \texttt{R.todo} can be used to resume the computation of the Gr{\"o}bner basis computation
with the Gr{\"o}bner pair \texttt{R.G}, \texttt{R.todo}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(Grobner(R.G,R.todo));
   b - a 
   a^3 - 1 
\end{Verbatim}
 In order to perform the Gr{\"o}bner basis computation with polynomials in a
free algebra over the field $GF(2)$, the coefficients of the polynomials need to be defined over that field. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(Grobner([[p1[1],One(GF(2))*p1[2]],[p2[1],One(GF(2))*p1[2]]]));
   b + a 
   a^3 + Z(2)^0 
\end{Verbatim}
 }

  

\subsection{\textcolor{Chapter }{SGrobner}}
\logpage{[ 3, 4, 2 ]}\nobreak
\hyperdef{L}{X7FEDA29E78B0CEED}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SGrobner({\slshape Lnp[, todo][, max]})\index{SGrobner@\texttt{SGrobner}}
\label{SGrobner}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 If the algorithm terminates, a Gr{\"o}bner Basis or a record if \mbox{\texttt{\slshape max}} is specified (see description). 



 For a list \mbox{\texttt{\slshape Lnp}} of polynomials in NP format this function will use Buchberger's algorithm with
strong normal form (see \cite{CohenGijsbersEtAl2007}) to find a Gr{\"o}bner Basis (if possible, the general problem is
unsolvable). 

 When called with the optional argument \mbox{\texttt{\slshape max}}, which should be a positive integer, the calculation will be interrupted if
it has not ended after \mbox{\texttt{\slshape max}} iterations. The return value will be a record containing lists \texttt{G} and \texttt{todo} of polynomials in NP format, a boolean \texttt{completed}, and an integer \texttt{iterations}. Here \texttt{G} and \texttt{todo} form a Gr{\"o}bner pair (see \cite{CohenGijsbersEtAl2007}). The number of performed iterations will be placed in \texttt{iterations}. If the algorithm has terminated, then \texttt{todo} will be the empty list and \texttt{completed} will be equal to \texttt{true}. If the algorithm has not terminated, then \texttt{todo} will be a non-empty list of polynomials in NP format and \texttt{completed} will be \texttt{false}. 

 By use of the optional argument \mbox{\texttt{\slshape D}}, it is possible to resume a previously interrupted calculation. 

 \emph{Example:} Consider the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[1,2,2],[]],[1,-1]];;
  gap> PrintNPList([p1,p2]);
   a^2b - 1 
   ab^2 - 1 
\end{Verbatim}
 Their Gr{\"o}bner basis can be computed by the function \texttt{Grobner}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> G := SGrobner([p1,p2]);;
  gap> PrintNPList(G);
   b - a 
   a^3 - 1 
\end{Verbatim}
 One iteration of the Gr{\"o}bner computations is invoked by use of the
parameter \texttt{max}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> R := SGrobner([p1,p2],1);;
  gap> PrintNPList(R.G);
   b - a 
  gap> PrintNPList(R.todo);
   a^3 - 1 
  gap> R.iterations;
  1
  gap> R.completed;
  false
\end{Verbatim}
 The above list \texttt{R.todo} can be used to resume the computation of the Gr{\"o}bner basis computation
with the Gr{\"o}bner pair \texttt{R.G}, \texttt{R.todo}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(SGrobner(R.G,R.todo));
   b - a 
   a^3 - 1 
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsGrobnerBasis}}
\logpage{[ 3, 4, 3 ]}\nobreak
\hyperdef{L}{X80D4D22C7E643C7B}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsGrobnerBasis({\slshape G})\index{IsGrobnerBasis@\texttt{IsGrobnerBasis}}
\label{IsGrobnerBasis}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 \texttt{true} if \mbox{\texttt{\slshape G}} is a Gr{\"o}bner basis and \texttt{false} otherwise 



 When invoked with a list \mbox{\texttt{\slshape G}} of polynomials in NP format (see Section \ref{NP}), this function will check whether the list is a Gr{\"o}bner basis. The check
is based on Theorem 1.4 from \cite{CohenGijsbersEtAl2007}. 

 Polynomials representing zero are allowed in \mbox{\texttt{\slshape G}}. 

 \emph{Example:} Consider the following list of two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> Lnp := [[[[1,1,2],[]],[1,-1]], [[[1,2,2],[]],[1,-1]]];;
  gap> PrintNPList(Lnp);
   a^2b - 1 
   ab^2 - 1 
\end{Verbatim}
 The function \texttt{IsGrobner} checks whether the list is a Gr{\"o}bner basis. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> IsGrobnerBasis(Lnp);
  false
\end{Verbatim}
 So the answer should be \texttt{true} for the result of a Gr{\"o}bner computation: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> IsGrobnerBasis(Grobner(Lnp));
  true
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsStrongGrobnerBasis}}
\logpage{[ 3, 4, 4 ]}\nobreak
\hyperdef{L}{X7D17F9027F08CF0B}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsStrongGrobnerBasis({\slshape G})\index{IsStrongGrobnerBasis@\texttt{IsStrongGrobnerBasis}}
\label{IsStrongGrobnerBasis}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 \texttt{true} if \mbox{\texttt{\slshape G}} is a strong Gr{\"o}bner basis and \texttt{false} otherwise 



 When invoked with a list \mbox{\texttt{\slshape G}} of polynomials in NP format (see Section \ref{NP}), this function will check whether the polynomials in this list form a strong
Gr{\"o}bner basis (see \cite{CohenGijsbersEtAl2007}). 

 Polynomials representing zero are allowed in \mbox{\texttt{\slshape G}}. 

 \emph{Example:} Consider the following list of two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> Lnp := [[[[1,1,2],[]],[1,-1]], [[[1,2,2],[]],[1,-1]]];;
  gap> PrintNPList(Lnp);
   a^2b - 1 
   ab^2 - 1 
\end{Verbatim}
 The function \texttt{IsStrongGrobner} checks whether the list is a strong Gr{\"o}bner basis. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> IsStrongGrobnerBasis(Lnp);
  false
\end{Verbatim}
 But the answer should be \texttt{true} for the result of a strong Gr{\"o}bner computation: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> IsStrongGrobnerBasis(SGrobner(Lnp));
  true
\end{Verbatim}
 A Gr{\"o}bner basis that is not a strong Gr{\"o}bner basis: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> B := SGrobner(Lnp);;
  gap> Add(B,AddNP(Lnp[1],B[1],1,-1));;
  gap> PrintNPList(B);
   b - a 
   a^3 - 1 
   a^2b - b + a - 1 
  gap> IsGrobnerBasis(B);
  true
  gap> IsStrongGrobnerBasis(B);
  false
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{IsGrobnerPair}}
\logpage{[ 3, 4, 5 ]}\nobreak
\hyperdef{L}{X7E0105ED7FF4210F}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{IsGrobnerPair({\slshape G, D})\index{IsGrobnerPair@\texttt{IsGrobnerPair}}
\label{IsGrobnerPair}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 A boolean, which has the value \texttt{true} if the input forms a Gr{\"o}bner pair 



 When called with two lists of polynomials in NP format, this function returns
true if they form a Gr{\"o}bner pair. Testing whether \mbox{\texttt{\slshape D}} is a basic set for \mbox{\texttt{\slshape G}} might involve computing the Gr{\"o}bner basis. Instead of this only some
simple computations are done to see if it can easily be proven that \mbox{\texttt{\slshape D}} is a basic set for \mbox{\texttt{\slshape G}}. If this cannot be proven easily, then \texttt{false} is returned, even though $G, D$ might still be a Gr{\"o}bner pair. 

 \emph{Example:} Consider the following four polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[1,2,2],[]],[1,-1]];;
  gap> q1 := [[[2],[1]],[1,-1]];;
  gap> q2 := [[[1,1,1],[]],[1,-1]];;
\end{Verbatim}
 The function \texttt{IsGrobnerPair} is used to check whether some combinations of these polynomials in two lists
provide Gr{\"o}bner pairs. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> IsGrobnerPair([p1,p2,q1],[q2]);
  true
  gap> IsGrobnerPair([q1,q2],[p1,p2]);
  false
\end{Verbatim}
 The function \texttt{IsGrobnerPair} applied with an empty list as second argument is a check whether the first
argument is a Gr{\"o}bner basis. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> IsGrobnerPair([p1,p2],[]) = IsGrobnerBasis([p1,p2]);
  true
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{MakeGrobnerPair}}
\logpage{[ 3, 4, 6 ]}\nobreak
\hyperdef{L}{X8752DA1A7CAF77D3}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MakeGrobnerPair({\slshape G, D})\index{MakeGrobnerPair@\texttt{MakeGrobnerPair}}
\label{MakeGrobnerPair}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 A record containing a new Grobner pair 



 When called with as arguments a pair $G, D$, this function cleans \mbox{\texttt{\slshape G}} and \mbox{\texttt{\slshape D}} and adds some obstructions to \mbox{\texttt{\slshape D}} till it is easily provable that \mbox{\texttt{\slshape D}} is a basic set for \mbox{\texttt{\slshape G}} (see \cite{CohenGijsbersEtAl2007}). The result is a record containing the fields \texttt{G} and \texttt{todo} representing the Gr{\"o}bner pair. 

 \emph{Example:} Consider the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[1,2,2],[]],[1,-1]];;
\end{Verbatim}
 The function \texttt{MakeGrobnerPair} turns the list with these two polynomials into a Gr{\"o}bner pair, once the
empty list is added as a second argument. The result is a record whose fields \texttt{G} and \texttt{todo} 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GP := MakeGrobnerPair([p1,p2],[]);;
  gap> PrintNPList(GP.G);
   a^2b - 1 
   ab^2 - 1 
  gap> PrintNPList(GP.todo);
   b - a 
\end{Verbatim}
 These fields are ready for use in \texttt{Grobner} 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := Grobner(GP.G,GP.todo);;
  gap> PrintNPList(GB);
   b - a 
   a^3 - 1 
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Finite-dimensional quotient algebras}}\label{QA}
\logpage{[ 3, 5, 0 ]}
\hyperdef{L}{X7F387F7780425B9A}{}
{
 

\subsection{\textcolor{Chapter }{BaseQA}}
\logpage{[ 3, 5, 1 ]}\nobreak
\hyperdef{L}{X7EAA04247B2C6330}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{BaseQA({\slshape G, t, maxno})\index{BaseQA@\texttt{BaseQA}}
\label{BaseQA}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A list of terms forming a basis of the quotient algebra of the
(non-commutative) polynomial algebra in \mbox{\texttt{\slshape t}} variables by the 2-sided ideal generated by \mbox{\texttt{\slshape G}} 



 When called with a Gr{\"o}bner basis \mbox{\texttt{\slshape G}}, the number \mbox{\texttt{\slshape t}} of generators of the algebra, and a maximum number of terms to be found \mbox{\texttt{\slshape maxno}}, BaseQA will return a (partial) base of the quotient algebra. If this
function is invoked with \mbox{\texttt{\slshape maxno}} equal to 0, then a full basis will be given. If the dimension of this quotient
algebra is infinite and \mbox{\texttt{\slshape maxno}} is set to 0, then the algorithm behind this function will not terminate. 

 \emph{Example:} Consider the following Gr{\"o}bner basis. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[1,2,2],[]],[1,-1]];;
  gap> G := Grobner([p1,p2]);;
  gap> PrintNPList(G);
   b - a 
   a^3 - 1 
\end{Verbatim}
 The function \texttt{BaseQA} computes a basis for the quotient algebra of the free algebra over the
rationals with generators $a$ and $b$ by the two-sided ideal generated by \texttt{G}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(G);
   b - a 
   a^3 - 1 
  gap> BaseQA(G,2,0);
  [ [ [ [  ] ], [ 1 ] ], [ [ [ 1 ] ], [ 1 ] ], [ [ [ 1, 1 ] ], [ 1 ] ] ]
  gap> PrintNPList(BaseQA(G,2,0));
   1 
   a 
   a^2 
\end{Verbatim}
 It is necessary for a correct result that the first argument be a Gr{\"o}bner
basis, as will be clear from the following invocation of \texttt{BaseQA}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(BaseQA([p1,p2],2,10));
   1 
   a 
   b 
   a^2 
   ab 
   ba 
   b^2 
   a^3 
   aba 
   ba^2 
   bab 
   b^2a 
   b^3 
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{DimQA}}
\logpage{[ 3, 5, 2 ]}\nobreak
\hyperdef{L}{X81A50EEE7B56C723}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DimQA({\slshape G, t})\index{DimQA@\texttt{DimQA}}
\label{DimQA}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
The dimension of the quotient algebra 



 When called with a Gr{\"o}bner basis \mbox{\texttt{\slshape G}} and a number of variables \mbox{\texttt{\slshape t}}, the function \texttt{DimQA} will return the dimension of the quotient algebra of the free algebra
generated by \mbox{\texttt{\slshape t}} variables by the ideal generated by \mbox{\texttt{\slshape G}} if it is finite. It will not terminate if the dimension is infinite. 

 If \mbox{\texttt{\slshape t}}=0, the function will compute the minimal value of \texttt{t} such that the polynomials in \mbox{\texttt{\slshape G}} belong to the free algebra on \texttt{t} generators. 

 To check whether the dimension of the quotient algebra is finite and to
determine the type of growth if it is infinite, see also the functions \texttt{FinCheckQA} (\ref{FinCheckQA}) and \texttt{DetermineGrowthQA} (\ref{DetermineGrowthQA}) in Section \ref{finiteness}. 

 \emph{Example:} Consider the following Gr{\"o}bner basis. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-2]];;
  gap> p2 := [[[1,2,2],[]],[1,-2]];;
  gap> G := Grobner([p1,p2]);;
  gap> PrintNPList(G);
   b - a 
   a^3 - 2 
\end{Verbatim}
 The function \texttt{DimQA} computes the dimension of the quotient algebra of the free algebra over the
rationals with generators $a$ and $b$ by the two-sided ideal generated by \texttt{G}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> DimQA(G,2);
  3
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{MatrixQA}}
\logpage{[ 3, 5, 3 ]}\nobreak
\hyperdef{L}{X7DFA841A8425DD94}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MatrixQA({\slshape i, B, GB})\index{MatrixQA@\texttt{MatrixQA}}
\label{MatrixQA}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 The matrix representation for the \mbox{\texttt{\slshape i}}-th generator of the algebra for right multiplication in the quotient algebra 



 Given a basis \mbox{\texttt{\slshape B}} of the quotient algebra, a Gr{\"o}bner basis (record) \mbox{\texttt{\slshape GB}}, and a natural number \mbox{\texttt{\slshape i}}, this function creates a matrix representation for the \mbox{\texttt{\slshape i}}-th generator of the algebra for right multiplication. 

 \emph{Example:} Consider the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,1,2],[]],[1,-1]];;
  gap> p2 := [[[2,2,2,1],[]],[1,-1]];;
\end{Verbatim}
 The matrix of right multiplication by the first indeterminate $a$ on the quotient algebra with respect to the ideal generated by \texttt{p1} and \texttt{p2} is obtained by applying \texttt{MatrixQA} to the Gr{\"o}bner basis of these generators and a basis of the quotient
algebra as found in \texttt{BaseQA} (\ref{BaseQA}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := Grobner([p1,p2]);;
  gap> B := BaseQA(GB,2,0);;
  gap> PrintNPList(B);
   1 
   a 
   b 
   a^2 
   ab 
   a^3 
   a^2b 
   a^4 
  gap> Display(MatrixQA(1, B,GB));
  [ [  0,  1,  0,  0,  0,  0,  0,  0 ],
    [  0,  0,  0,  1,  0,  0,  0,  0 ],
    [  0,  0,  0,  0,  1,  0,  0,  0 ],
    [  0,  0,  0,  0,  0,  1,  0,  0 ],
    [  0,  0,  0,  0,  0,  0,  1,  0 ],
    [  0,  0,  0,  0,  0,  0,  0,  1 ],
    [  1,  0,  0,  0,  0,  0,  0,  0 ],
    [  0,  0,  1,  0,  0,  0,  0,  0 ] ]
\end{Verbatim}
 The function is also applicable to Gr{\"o}bner basis records for modules.
Consider the following two vectors. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> v1 := [[[-1,1,2],[-1]],[1,-1]];;
  gap> v2 := [[[-2,2,2],[-2]],[1,-2]];;
\end{Verbatim}
 The Gr{\"o}bner basis record for this data is found by \texttt{SGrobnerModule} (\ref{SGrobnerModule}) and a quotient module basis by \texttt{BaseQM} (\ref{BaseQM}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBR := SGrobnerModule([v1,v2],[p1,p2]);;
  gap> B := BaseQM(GBR,2,2,0);;
\end{Verbatim}
 The matrix of right multiplication by $a$, the first generator of the free algebra, is 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> Display(MatrixQA(1,B,GBR));
  [ [  0,  1 ],
    [  1,  0 ] ]
\end{Verbatim}
 }

  

\subsection{\textcolor{Chapter }{MatricesQA}}
\logpage{[ 3, 5, 4 ]}\nobreak
\hyperdef{L}{X78E4BF2F7F0D5E74}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MatricesQA({\slshape t, B, GB})\index{MatricesQA@\texttt{MatricesQA}}
\label{MatricesQA}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 The matrix representation for the \mbox{\texttt{\slshape t}} generators of the algebra for right multiplication in the quotient algebra 



 Given a basis \mbox{\texttt{\slshape B}} of the quotient algebra, a Gr{\"o}bner basis (record) \mbox{\texttt{\slshape GB}}, and a natural number \mbox{\texttt{\slshape t}}, this function creates a list of \mbox{\texttt{\slshape t}} matrices representing the linear transformations of the generators of the
algebra by right multiplication on the quotient algebra. 

 \emph{Example:} Consider the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,1,2],[]],[1,-1]];;
  gap> p2 := [[[2,2,2,1],[]],[1,-1]];;
\end{Verbatim}
 The function \texttt{MatricesQA} gives the list of matrices found by \texttt{MatrixQA} (\ref{MatrixQA}) when the first argument takes the integer values between 1 and the number of
all algebra generators. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := Grobner([p1,p2]);;
  gap> B := BaseQA(GB,2,0);;
  gap> mats := MatricesQA(2,B,GB);;
  gap> for mat in mats do Display(mat); Print("\n"); od;
  [ [  0,  1,  0,  0,  0,  0,  0,  0 ],
    [  0,  0,  0,  1,  0,  0,  0,  0 ],
    [  0,  0,  0,  0,  1,  0,  0,  0 ],
    [  0,  0,  0,  0,  0,  1,  0,  0 ],
    [  0,  0,  0,  0,  0,  0,  1,  0 ],
    [  0,  0,  0,  0,  0,  0,  0,  1 ],
    [  1,  0,  0,  0,  0,  0,  0,  0 ],
    [  0,  0,  1,  0,  0,  0,  0,  0 ] ]
  
  [ [  0,  0,  1,  0,  0,  0,  0,  0 ],
    [  0,  0,  0,  0,  1,  0,  0,  0 ],
    [  0,  0,  0,  1,  0,  0,  0,  0 ],
    [  0,  0,  0,  0,  0,  0,  1,  0 ],
    [  0,  0,  0,  0,  0,  1,  0,  0 ],
    [  1,  0,  0,  0,  0,  0,  0,  0 ],
    [  0,  0,  0,  0,  0,  0,  0,  1 ],
    [  0,  1,  0,  0,  0,  0,  0,  0 ] ]
  
\end{Verbatim}
 The result is also obtainable by use of the List function: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> MatricesQA(2,B,GB) = List([1,2], q -> MatrixQA(q,B,GB));
  true
\end{Verbatim}
 }

  

\subsection{\textcolor{Chapter }{MulQA}}
\logpage{[ 3, 5, 5 ]}\nobreak
\hyperdef{L}{X80C4D0E882B05FDF}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MulQA({\slshape p1, p2, G})\index{MulQA@\texttt{MulQA}}
\label{MulQA}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
The strong normal form of the product \mbox{\texttt{\slshape p1}}$*$\mbox{\texttt{\slshape p2}} with respect to \mbox{\texttt{\slshape G}} 



 When called with two polynomials in NP form, \mbox{\texttt{\slshape p1}} and \mbox{\texttt{\slshape p2}}, and a Gr{\"o}bner basis \mbox{\texttt{\slshape G}}, this function will return the product in the quotient algebra. 

 \emph{Example:} Consider the following Gr{\"o}bner basis. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[1,2,2],[]],[1,-1]];;
  gap> G := Grobner([p1,p2]);;
  gap> PrintNPList(G);
   b - a 
   a^3 - 1 
\end{Verbatim}
 Print the product in the quotient algebra of the polynomials $a-2$ and $b-3$ by use of \texttt{MulQA}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> s1 := [[[1],[]],[1,-2]];;
  gap> s2 := [[[2],[]],[1,-3]];;
  gap> PrintNP(MulQA(s1,s2,G));
   a^2 - 5a + 6 
\end{Verbatim}
 The result should be equal to the strong normal form of the product of $a-2$ and $b-3$ with respect to \texttt{G}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> MulQA(s1,s2,G) = StrongNormalFormNP(MulNP(s1,s2),G);
  true
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{StrongNormalFormNP}}
\logpage{[ 3, 5, 6 ]}\nobreak
\hyperdef{L}{X8563683E7FA604F8}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{StrongNormalFormNP({\slshape f, G})\index{StrongNormalFormNP@\texttt{StrongNormalFormNP}}
\label{StrongNormalFormNP}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 The strong normal form of a polynomial with respect to \mbox{\texttt{\slshape G}} 



 When invoked with a polynomial in NP format (see Section \ref{NP}) and a finite set \mbox{\texttt{\slshape G}} of polynomials in NP format, this function will return a strong normal form
(that is, a polynomial that is equal to \mbox{\texttt{\slshape f}} modulo \mbox{\texttt{\slshape G}}, every monomial of which is a multiple of no leading monomial of an element
of \mbox{\texttt{\slshape G}}). 

 Note that the StrongNormalForm with respect to a Gr{\"o}bner basis is uniquely
determined, but that for an arbitrary input \mbox{\texttt{\slshape G}} the result may depend on the order in which the individual reduction steps are
implemented. 

 \emph{Example:} Consider the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[1,2,2],[]],[1,-1]];;
\end{Verbatim}
 The strong normal form of the polynomial 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p := [[[1,1,1,2],[2,1],[]],[1,-1,3]];;
\end{Verbatim}
 with respect to the list \texttt{[p1,p2]} is computed by use of the function \texttt{StrongNormalFormNP}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNP(StrongNormalFormNP(p,[p1,p2]));
   - ba + a + 3 
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Finiteness and Hilbert series}}\label{finiteness}
\logpage{[ 3, 6, 0 ]}
\hyperdef{L}{X79FE4A3983E2329F}{}
{
 

\subsection{\textcolor{Chapter }{DetermineGrowthQA}}
\logpage{[ 3, 6, 1 ]}\nobreak
\hyperdef{L}{X83C57C3A7DCF0471}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DetermineGrowthQA({\slshape Lm, t, exact})\index{DetermineGrowthQA@\texttt{DetermineGrowthQA}}
\label{DetermineGrowthQA}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 If the quotient algebra is finite dimensional, then the integer \texttt{0} is returned. If the growth is polynomial and the algorithm found a precise
degree \texttt{d} of the growth polynomial, then \texttt{d} is returned. If the growth is polynomial and no precise answer is found, an
interval \texttt{[d1,d2]} is returned in which the dimension lies. If the growth is exponential, the
string \texttt{"exponential growth"} is returned. 



 Given leading monomials \mbox{\texttt{\slshape Lm}} of some Gr{\"o}bner basis (these can be obtained with the function \texttt{LMonsNP} (\ref{LMonsNP})), the number \mbox{\texttt{\slshape t}} of generators of a free algebra, say $A$, in which the monomials lie, and a boolean \mbox{\texttt{\slshape exact}}, this function checks whether the quotient algebra of $A$ by the ideal generated by \mbox{\texttt{\slshape Lm}} is finite dimensional. In doing so it constructs a graph of normal words which
helps with the computations. It also checks for exponential or polynomial
growth in the infinite case. 

 If the precise degree is needed in the polynomial case, the argument \mbox{\texttt{\slshape exact}} should be set to \texttt{true}. 

 The function \texttt{DetermineGrowthQA} allows preprocessing, which may speed up the computations. This can be done
with the function \texttt{PreprocessAnalysisQA} (\ref{PreprocessAnalysisQA}). 

 \emph{Example:} For the list of monomials consisting of a single variable in a free algebra
generated by two variables the growth is clearly polynomial of degree 1. This
is verified by invoking \texttt{DetermineGrowthQA} with arguments \texttt{[[1]]} (the list of the single monomial consisting of the first variable), the number
of generators of the free algebra to which the monomials belong (which is 2
here), and the boolean \texttt{true} indicating that we wish a precise degree in case of polynomial growth. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> DetermineGrowthQA([[1]],2,true);
  1
\end{Verbatim}
 Here is an example of polynomial growth of degree 2: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> L := [[1,2,1],[2,2,1]];
  [ [ 1, 2, 1 ], [ 2, 2, 1 ] ]
  gap> DetermineGrowthQA(L,2,true);
  2
\end{Verbatim}
 In order to show how to apply the function to arbitrary polynomials, consider
the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> F := GF(256);
  GF(2^8)
  gap> z := GeneratorsOfField(F)[1];
  Z(2^8)
  gap> p1 := [[[1,1,1,2],[]],[z,1]];;
  gap> p2 := [[[2,2,2,1],[]],[1,z]];;
\end{Verbatim}
 The polynomials \texttt{p1} and \texttt{p2} have coefficients in the field \texttt{F} of order 256. In order to study the growth of the quotient algebra we first
compute the list of leading monomials of the Gr{\"o}bner basis elements and
next apply \texttt{DetermineGrowthQA}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := Grobner([p1,p2]);;
  gap> L := LMonsNP(GB);;
  gap> for lm  in L  do PrintNP( [ [ lm ], [ 1 ] ] ); od;
   a^3b 
   b^2 
   a^5 
   ba 
  gap> DetermineGrowthQA(L,2,true);
  0
\end{Verbatim}
 }

  

\subsection{\textcolor{Chapter }{FinCheckQA}}
\logpage{[ 3, 6, 2 ]}\nobreak
\hyperdef{L}{X792E39A98717D779}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{FinCheckQA({\slshape Lm, t})\index{FinCheckQA@\texttt{FinCheckQA}}
\label{FinCheckQA}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 \texttt{true}, if the quotient algebra is finite dimensional and\texttt{ false} otherwise 



 Given a list \mbox{\texttt{\slshape Lm}} of leading monomials such that none of these divides another, and the number \mbox{\texttt{\slshape t}} of generators of a free algebra in which they are embedded, this function
checks whether the quotient algebra of the free algebra by the ideal generated
by \mbox{\texttt{\slshape Lm}} is finite dimensional. 

 When given a Gr{\"o}bner basis $G$, the dimension of the quotient algebra of the free algebra by the ideal
generated by $G$ coincides with the the dimension of the quotient algebra of the free algebra
by the ideal generated by the leading terms of elements of $G$. These can be obtained from $G$ with the function \texttt{LMonsNP} (\ref{LMonsNP}). 

 The function \texttt{FinCheckQA} allows for preprocessing with the function \texttt{PreprocessAnalysisQA} (\ref{PreprocessAnalysisQA}). This may speed up the computation. 

 \emph{Example:} Consider the following list \texttt{L} of two monomials. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> L := [[1,2,1],[2,2,1]];;
\end{Verbatim}
 Finiteness of the dimension of the quotient algebra of the free algebra by the
ideal generated by these two monomials can be decided by means of \texttt{FinCheckQA}. Its arguments are \texttt{L} and the number of generators of the free algebra in which the monomials
reside. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> FinCheckQA(L,2);
  false
\end{Verbatim}
 This example turns out to be infinite dimensional. Here is a
finite-dimensional example. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> FinCheckQA([[1],[2,2]],2);
  true
\end{Verbatim}
 }

  

\subsection{\textcolor{Chapter }{HilbertSeriesQA}}
\logpage{[ 3, 6, 3 ]}\nobreak
\hyperdef{L}{X7CFD47367CF309EB}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{HilbertSeriesQA({\slshape Lm, t, d})\index{HilbertSeriesQA@\texttt{HilbertSeriesQA}}
\label{HilbertSeriesQA}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 A list of coefficients of the Hilbert series up to degree \mbox{\texttt{\slshape d}} 



 Given a set of monomials \mbox{\texttt{\slshape Lm}}, none of which divides another, and the number \mbox{\texttt{\slshape n}} of generators of the free algebra in which they occur, this function computes
the Hilbert series up to a given degree \mbox{\texttt{\slshape d}}. 

 Internally, it builds (part of) the graph of standard words.  This function will remove zeroes from the end of the list of coefficients. 

 \emph{Example:} Consider the following list \texttt{L} of two monomials. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> L := [[1,2,1],[2,2,1]];;
\end{Verbatim}
 Finiteness of the dimension of the quotient algebra of the free algebra by the
ideal generated by these two monomials can be decided by means of \texttt{FinCheckQA}. Its arguments are \texttt{L} and the number of generators of the free algebra in which the monomials
reside. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> HilbertSeriesQA(L,2,10);
  [ 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 ]
\end{Verbatim}
 This indicates that the growth may be polynomial. \texttt{DetermineGrowthQA} (\ref{DetermineGrowthQA}) can be used to check this. }

 

\subsection{\textcolor{Chapter }{PreprocessAnalysisQA}}
\logpage{[ 3, 6, 4 ]}\nobreak
\hyperdef{L}{X863124677B933CEE}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PreprocessAnalysisQA({\slshape Lm, t, iterations})\index{PreprocessAnalysisQA@\texttt{PreprocessAnalysisQA}}
\label{PreprocessAnalysisQA}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 The left-reduced list of `obstructions', obtained by applying left-reduction
recursively 



 This preprocessing of the list \mbox{\texttt{\slshape Lm}} of monomials can be applied to the set of leading terms of a Gr{\"o}bner basis
before calling the functions \texttt{FinCheckQA} (\ref{FinCheckQA}) or \texttt{DetermineGrowthQA} (\ref{DetermineGrowthQA}), in order to speed up calculations using these functions. As the name
suggests, \mbox{\texttt{\slshape t}} should be the size of the alphabet. The parameter \mbox{\texttt{\slshape iterations}} gives the maximum number of recursion steps in the preprocessing (\mbox{\texttt{\slshape 0}} means no restriction). For more information about this function see \cite{Krook2003}. 

 \emph{Example:} Consider the following two polynomials in NP format of which a Gr{\"o}bner
basis is computed. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  F := GF(256);
  z := GeneratorsOfField(F)[1];
  gap> p1 := [[[1,1,1,1,2],[]],[1,-1]];;
  gap> p2 := [[[2,2,2,1,1,1],[]],[1,-1]];;
  gap> GB := Grobner([p1,p2]);;
  gap> PrintNPList(GB);
   a^4b - 1 
   b^2 - a 
   ba - ab 
   a^5 - b 
\end{Verbatim}
 Application of \texttt{PreprocessAnalysisQA} is carried out on the leading terms of \texttt{GB}, with 2, 4, 8, recursions, respectively. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> L := LMonsNP(GB);
  [ [ 1, 1, 1, 1, 2 ], [ 2, 2 ], [ 2, 1 ], [ 1, 1, 1, 1, 1 ] ]
  gap> L1 := PreprocessAnalysisQA(L,2,2);
  [ [ 1, 1, 1 ], [ 2, 1 ], [ 1, 1, 2 ], [ 2, 2 ] ]
  gap> L2 := PreprocessAnalysisQA(L1,2,4);
  [ [ 1 ], [ 2 ] ]
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Functions of the trace variant}}\label{tracefun}
\logpage{[ 3, 7, 0 ]}
\hyperdef{L}{X7BA5CAA07890F7AA}{}
{
 

\subsection{\textcolor{Chapter }{EvalTrace}}
\logpage{[ 3, 7, 1 ]}\nobreak
\hyperdef{L}{X813454F6799B1D57}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{EvalTrace({\slshape p, Lnp})\index{EvalTrace@\texttt{EvalTrace}}
\label{EvalTrace}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 The trace evaluated to a polynomial in NP format. 



 For a traced polynomial \mbox{\texttt{\slshape p}} and a list \mbox{\texttt{\slshape Lnp}} of polynomials in NP format, this program evaluates the trace by substituting
the polynomials of \mbox{\texttt{\slshape Lnp}} back in the expression \texttt{p.trace} and computing the resulting polynomial. The result should have the same value
as \texttt{p.pol}. 

 \emph{Example:} First we compute the traced Gr{\"o}bner basis of the list of the following two
polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[2,2,1],[]],[1,-1]];;
  gap> Lnp := [p1,p2];;
  gap> GBT := SGrobnerTrace(Lnp);;
\end{Verbatim}
 In order to check that the polynomials in \texttt{GBT} belong to the ideal generated by \texttt{p1} and \texttt{p2}, we evaluate the trace. For each traced polynomial \texttt{p} in \texttt{GBT}, the polynomial \texttt{p.pol} is equated to the evaluated expression \texttt{p.trace}, in which each occurrence of \texttt{G(i)} is replaced by \texttt{Lnp[i]} by use of \texttt{EvalTrace}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> ForAll(GBT,q -> EvalTrace(q,Lnp) = q.pol);
  true
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{PrintTraceList}}
\logpage{[ 3, 7, 2 ]}\nobreak
\hyperdef{L}{X83D1560C7F2A04BA}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PrintTraceList({\slshape G})\index{PrintTraceList@\texttt{PrintTraceList}}
\label{PrintTraceList}
}\hfill{\scriptsize (function)}}\\


 When invoked with a list \mbox{\texttt{\slshape G}} of traced polynomials, this function prints the traces of that list. 

 \emph{Example:} First we compute the traced Gr{\"o}bner basis of the list of two polynomials
in NP format and next we print it by use of \texttt{PrintTraceList}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[2,2,1],[]],[1,-1]];;
  gap> GBT := SGrobnerTrace([p1,p2]);;
  gap> PrintTraceList(GBT);
   aG(1) - bG(1) - G(1)ba^2b + a^2G(2)ab 
  
   G(1)ba^2 + bG(1)ba + G(2) - a^2G(2)a - ba^2G(2) 
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{PrintTracePol}}
\logpage{[ 3, 7, 3 ]}\nobreak
\hyperdef{L}{X8039BEE77C070FB1}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PrintTracePol({\slshape p})\index{PrintTracePol@\texttt{PrintTracePol}}
\label{PrintTracePol}
}\hfill{\scriptsize (function)}}\\


 This function prints the trace of an NP polynomial \mbox{\texttt{\slshape p}}. 

 \emph{Example:} First we compute the traced Gr{\"o}bner basis of the list of two polynomials
in NP format. Next we print the trace polynomial of the members of the list by
use of \texttt{PrintTracePol}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[2,2,1],[]],[1,-1]];;
  gap> GBT := SGrobnerTrace([p1,p2]);;
  gap> for np in GBT do PrintTracePol(np); Print("\n"); od;
   aG(1) - bG(1) - G(1)ba^2b + a^2G(2)ab 
  
   G(1)ba^2 + bG(1)ba + G(2) - a^2G(2)a - ba^2G(2) 
  
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{PrintNPListTrace}}
\logpage{[ 3, 7, 4 ]}\nobreak
\hyperdef{L}{X7DD0B56D7BD6CD98}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{PrintNPListTrace({\slshape G})\index{PrintNPListTrace@\texttt{PrintNPListTrace}}
\label{PrintNPListTrace}
}\hfill{\scriptsize (function)}}\\


 When invoked with a set of traced non-commutative polynomials \mbox{\texttt{\slshape G}}, this function prints the list of the traced polynomials, without the trace. 

 \emph{Example:} First we compute the traced Gr{\"o}bner basis of the list of two polynomials
in NP format. Next we print the polynomials found by use of \texttt{PrintNPListTrace}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[2,2,1],[]],[1,-1]];;
  gap> GBT := SGrobnerTrace([p1,p2]);;
  gap> PrintNPListTrace(GBT);
   b - a 
   a^3 - 1 
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{SGrobnerTrace}}
\logpage{[ 3, 7, 5 ]}\nobreak
\hyperdef{L}{X78AE6EED83B97595}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SGrobnerTrace({\slshape Lnp})\index{SGrobnerTrace@\texttt{SGrobnerTrace}}
\label{SGrobnerTrace}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 Gr{\"o}bner Basis, traceable 



 For a list of noncommutative polynomials \mbox{\texttt{\slshape Lnp}} this function will use Buchberger's algorithm with strong normal form to find
a Gr{\"o}bner Basis \texttt{G} (if possible; the general problem is unsolvable). 

 The results will be traceable. Functions that can print the Gr{\"o}bner basis
are \texttt{PrintTraceList} (\ref{PrintTraceList}) (with the trace) and \texttt{PrintNPListTrace} (\ref{PrintNPListTrace}) (without the trace). 

 \emph{Example:} For the list of the following two polynomials in NP format, a traced
Gr{\"o}bner basis is computed. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[2,2,1],[]],[1,-1]];;
  gap> GBT := SGrobnerTrace([p1,p2]);
  [ rec( pol := [ [ [ 2 ], [ 1 ] ], [ 1, -1 ] ], 
        trace := [ [ [  ], 1, [ 2, 1, 1, 2 ], -1 ], [ [ 2 ], 1, [  ], -1 ], 
            [ [ 1 ], 1, [  ], 1 ], [ [ 1, 1 ], 2, [ 1, 2 ], 1 ] ] ), 
    rec( pol := [ [ [ 1, 1, 1 ], [  ] ], [ 1, -1 ] ], 
        trace := [ [ [ 2 ], 1, [ 2, 1 ], 1 ], [ [  ], 1, [ 2, 1, 1 ], 1 ], 
            [ [  ], 2, [  ], 1 ], [ [ 2, 1, 1 ], 2, [  ], -1 ], 
            [ [ 1, 1 ], 2, [ 1 ], -1 ] ] ) ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{StrongNormalFormTraceDiff}}
\logpage{[ 3, 7, 6 ]}\nobreak
\hyperdef{L}{X8219059A86A54130}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{StrongNormalFormTraceDiff({\slshape np, GBT})\index{StrongNormalFormTraceDiff@\texttt{StrongNormalFormTraceDiff}}
\label{StrongNormalFormTraceDiff}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 The traced polynomial for the difference of \mbox{\texttt{\slshape f}} with the strong normal form of \mbox{\texttt{\slshape np}} with respect to \mbox{\texttt{\slshape GBT}} 



 When invoked with a polynomial \mbox{\texttt{\slshape np}} in NP format as its first argument, and a traced Gr{\"o}bner basis \mbox{\texttt{\slshape GBT}} as generated by \texttt{SGrobnerTrace} (\ref{SGrobnerTrace}), this function returns the difference of \mbox{\texttt{\slshape np}} with the strong normal form of \mbox{\texttt{\slshape np}} with respect to \mbox{\texttt{\slshape GBT}}. This difference \texttt{d} is returned as a traced polynomial. The trace information \texttt{d.trace} gives an expression of \texttt{d.pol} as a combination of polynomials from the list of polynomials to which the
trace parts of \mbox{\texttt{\slshape GBT}} are referring. Typically, this is the set of relations used as input to the
computation of \mbox{\texttt{\slshape GBT}}. 

 Note that the difference of the polynomials \mbox{\texttt{\slshape np}} and \texttt{d.pol} is the same as the StrongNormalForm of \mbox{\texttt{\slshape np}}. 

 \emph{Example:} First we compute the traced Gr{\"o}bner basis of the list of the following two
polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[2,2,1],[]],[1,-1]];;
  gap> GBT := SGrobnerTrace([p1,p2]);;
\end{Verbatim}
 Of the polynomial $a^6$ we compute its difference with the normal form. The result is printed by used
of \texttt{PrintNP} (\ref{PrintNP}) and \texttt{PrintTraceList} (\ref{PrintTraceList}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> f := [[[1,1,1,1,1,1]],[1]];;
  gap> sf := StrongNormalFormTraceDiff(f,GBT);;
  gap> PrintNP(sf.pol);
   a^6 - 1 
  gap> PrintTraceList([sf]);
   G(1)ba^2 + bG(1)ba + G(1)ba^5 + bG(1)ba^4 + G(2) + G(2)a^3 - a^2G(
  2)a - ba^2G(2) - a^2G(2)a^4 - ba^2G(2)a^3 
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Functions of the truncated variant}}\label{truncfun}
\logpage{[ 3, 8, 0 ]}
\hyperdef{L}{X7E4E3AD07B2465F9}{}
{
 
\subsection{\textcolor{Chapter }{Examples}}\logpage{[ 3, 8, 1 ]}
\hyperdef{L}{X7A489A5D79DA9E5C}{}
{
 More about these functions can be found in \ref{Example11} }

 

\subsection{\textcolor{Chapter }{SGrobnerTrunc}}
\logpage{[ 3, 8, 2 ]}\nobreak
\hyperdef{L}{X7CD043E081BF2302}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SGrobnerTrunc({\slshape Lnp, deg, wtv})\index{SGrobnerTrunc@\texttt{SGrobnerTrunc}}
\label{SGrobnerTrunc}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 A list of homogeneous NP polynomials if the first argument of the input is a
list of homogeneous NP polynomials, and the boolean \texttt{false} otherwise. 



 This functions should be invoked with a list \mbox{\texttt{\slshape Lnp}} of polynomials in NP format, a natural number \mbox{\texttt{\slshape deg}}, and a weight vector \mbox{\texttt{\slshape wtv}} of length the number of generators of the free algebra $A$ containing the elements of \mbox{\texttt{\slshape Lnp}}, and with positive integers for entries. If the polynomials of \mbox{\texttt{\slshape Lnp}} are homogeneous with respect to \mbox{\texttt{\slshape wtv}}, the function will return a Gr{\"o}bner basis of \mbox{\texttt{\slshape Lnp}} truncated above \mbox{\texttt{\slshape deg}}. If the list of polynomials \mbox{\texttt{\slshape Lnp}} is not homogeneous with respect to \mbox{\texttt{\slshape wtv}}, it returns \texttt{false}. The homogeneity check can be carried out by \texttt{CheckHomogeneousNPs} (\ref{CheckHomogeneousNPs}). 

 \emph{Example:} Consider the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,2,2,1],[2,1,1,2]],[1,-1]];;
  gap> p2 := [[[2,2,2],[1,1]],[1,-1]];;
  gap> PrintNPList([p1,p2]);
   ab^2a - ba^2b 
   b^3 - a^2 
\end{Verbatim}
 These are homogeneous with respect to weights $[3,2]$. The degrees are $10$ and $6$, respectively. The Gr{\"o}bner basis truncated above degree 12 of the list \texttt{[p1,p2]} is computed and subsequently printed as follows. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(SGrobnerTrunc([p1,p2],12,[3,2]));
   ba^2 - a^2b 
   b^3 - a^2 
   ab^2a - a^2b^2 
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{CheckHomogeneousNPs}}
\logpage{[ 3, 8, 3 ]}\nobreak
\hyperdef{L}{X83C9E598798D5809}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{CheckHomogeneousNPs({\slshape Lnp, wtv})\index{CheckHomogeneousNPs@\texttt{CheckHomogeneousNPs}}
\label{CheckHomogeneousNPs}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 A list of weighted degrees of the polynomials if these are homogeneous with
respect to \mbox{\texttt{\slshape wtv}}, and \texttt{false} otherwise. 



 When invoked with a list of NP polynomials \mbox{\texttt{\slshape Lnp}} and a weight vector \mbox{\texttt{\slshape wtv}} (whose entries should be positive integers), this function returns the list of
weighted degrees of the polynomials in \mbox{\texttt{\slshape Lnp}} if these are all homogeneous and nonzero, and \texttt{false} otherwise. Here, a polynomial is (weighted) homogeneous with respect to a
weight vector $w$ if there is constant $d$ such that, for each monomial $[t_1,...,t_r]$ of the polynomial the sum of all $w[t_i]$ for $i$ in $[1..r]$ is equal to $d$. The natural number $d$ is then called the weighted degree of the polynomial. 

 \emph{Example:} Consider the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,2,2,1],[2,1,1,2]],[1,-1]];;
  gap> p2 := [[[2,2,2],[1,1]],[1,-1]];;
  gap> PrintNPList([p1,p2]);
   ab^2a - ba^2b 
   b^3 - a^2 
\end{Verbatim}
 These are homogeneous with respect to weights $[3,2]$. The degrees are $10$ and $6$, respectively. This is checked as follows. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> CheckHomogeneousNPs([p1,p2],[3,2]);
  [ 10, 6 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{BaseQATrunc}}
\logpage{[ 3, 8, 4 ]}\nobreak
\hyperdef{L}{X7E33C064875D95CA}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{BaseQATrunc({\slshape Lnp, deg, wtv})\index{BaseQATrunc@\texttt{BaseQATrunc}}
\label{BaseQATrunc}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 A list of monomials if the first argument of the input is a list of
homogeneous NP polynomials or \texttt{false}. 



 When invoked with a list of polynomials \mbox{\texttt{\slshape Lnp}}, a natural number \mbox{\texttt{\slshape deg}}, and a weight vector \mbox{\texttt{\slshape wtv}} of length the number of variables and with positive integers for entries, such
that the polynomials of \mbox{\texttt{\slshape Lnp}} are homogeneous with respect to \mbox{\texttt{\slshape wtv}}, it returns a list whose $i$-th entry is a basis of monomials of the homogeneous part of degree $i-1$ the quotient algebra of the free noncommutative algebra by the weighted
homogeneous ideal generated by \mbox{\texttt{\slshape Lnp}} truncated above \mbox{\texttt{\slshape deg}}. If the list of polynomials \mbox{\texttt{\slshape Lnp}} is not homogeneous, it returns \texttt{false}. 

 \emph{Example:} Consider the truncated Gr{\"o}bner basis of the following two polynomials in
NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,2,2,1],[2,1,1,2]],[1,-1]];;
  gap> p2 := [[[2,2,2],[1,1]],[1,-1]];;
  gap> wtv := [3,2];;
  gap> GB := SGrobnerTrunc([p1,p2],12,wtv);;
  gap> GBNP.ConfigPrint("a","b");
  gap> PrintNPList(GB);
   ba^2 - a^2b 
   b^3 - a^2 
   ab^2a - a^2b^2 
\end{Verbatim}
 A basis of standard monomials is found and printed as follows. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> BT := BaseQATrunc(GB,12,wtv);;
  gap> for degpart in BT do 
  >   for mon in degpart do PrintNP([[mon],[1]]); od;
  > od;
   1 
   b 
   a 
   b^2 
   ba 
   ab 
   a^2 
   b^3 
   b^2a 
   bab 
   ab^2 
   aba 
   a^2b 
   b^4 
   a^3 
   b^3a 
   b^2ab 
   bab^2 
   ab^3 
   baba 
   abab 
   a^2b^2 
   b^5 
   a^2ba 
   b^4a 
   a^3b 
   b^3ab 
   b^2ab^2 
   bab^3 
   ab^4 
   a^4 
   b^2aba 
   ab^3a 
   babab 
   abab^2 
   a^2b^3 
   b^6 
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{DimsQATrunc}}
\logpage{[ 3, 8, 5 ]}\nobreak
\hyperdef{L}{X7C6882DB837A9F5A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DimsQATrunc({\slshape Lnp, deg, wtv})\index{DimsQATrunc@\texttt{DimsQATrunc}}
\label{DimsQATrunc}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 A list of monomials if the first argument of the input is a list of
homogeneous NP polynomials or \texttt{false}. 



 When invoked with a list of polynomials \mbox{\texttt{\slshape Lnp}}, a natural number \mbox{\texttt{\slshape deg}}, and a weight vector \mbox{\texttt{\slshape wtv}} of length the number of variables and with positive integers for entries, such
that the polynomials of \mbox{\texttt{\slshape Lnp}} are homogeneous with respect to \mbox{\texttt{\slshape wtv}}, it returns a list of dimensions of the homogeneous parts of the quotient
algebra of the free noncommutative algebra by the ideal generated by \mbox{\texttt{\slshape Lnp}} truncated above \mbox{\texttt{\slshape deg}}. The $i$-th entry of the list gives the dimension of the homogeneous part of degree $i-1$ of the quotient algebra. If the list of polynomials \mbox{\texttt{\slshape Lnp}} is not homogeneous, it returns \texttt{false}. 

 \emph{Example:} Consider the truncated Gr{\"o}bner basis of the following two polynomials in
NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,2,2,1],[2,1,1,2]],[1,-1]];;
  gap> p2 := [[[2,2,2],[1,1]],[1,-1]];;
  gap> wtv := [3,2];;
  gap> GB := SGrobnerTrunc([p1,p2],12,wtv);;
\end{Verbatim}
 Information on the dimensions of the homogeneous parts of the quotient algebra
is found as follows, 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> DimsQATrunc(GB,12,wtv);
  [ 1, 0, 1, 1, 1, 2, 2, 3, 3, 5, 4, 7, 7 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{FreqsQATrunc}}
\logpage{[ 3, 8, 6 ]}\nobreak
\hyperdef{L}{X7FBA7F1D79DA883F}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{FreqsQATrunc({\slshape Lnp, deg, wtv})\index{FreqsQATrunc@\texttt{FreqsQATrunc}}
\label{FreqsQATrunc}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 A list of multiplicities of frequencies of monomials if the first argument of
the input is a list of homogeneous polynomials in NP format, and \texttt{false} otherwise. 



 The frequency of a monomial is the list of numbers of occurrences of a
variable in the monomial for each variable; the multiplicity of a frequency is
the number of monomials in the standard basis for a quotient algebra with this
frequency. When invoked with a list \mbox{\texttt{\slshape Lnp}} of polynomials in NP format representing a (truncated) Gr{\"o}bner basis, a
natural number \mbox{\texttt{\slshape deg}}, and a weight vector \mbox{\texttt{\slshape wtv}} of length the number of variables and with positive integers for entries, such
that the polynomials of \mbox{\texttt{\slshape Lnp}} are homogeneous with respect to \mbox{\texttt{\slshape wtv}}, it returns a list of frequencies occurring with their multiplicities for the
quotient algebra of the free noncommutative algebra by the ideal generated by \mbox{\texttt{\slshape Lnp}} truncated above \mbox{\texttt{\slshape deg}}. The $i$-th entry of the list gives the frequencies of the weight $(i-1)$ basis monomials of the quotient algebra. If the list of polynomials \mbox{\texttt{\slshape Lnp}} is not homogeneous with respect to \mbox{\texttt{\slshape wtv}}, it returns \texttt{false}. 

 \emph{Example:} Consider the truncated Gr{\"o}bner basis of the following two polynomials in
NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,2,2,1],[2,1,1,2]],[1,-1]];;
  gap> p2 := [[[2,2,2],[1,1]],[1,-1]];;
  gap> wtv := [3,2];;
  gap> GB := SGrobnerTrunc([p1,p2],12,wtv);;
  gap> PrintNPList(GB);
   ba^2 - a^2b 
   b^3 - a^2 
   ab^2a - a^2b^2 
\end{Verbatim}
 The multiplicities of the frequencies of of monomials in a standard basis of
the quotient algebra with respect to the ideal generated by \texttt{GB} is found as follows, for weights up to and including 8. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> F := FreqsQATrunc(GB,8,wtv);
  [ [ [ [  ], 1 ] ], [ [ [ 0, 1 ], 1 ] ], [ [ [ 1, 0 ], 1 ] ], 
    [ [ [ 0, 2 ], 1 ] ], [ [ [ 1, 1 ], 2 ] ], 
    [ [ [ 2, 0 ], 1 ], [ [ 0, 3 ], 1 ] ], [ [ [ 1, 2 ], 3 ] ], 
    [ [ [ 2, 1 ], 2 ], [ [ 0, 4 ], 1 ] ] ]
\end{Verbatim}
 The interpretation of this data is given by the following lines of code. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> for f in F do
  >   if f[1][1] <> [] then
  >     Print("At level ", wtv * (f[1][1]), " the multiplicities are\n");
  >     for x in f do
  >       Print("  for ",x[1],": ",x[2],"\n");
  >     od;
  >   else
  >     Print("At level ", 0 , " the multiplicity of [] is ",f[1][2],"\n");
  >   fi;
  >   Print("\n");
  > od;
  At level 0 the multiplicity of [] is 1
  
  At level 2 the multiplicities are
    for [ 0, 1 ]: 1
  
  At level 3 the multiplicities are
    for [ 1, 0 ]: 1
  
  At level 4 the multiplicities are
    for [ 0, 2 ]: 1
  
  At level 5 the multiplicities are
    for [ 1, 1 ]: 2
  
  At level 6 the multiplicities are
    for [ 2, 0 ]: 1
    for [ 0, 3 ]: 1
  
  At level 7 the multiplicities are
    for [ 1, 2 ]: 3
  
  At level 8 the multiplicities are
    for [ 2, 1 ]: 2
    for [ 0, 4 ]: 1
  
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{Functions of the module variant}}\label{NPMs}
\logpage{[ 3, 9, 0 ]}
\hyperdef{L}{X8706DD3287E82019}{}
{
 

\subsection{\textcolor{Chapter }{SGrobnerModule}}
\logpage{[ 3, 9, 1 ]}\nobreak
\hyperdef{L}{X860966487ED88A43}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{SGrobnerModule({\slshape Lnpm, Lnp})\index{SGrobnerModule@\texttt{SGrobnerModule}}
\label{SGrobnerModule}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 A record \texttt{GBR} containing a Gr{\"o}bner basis (if found...the general problem is unsolvable)
for modules; \texttt{GBR.p} will contain the prefix rules and \texttt{GBR.ts} will contain the two-sided rules, and \texttt{GBR.pg} will be the smallest rank of the free module to which all prefix relations
belong 



 For a list \mbox{\texttt{\slshape Lnpm}} of vectors in NPM format (see Section \ref{NP}), and a list \mbox{\texttt{\slshape Lnp}} of polynomials in NP format, this function will use Buchberger's algorithm
with strong normal form applied to the union of \mbox{\texttt{\slshape Lnpm}}, \mbox{\texttt{\slshape Lnp}}, the set of polynomials $x*e-x$ and $x*m[i]$ for $x$ a standard indeterminate, a module generator $m[j]$ or the dummy indeterminate $e$, and the set of all $e*x -x$ for $x$ a standard indeterminate, to find a Gr{\"o}bner Basis record \texttt{GBR} (if possible; the general problem is unsolvable). This record will have a
Gr{\"o}bner Basis \texttt{GBR.ts} for the two-sided ideal generated by \mbox{\texttt{\slshape Lnp}} and an intersection with the module \texttt{GBR.p} representing the module relations needed to find representative vectors in the
module uniquely by means of a strong normal form computation modding out \texttt{GBR.p} and, for the scalars, \texttt{GBR.ts}. 

 \emph{Example:} Consider the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-2]];;
  gap> p2 := [[[1,2,2],[]],[1,-3]];;
\end{Verbatim}
 Consider also the following two vectors in NPM format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> v1 := [[[-1,1,2],[-1]],[1,-1]];;
  gap> v2 := [[[-2,2,2],[-2]],[1,-2]];;
\end{Verbatim}
 The Gr{\"o}bner basis record for this data is found by \texttt{SGrobnerModule}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBR := SGrobnerModule([v1,v2],[p1,p2]);;
\end{Verbatim}
 The record \texttt{GBR} has two fields, \texttt{p} for prefix relations (vectors in the module) and \texttt{ts} for two-sided relations (polynomials in the algebra): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(GBR.p);
  [ 0, 1 ]
  [ 1 , 0]
  gap> PrintNPList(GBR.ts);
   b - 3/2a 
   a^3 - 4/3 
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{BaseQM}}
\logpage{[ 3, 9, 2 ]}\nobreak
\hyperdef{L}{X7E3160E67C504F37}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{BaseQM({\slshape GBR, t, mt, maxno})\index{BaseQM@\texttt{BaseQM}}
\label{BaseQM}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A basis of the module obtained from the free module of rank \mbox{\texttt{\slshape mt}} over the free algebra on \mbox{\texttt{\slshape t}} generators by factoring out the submodule generated by the elements of \mbox{\texttt{\slshape GBR}} 



 When called with a Gr{\"o}bner basis record \mbox{\texttt{\slshape GBR}} (see Section \ref{GBR}), the number of variables \mbox{\texttt{\slshape t}}, the number of module generators \mbox{\texttt{\slshape mt}}, and a maximum number of terms to be found, \mbox{\texttt{\slshape maxno}}, the function \texttt{BaseQM} will return a (partial) base of the quotient module of $A^{mt}$ over the free algebra on $A$ on \texttt{t} generators by the right sub $A$-module generated by the elements of \mbox{\texttt{\slshape GBR}}. Note that the record \mbox{\texttt{\slshape GBR}} consists of two fields: the list \mbox{\texttt{\slshape GBR.p}} of vectors in NPM format representing elements of the free module $A^{mt}$, and the list \mbox{\texttt{\slshape GBR.ts}} of polynomials in NP format representing elements of $A$. The submodule generated by \mbox{\texttt{\slshape GBR}} is considered to be the right submodule of $A^{mt}$ generated by \mbox{\texttt{\slshape GBR.p}} and all elements of the form $v\cdot np$ with $np$ in the two-sided ideal of $A$ generated by \mbox{\texttt{\slshape GBR.ts}} and $v$ in $A^{mt}$. If this function is invoked with \mbox{\texttt{\slshape maxno}} equal to 0, then a full basis will be given. 

 If \mbox{\texttt{\slshape t}}$=0$, then \texttt{t} will be set to the minimal value such that all polynomials of \mbox{\texttt{\slshape GBR.ts}} and all polynomials occurring in \mbox{\texttt{\slshape GBR.p}} have at most \texttt{t} variables. 

 If \mbox{\texttt{\slshape mt}}$=0$, then \texttt{mt} will be set to the minimal value such that all vectors of \mbox{\texttt{\slshape GBR.p}} belong to $A^{mt}$. 

 If the module is cyclic (that is, has a single generator), it is possible to
use the Gr{\"o}bner basis of the ideal in the algebra instead of the
Gr{\"o}bner basis record. This can be done by entering 0 for the number \mbox{\texttt{\slshape mt}} of module generators. 

 \emph{Example:} Consider the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,1,2],[]],[1,-1]];;
  gap> p2 := [[[2,2,2,1],[]],[1,-1]];;
\end{Verbatim}
 Consider also the following two vectors in NPM format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> v1 := [[[-1,1,2],[-1]],[1,-1]];;
  gap> v2 := [[[-2,2,2],[-2]],[1,-2]];;
\end{Verbatim}
 The Gr{\"o}bner basis record for this data is found by \texttt{SGrobnerModule} (\ref{SGrobnerModule}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBR := SGrobnerModule([v1,v2],[p1,p2]);;
  gap> PrintNPList(GBR.ts);
   ba - ab 
   b^2 - a^2 
   a^3b - 1 
   a^5 - b 
  gap> PrintNPList(GBR.p);
  [ 0, 1 ]
  [ b - a , 0]
  [ a^2 - 1 , 0]
  [ ab - 1 , 0]
\end{Verbatim}
 The function \texttt{BaseQM} computes a basis. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> B := BaseQM(GBR,2,2,0);;
  gap> PrintNPList(B);
  [ 1 , 0]
  [ a , 0]
\end{Verbatim}
 The function \texttt{BaseQM} with arguments so as to let the number of dimensions of the module and the
number of variables be chosen minimal. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> B := BaseQM(GBR,0,0,0);;
  gap> PrintNPList(B);
  [ 1 , 0]
  [ a , 0]
\end{Verbatim}
 The function \texttt{BaseQM} can also be used to ompute the first three elements of a basis. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> B := BaseQM(GBR,2,2,3);;
  gap> PrintNPList(B);
  [ 1 , 0]
  [ a , 0]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{DimQM}}
\logpage{[ 3, 9, 3 ]}\nobreak
\hyperdef{L}{X813E6A2C8709C9F3}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{DimQM({\slshape GBR, t, mt})\index{DimQM@\texttt{DimQM}}
\label{DimQM}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
The dimension of the quotient module 



 When called with a Gr{\"o}bner basis record \mbox{\texttt{\slshape GBR}} (see Section \ref{GBR}), a number of variables \mbox{\texttt{\slshape t}} at least equal to the number of generators involved in the polynomials of \mbox{\texttt{\slshape GBR.p}} and \mbox{\texttt{\slshape GBR.ts}}, and a number of generators \mbox{\texttt{\slshape mt}} of a free module containing the prefix relations in \mbox{\texttt{\slshape GBR.p}}, the function \texttt{DimQM} will return the dimension over the coefficient field of the quotient module of
the free right module $A^{mt}$ of rank \mbox{\texttt{\slshape mt}} over the free algebra $A$ on \texttt{t} generators by the right sub $A$-module generated by the elements of \mbox{\texttt{\slshape GBR}}, if this dimension is finite. Otherwise, the computation invoked by the
function will not terminate. 

 If \mbox{\texttt{\slshape t}}$=0$, then \texttt{t} will be set to the minimal value such that all polynomials of \mbox{\texttt{\slshape GBR.ts}} and all polynomials occurring in \mbox{\texttt{\slshape GBR.p}} belong to $A^{mt}$. 

 If \mbox{\texttt{\slshape mt}}$=0$, then \texttt{mt} will be set to the minimal value such that all vectors of \mbox{\texttt{\slshape GBR.p}} belong to $A^{mt}$. \emph{Example:} Consider the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,1,2],[]],[1,-1]];;
  gap> p2 := [[[2,2,2,1],[]],[1,-1]];;
\end{Verbatim}
 Consider also the following two vectors in NPM format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> v1 := [[[-1,1,2],[-2]],[1,-1]];;
  gap> v2 := [[[-2,2,2],[-1]],[1,-2]];;
\end{Verbatim}
 The Gr{\"o}bner basis record for this data is found by \texttt{SGrobnerModule} (\ref{SGrobnerModule}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBR := SGrobnerModule([v1,v2],[p1,p2]);;
\end{Verbatim}
 The function \texttt{DimQM} computes the dimension over the rationals of the quotient of the free module
over the free algebra on two generators by the submodule generated by the
vectors \texttt{v1}, \texttt{v2}, $[p,q]$, where $p$ and $q$ run over all elements of the two-sided ideal in the free algebra generated by \texttt{p1} and \texttt{p2}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> SetInfoLevel(InfoGBNP,2);
  gap> DimQM(GBR,2,2);
  0
\end{Verbatim}
 The answer should be equal to the size of \texttt{BaseQM(GBR,t,mt,0)}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> DimQM(GBR,2,2) = Length(BaseQM(GBR,2,2,0));
  true
  gap> SetInfoLevel(InfoGBNP,0);
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{MulQM}}
\logpage{[ 3, 9, 4 ]}\nobreak
\hyperdef{L}{X805FB42A7EEF510F}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{MulQM({\slshape p1, p2, GBR})\index{MulQM@\texttt{MulQM}}
\label{MulQM}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
The strong normal form of the product \mbox{\texttt{\slshape p1}}$*$\mbox{\texttt{\slshape p2}} with respect to \mbox{\texttt{\slshape GBR}} 



 When called with three arguments, the first of which, \mbox{\texttt{\slshape p1}}, is a module element in NPM format, the second of which, \mbox{\texttt{\slshape p2}}, is a polynomial in NP format representing an element of the quotient
algebra, and the third of which is a Gr{\"o}bner basis record \mbox{\texttt{\slshape GBR}}, this function will return the product \texttt{p1*p2} in the module. 

 \emph{Example:} Consider the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[1,2,2],[]],[1,-1]];;
  gap> PrintNPList([p1,p2]);
   a^2b - 1 
   ab^2 - 1 
\end{Verbatim}
 Consider also the following two vectors in NPM format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> v1 := [[[-1,1,2],[-1]],[1,-1]];;
  gap> v2 := [[[-2,2,2],[-2]],[1,-2]];;
  gap> PrintNPList([v1,v2]);
  [ ab - 1 , 0]
  [ 0, b^2 - 2 ]
\end{Verbatim}
 The Gr{\"o}bner basis record for this data is found by \texttt{SGrobnerModule} (\ref{SGrobnerModule}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBR := SGrobnerModule([v1,v2],[p1,p2]);;
  gap> PrintNPList(GBR.ts);
   b - a 
   a^3 - 1 
  gap> PrintNPList(GBR.p);
  [ 0, 1 ]
  [ a - 1 , 0]
\end{Verbatim}
 The function \texttt{MulQM} computes the product of the vector \texttt{w} with the polynomial \texttt{q}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> w := [[[-1,2],[-2,1]],[1,-4]];;
  gap> PrintNP(w);
  [ b , - 4a ]
  gap> q := [[[2,2,1],[1]],[2,3]];;
  gap> PrintNP(q);
   2b^2a + 3a 
  gap> wq := MulQM(w,q,GBR);;
  gap> PrintNP(wq);
  [ 5 , 0]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{StrongNormalFormNPM}}
\logpage{[ 3, 9, 5 ]}\nobreak
\hyperdef{L}{X87D51A8379C50A80}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{StrongNormalFormNPM({\slshape f, GBR})\index{StrongNormalFormNPM@\texttt{StrongNormalFormNPM}}
\label{StrongNormalFormNPM}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 The strong normal form of a polynomial in NP format with respect to \mbox{\texttt{\slshape GBR}} 



 When invoked with a polynomial in NP format (see Section \ref{NP}) and a Gr{\"o}bner basis record \mbox{\texttt{\slshape GBR}} (see Section \ref{GBR}), this function will return the strong normal form (the polynomial reduced by
the prefix and two-sided relations of the Gr{\"o}bner basis combination). 

 This function assumes that \mbox{\texttt{\slshape GBR.p}} and \mbox{\texttt{\slshape GBR.ts}} are ordered (with the ordering \texttt{LtNP} (\ref{LtNP})), that the polynomials in \mbox{\texttt{\slshape GBR.ts}} are monic and clean (see \texttt{MkMonicNP} (\ref{MkMonicNP}) and \texttt{CleanNP} (\ref{CleanNP})), and that the polynomial \mbox{\texttt{\slshape f}} is clean. Note that a Gr{\"o}bner basis record as returned by a function like \texttt{SGrobnerModule} (\ref{SGrobnerModule}) is in the required form. 

 \emph{Example:} Consider the following two polynomials in NP format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[1,1,2],[]],[1,-1]];;
  gap> p2 := [[[1,2,2],[]],[1,-1]];;
  gap> PrintNPList([p1,p2]);
   a^2b - 1 
   ab^2 - 1 
\end{Verbatim}
 Consider also the following two vectors in NPM format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> v1 := [[[-1,1,2],[-1]],[1,-1]];;
  gap> v2 := [[[-2,2,2],[-2]],[1,-2]];;
  gap> PrintNPList([v1,v2]);
  [ ab - 1 , 0]
  [ 0, b^2 - 2 ]
\end{Verbatim}
 The Gr{\"o}bner basis record for this data is found by \texttt{SGrobnerModule} (\ref{SGrobnerModule}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBR := SGrobnerModule([v1,v2],[p1,p2]);;
  gap> PrintNPList(GBR.ts);
   b - a 
   a^3 - 1 
  gap> PrintNPList(GBR.p);
  [ 0, 1 ]
  [ a - 1 , 0]
\end{Verbatim}
 The vector \texttt{w} is brought into strong normal form with respect to \texttt{GBR}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> w := [[[-1,2],[-2,1]],[1,-4]];;
  gap> PrintNP(w);
  [ b , - 4a ]
  gap> v := StrongNormalFormNPM(w,GBR);;
  gap> PrintNP(v);
  [ 1 , 0]
\end{Verbatim}
 }

 }

 }

 
\chapter{\textcolor{Chapter }{Info Level}}\label{Info}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X79C5DF3782576D98}{}
{
 
\section{\textcolor{Chapter }{Introduction}}\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
 Many functions of the GBNP package can produce additional output. Such output
might be useful for long calculations, to see where the calculation is or to
gain more information about the calculation itself. 

 \textsf{GAP} provides the tools to be able to tune the output of the functions. All of the
functions of this package use the \texttt{InfoClass} \texttt{InfoGBNP} (\ref{InfoGBNP}) and some use the \texttt{InfoClass} \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}). As usual with GAP when this is left at 0, the functions will hardly print
additional information. It can be set to 1 or 2 with \texttt{SetInfoLevel} (more about this function can be found at  \textbf{Reference: SetInfoLevel}). A brief explanation about each infolevel will be given in the next
sections. }

 
\section{\textcolor{Chapter }{InfoGBNP}}\logpage{[ 4, 2, 0 ]}
\hyperdef{L}{X82D40B0E84383BBC}{}
{
 

\subsection{\textcolor{Chapter }{InfoGBNP}}
\logpage{[ 4, 2, 1 ]}\nobreak
\hyperdef{L}{X82D40B0E84383BBC}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{InfoGBNP\index{InfoGBNP@\texttt{InfoGBNP}}
\label{InfoGBNP}
}\hfill{\scriptsize (info class)}}\\


 The \texttt{InfoClass} for this package is used in almost all functions. To change this level to 1
(some information) or 2 (more information, also information from calculation
loops) use the function \texttt{SetInfoLevel}. }

 
\subsection{\textcolor{Chapter }{What will be printed at level 0}}\logpage{[ 4, 2, 2 ]}
\hyperdef{L}{X8222A2F67E4CC62B}{}
{
 At level 0 no information is printed beyond what functions themselves command
to be printed. These include functions like \texttt{PrintNP} (\ref{PrintNP}), \texttt{PrintNPList} (\ref{PrintNPList}), \texttt{PrintTraceList} (\ref{PrintTraceList}) and \texttt{PrintNPListTrace} (\ref{PrintNPListTrace}), but it also includes the function \texttt{DetermineGrowthQA} (\ref{DetermineGrowthQA}), which only prints one or two lines and \texttt{DimsQATrunc} (\ref{DimsQATrunc}) which produces information about a truncated Gr{\"o}bner basis. }

 
\subsection{\textcolor{Chapter }{What will be printed at level 1}}\logpage{[ 4, 2, 3 ]}
\hyperdef{L}{X8552D1FF7EA2B8A6}{}
{
 The infolevel can be set to 1 with the following command: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  SetInfoLevel(InfoGBNP,1);
\end{Verbatim}
 At level 1 a large set of functions will produce a bit of output. Most of this
information reports on the phase of the algorithm the calculations are in or
some simple statistics about the input or output. }

 
\subsection{\textcolor{Chapter }{What will be printed at level 2}}\logpage{[ 4, 2, 4 ]}
\hyperdef{L}{X7CC244E47F903B31}{}
{
 The infolevel can be set to 2 with the following command. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  SetInfoLevel(InfoGBNP,2);
\end{Verbatim}
 At level 2 a large set of functions will produce a lot of output. This mostly
concerns information on loops in the calculations. Timing information will be
printed as well. }

  }

 
\section{\textcolor{Chapter }{InfoGBNPTime}}\logpage{[ 4, 3, 0 ]}
\hyperdef{L}{X7FAE244E80397B9A}{}
{
 

\subsection{\textcolor{Chapter }{InfoGBNPTime}}
\logpage{[ 4, 3, 1 ]}\nobreak
\hyperdef{L}{X7FAE244E80397B9A}{}
{\noindent\textcolor{FuncColor}{$\Diamond$\ \texttt{InfoGBNPTime\index{InfoGBNPTime@\texttt{InfoGBNPTime}}
\label{InfoGBNPTime}
}\hfill{\scriptsize (info class)}}\\


 The \texttt{InfoClass} for timing is used in producing information about the runtime of the algorithm
in certain possibly lengthy calculations. 

 To change this level to 1 (Gr{\"o}bner functions give information) or 2 (more
information, also information from other functions, which might not always
take a long time and from inside loops) use the function \texttt{SetInfoLevel}. }

 
\subsection{\textcolor{Chapter }{What will be printed at level 0}}\logpage{[ 4, 3, 2 ]}
\hyperdef{L}{X8222A2F67E4CC62B}{}
{
 No timing information will be printed at level 0. This can be desirable for
small examples or when producing test output, for use with \texttt{ReadTest}. }

 
\subsection{\textcolor{Chapter }{What will be printed at level 1}}\logpage{[ 4, 3, 3 ]}
\hyperdef{L}{X8552D1FF7EA2B8A6}{}
{
 The infolevel can be set to 1 with the following command: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 At level one there will be time information printed by the functions from
different variants of the Gr{\"o}bner basis algorithm: \texttt{Grobner} (\ref{Grobner}), \texttt{SGrobner} (\ref{SGrobner}), \texttt{SGrobnerTrace} (\ref{SGrobnerTrace}), and \texttt{SGrobnerTrunc} (\ref{SGrobnerTrunc}). }

 
\subsection{\textcolor{Chapter }{What will be printed at level 2}}\logpage{[ 4, 3, 4 ]}
\hyperdef{L}{X7CC244E47F903B31}{}
{
 The infolevel can be set to 2 with the following command: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  SetInfoLevel(InfoGBNPTime,2);
\end{Verbatim}
 At level two there will also be some information printed from a loop from
within \texttt{SGrobnerTrunc} (\ref{SGrobnerTrunc}).  }

  }

 }

 

\appendix


\chapter{\textcolor{Chapter }{Examples}}\label{Examples}
\logpage{[ "A", 0, 0 ]}
\hyperdef{L}{X7A489A5D79DA9E5C}{}
{
 
\section{\textcolor{Chapter }{Introduction}}\label{ExamplesIntroduction}
\logpage{[ "A", 1, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
 In this chapter all available commented examples can be found. Those without
comments are in the directory \texttt{gbnp/examples}. Timing results are obtained on an Intel Pentium 4 3.00GHz processor running
Linux (2.6.28-15-generic \#49-Ubuntu SMP Tue Aug 18 18:40:08 UTC 2009 i686
GNU/Linux) and using GAP 4.4.10. 
\begin{itemize}
\item \ref{Example01} `A simple commutative Gr{\"o}bner basis computation'
\item \ref{Example02} `A truncated Gr{\"o}bner basis for Leonard pairs'
\item \ref{Example11} `The truncated variant on two weighted homogeneous polynomials'
\item \ref{Example03} `The order of the Weyl group of type E$_6$'
\item \ref{Example05} `The gcd of some univariate polynomials'
\item \ref{Example06} `From the Tapas book'
\item \ref{Example07} `The Birman-Murakami-Wenzl algebra of type A$_3$'
\item \ref{Example08} `The Birman-Murakami-Wenzl algebra of type A$_2$'
\item \ref{Example10} `A commutative example by Mora'
\item \ref{Example09} `Tracing an example by Mora'
\item \ref{Example13} `Finiteness of the Weyl group of type E$_6$' 

 This extends Example \ref{Example03}. 
\item \ref{Example14} `Preprocessing for Weyl group computations' 

 This extends two earlier examples \ref{Example03} and \ref{Example13}. 
\item \ref{Example15} `A quotient algebra with exponential growth'
\item \ref{Example16} `A commutative quotient algebra of polynomial growth' 

 This extends Example \ref{Example06}. 
\item \ref{Example17} `An algebra over a finite field'
\item \ref{Example18} `The dihedral group of order 8'  
\item \ref{Example19} `The dihedral group of order 8 on another module'  

 This extends Example \ref{Example18}. 
\item \ref{Example20} `The dihedral group on a non-cyclic module' 

 This example also extends Example \ref{Example18}. 
\item \ref{Example04} `The icosahedral group'
\item \ref{Example21} `The symmetric inverse monoid for a set of size four'
\item \ref{Example22} `A module of the Hecke algebra of type A$_3$ over GF(3)'  
\item \ref{Example23} `Generalized Temperley-Lieb algebras'
\item \ref{Example12} `The universal enveloping algebra of a Lie algebra'
\item \ref{Example24} `Serre's exercise'
\item \ref{Example25} `Baur and Draisma's transformations'
\item \ref{ExampleColagen} `The cola gene puzzle'
\end{itemize}
 }

 
\section{\textcolor{Chapter }{A simple commutative Gr{\"o}bner basis computation}}\label{Example01}
\logpage{[ "A", 2, 0 ]}
\hyperdef{L}{X784586E47E2739E3}{}
{
  In this commutative example the relations are $x^2y-1$ and $xy^2-1$; we add $xy-yx$ to enforce that $x$ and $y$ commute. The answer should be $\{x^3-1, x-y, xy-yx\}$, as the reduction ordering is total degree first and then lexicographic with $ x $ smaller than $y$. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 2 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 1 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,2);
  gap> SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 Then input the relations in NP format (see Section \ref{NP}). They will be put in the list \texttt{Lnp}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> Lnp := [ [[[1,2],[2,1]],[1,-1]]   ];
  [ [ [ [ 1, 2 ], [ 2, 1 ] ], [ 1, -1 ] ] ]
  gap> x2y := [[[1,1,2],[]],[1,-1]];
  [ [ [ 1, 1, 2 ], [  ] ], [ 1, -1 ] ]
  gap>     AddSet(Lnp,x2y);   
  gap> xy2 := [[[1,2,2],[]],[1,-1]];
  [ [ [ 1, 2, 2 ], [  ] ], [ 1, -1 ] ]
  gap>     AddSet(Lnp,xy2);
\end{Verbatim}
 The relations can be exhibited with \texttt{PrintNPList} (\ref{PrintNPList}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(Lnp);
   a^2b - 1 
   ab - ba 
   ab^2 - 1 
\end{Verbatim}
 Let the variables be printed as $x$ and $y$ instead of $a$ and $b$ by means of \texttt{GBNP.ConfigPrint} (\ref{GBNP.ConfigPrint}) 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBNP.ConfigPrint("x","y");
\end{Verbatim}
 The Gr{\"o}bner basis can now be calculated with \texttt{SGrobner} (\ref{SGrobner}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := SGrobner(Lnp);
  #I  number of entered polynomials is 3
  #I  number of polynomials after reduction is 3
  #I  End of phase I
  #I  End of phase II
  #I  length of G =1
  #I  length of todo is 1
  #I  length of G =2
  #I  length of todo is 0
  #I  List of todo lengths is [ 1, 1, 0 ]
  #I  End of phase III
  #I  G: Cleaning finished, 0 polynomials reduced
  #I  End of phase IV
  #I  The computation took 8 msecs.
  [ [ [ [ 2 ], [ 1 ] ], [ 1, -1 ] ], [ [ [ 1, 1, 1 ], [  ] ], [ 1, -1 ] ] ]
\end{Verbatim}
 When printed, it looks like: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(GB);
   y - x 
   x^3 - 1 
\end{Verbatim}
 The dimension of the quotient algebra can be calculated with \texttt{DimQA} (\ref{DimQA}). The arguments are the Gr{\"o}bner basis \texttt{GB} and the number of variables is \texttt{2}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> DimQA(GB,2);
  3
\end{Verbatim}
 A basis of this quotient algebra can be calculated with \texttt{BaseQA} (\ref{BaseQA}). The arguments are a Gr{\"o}bner basis \texttt{GB}, the number of variables \mbox{\texttt{\slshape t}} ($=2$) and a variable \mbox{\texttt{\slshape maxno}} for returning partial quotient algebras (0 means full basis). The calculated
basis will be printed as well. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> B:=BaseQA(GB,2,0);;
  gap> PrintNPList(B);
   1 
   x 
   x^2 
\end{Verbatim}
 The strong normal form of the element $xyxyxyx$ can be found by use of \texttt{StrongNormalFormNP} (\ref{StrongNormalFormNP}). The arguments are this element and the Gr{\"o}bner basis \texttt{GB}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> f:=[[[1,2,1,2,1,2,1]],[1]];;
  gap> PrintNP(f);
   xyxyxyx 
  gap> p:=StrongNormalFormNP(f,GB);;
  gap> PrintNP(p);
   x 
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{A truncated Gr{\"o}bner basis for Leonard pairs}}\label{Example02}
\logpage{[ "A", 3, 0 ]}
\hyperdef{L}{X7E1B57AA85C2BA70}{}
{
 To provide Terwilliger with experimental dimension information in low degrees
for his theory of Leonard pairs a truncated Gr{\"o}bner basis computation was
carried out as follows. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 1 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 2 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,1);
  gap> SetInfoLevel(InfoGBNPTime,2);
\end{Verbatim}
 We truncate the example by putting all monomials of degree $n$ in the ideal by means of the function \texttt{MkTrLst} to be introduced below; a better way to compute the result is by means of the
truncated GB algorithms (See \ref{Example12}). 

 We want to truncate at degree 7 so we have fixed $n = 8$. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> n := 8;;
\end{Verbatim}
 Now enter the relations in NP form (see \ref{NP}). The function \texttt{MkTrLst} will be introduced, which will return all monomials of degree \texttt{n}. The list of ideal generators of interest is called \texttt{I}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> sqbr := function(n,q) ; return (q^3-q^-3)/(q-q^(-1)); end;;
  
  gap> c := sqbr(3,5);
  651/25
  
  gap> s1 :=[[[1,1,1,2],[1,1,2,1],[1,2,1,1],[2,1,1,1]],[1,-c,c,-1]];;
  gap> s2 :=[[[2,2,2,1],[2,2,1,2],[2,1,2,2],[1,2,2,2]],[1,-c,c,-1]];;
  
  gap> MkTrLst := function(l) local ans, h1, h2, a, i;
  >    ans := [[1],[2]];
  >    for i in [2..l] do
  >       h1 := [];
  >       h2 := [];
  >       for a in ans do
  >         Add(h1,Concatenation([1],a));
  >         Add(h2,Concatenation([2],a));
  >       od;
  >       ans := Concatenation(h1,h2);
  >    od;
  >    return List(ans, a -> [[a],[1]]);
  > end;;
  
  gap> I := Concatenation([s1,s2],MkTrLst(n));;
\end{Verbatim}
 To give an impression, we print the first 20 entries of this list: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(I{[1..20]});
   a^3b - 651/25a^2ba + 651/25aba^2 - ba^3 
   b^3a - 651/25b^2ab + 651/25bab^2 - ab^3 
   a^8 
   a^7b 
   a^6ba 
   a^6b^2 
   a^5ba^2 
   a^5bab 
   a^5b^2a 
   a^5b^3 
   a^4ba^3 
   a^4ba^2b 
   a^4baba 
   a^4bab^2 
   a^4b^2a^2 
   a^4b^2ab 
   a^4b^3a 
   a^4b^4 
   a^3ba^4 
   a^3ba^3b 
\end{Verbatim}
 We calculate the Gr{\"o}bner basis with \texttt{SGrobner} (\ref{SGrobner}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := SGrobner(I);;
  #I  number of entered polynomials is 258
  #I  number of polynomials after reduction is 114
  #I  End of phase I
  #I  End of phase II
  #I  End of phase III
  #I  Time needed to clean G :0
  #I  End of phase IV
  #I  The computation took 232 msecs.
\end{Verbatim}
 Now print the first part of the Gr{\"o}bner basis with \texttt{PrintNPList} (\ref{PrintNPList}) (only the first 20 polynomials are printed here, the full Gr{\"o}bner basis
can be printed with \texttt{PrintNPList(GB)}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(GB{[1..20]});
   ba^3 - 651/25aba^2 + 651/25a^2ba - a^3b 
   b^3a - 651/25b^2ab + 651/25bab^2 - ab^3 
   b^2a^2ba - bab^2a^2 - baba^2b + ba^2bab + ab^2aba - abab^2a - aba^2b^2 + a^2b\
  ^2ab 
   b^2ab^2a^2 - 651/25b^2ababa + b^2aba^2b + 626/25bab^2aba - bab^2a^2b + babab^\
  2a - ba^2b^2ab + ba^2bab^2 - 651/25ab^2ab^2a + ab^2abab + 423176/625abab^2ab -\
   423801/625ababab^2 + 626/25aba^2b^3 - 406901/625a^2b^2ab^2 + 423176/625a^2bab\
  ^3 - 651/25a^3b^4 
   a^8 
   a^7b 
   a^6ba 
   a^6b^2 
   a^5ba^2 
   a^5bab 
   a^5b^2a 
   a^5b^3 
   a^4ba^2b 
   a^4baba 
   a^4bab^2 
   a^4b^2a^2 
   a^4b^2ab 
   a^4b^4 
   a^3ba^2ba 
   a^3ba^2b^2 
\end{Verbatim}
 The truncated quotient algebra is obtained by factoring out the ideal
generated by the Gr{\"o}bner basis \texttt{GB} and so its dimension can be calculated with \texttt{DimQA} (\ref{DimQA}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> DimQA(GB,2);
  #I  The computation took 0 msecs.
  157
\end{Verbatim}
 Here is what Paul Terwilliger wrote in reaction to the computation carried out
by this example:  

 I just wanted to thank you again for the dimension data that you gave me after
the Durham meeting. It ended up having a large impact. See the attached paper;
joint with Tatsuro Ito.

 I spent several weeks in Japan this past January, working with Tatsuro and
trying to find a good basis for the algebra on two symbols subject to the $q$-Serre relations. After much frustration, we thought of feeding your data into
Sloane's online handbook of integer sequences. We did it out of curiosity more
than anything; we did not expect the handbook data to be particularly useful.
But it was.

 The handbook told us that the graded dimension generating function, using your
data for the coefficients, matched the $q$-series for the inverse of the Jacobi theta function $\vartheta_4$; armed with this overwhelming hint we were able to prove that the graded
dimension generating function was indeed given by the inverse of $\vartheta_4$. With that info we were able to get a nice result about td pairs.

 Paul

  }

 
\section{\textcolor{Chapter }{The truncated variant on two weighted homogeneous polynomials}}\label{Example11}
\logpage{[ "A", 4, 0 ]}
\hyperdef{L}{X79AC59C482A2E4C1}{}
{
 Here we exhibit a truncated non-commutative homogeneous weighted Gr{\"o}bner
basis computation. This example uses the functions from Section \ref{truncfun}, the truncation variants (see also Section \ref{trunc}). 

 The input is a set of polynomials in $x$ and $y$, which are homogeneous when the weight of $x$ is 2 and of $y$ is 3. The input is $\{x^3y^2-x^6+y^4,y^2x^3+xyxyx+x^2yxy\}$. We truncate the computation at degree 16. The truncated Gr{\"o}bner basis is $\{y^2x^3+xyxyx+x^2yxy,x^6-x^3y^2-y^4,x^3y^2x-x^4y^2-xy^4\}$ and the dimension of the quotient algebra is 134. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 1 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 1 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,1);
  gap> SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 The variables will be printed as $x$ and $y$. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBNP.ConfigPrint("x","y");
\end{Verbatim}
 The level to truncate at is assigned to $n$. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> n := 16;;
\end{Verbatim}
 Now enter the relations in NP form (see Section \ref{NP}) and the weights. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> s1 :=[[[1,1,1,2,2],[1,1,1,1,1,1],[2,2,2,2]],[1,-1,1]];;
  gap> s2 :=[[[2,2,1,1,1],[1,2,1,2,1],[1,1,2,1,2]],[1,1,1]];;
  gap> K := [s1,s2];;
  gap> weights:=[2,3];;
\end{Verbatim}
 The input can be printed with \texttt{PrintNPList} (\ref{PrintNPList}) 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(K);
   x^3y^2 - x^6 + y^4 
   y^2x^3 + xyxyx + x^2yxy 
\end{Verbatim}
 Verify whether the list \texttt{K} consists only of polynomials that are homogeneous with respect to \texttt{weights} by means of \texttt{CheckHomogeneousNPs} (\ref{CheckHomogeneousNPs}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> CheckHomogeneousNPs(K,weights);
  #I  Input is homogeneous
  [ 12, 12 ]
\end{Verbatim}
 Now calculate the truncated Gr{\"o}bner basis with \texttt{SGrobnerTrunc} (\ref{SGrobnerTrunc}). The output will only contain homogeneous polynomials of degree at most \texttt{n}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> G := SGrobnerTrunc(K,n,weights);;
  #I  number of entered polynomials is 2
  #I  number of polynomials after reduction is 2
  #I  End of phase I
  #I  Input is homogeneous
  #I  Reached level 16
  #I  end of the algorithm
  #I  The computation took 8 msecs.
\end{Verbatim}
 The Gr{\"o}bner basis of the truncated quotient algebra can be printed with \texttt{PrintNPList} (\ref{PrintNPList}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(G);
   y^2x^3 + xyxyx + x^2yxy 
   x^6 - x^3y^2 - y^4 
   x^3y^2x - x^4y^2 + y^4x - xy^4 
\end{Verbatim}
 The standard basis of the quotient of the free noncommutative algebra on $n$ variables, where $n$ is the length of the vector \texttt{weights}, by the homogeneous ideal generated by \texttt{K} up to degree $n$ is obtained by means of the function \texttt{BaseQATrunc} (\ref{BaseQATrunc}) applied to \texttt{K}, \texttt{n}, and \texttt{weights}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> B := BaseQATrunc(K,n,weights);;
  #I  number of entered polynomials is 2
  #I  number of polynomials after reduction is 2
  #I  End of phase I
  #I  Input is homogeneous
  #I  Reached level 16
  #I  end of the algorithm
  #I  The computation took 4 msecs.
  gap> i := Length(B);
  17
  gap> Print("at level ",i-1," the standard monomials are:\n");
  at level 16 the standard monomials are:
  gap> PrintNPList(List(B[i], qq -> [[qq],[1]]));
   yxyx^4 
   yx^2yx^3 
   xyxyx^3 
   yx^3yx^2 
   xyx^2yx^2 
   x^2yxyx^2 
   y^4x^2 
   yx^4yx 
   xyx^3yx 
   x^2yx^2yx 
   x^3yxyx 
   y^3xyx 
   y^2xy^2x 
   yxy^3x 
   xy^4x 
   yx^5y 
   xyx^4y 
   x^2yx^3y 
   x^3yx^2y 
   y^3x^2y 
   x^4yxy 
   y^2xyxy 
   yxy^2xy 
   xy^3xy 
   x^5y^2 
   y^2x^2y^2 
   yxyxy^2 
   xy^2xy^2 
   yx^2y^3 
   xyxy^3 
   x^2y^4 
\end{Verbatim}
 The same result can be obtained by using the truncated Gr{\"o}bner basis found
for \texttt{G} instead of \texttt{K}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> B2 := BaseQATrunc(G,n,weights);;
  #I  number of entered polynomials is 3
  #I  number of polynomials after reduction is 3
  #I  End of phase I
  #I  Input is homogeneous
  #I  Reached level 16
  #I  end of the algorithm
  #I  The computation took 4 msecs.
  gap> B = B2;
  true
\end{Verbatim}
 Also, the same result can be obtained by using the leading terms of the
truncated Gr{\"o}bner basis found for \texttt{G} instead of \texttt{K}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> B3 := BaseQATrunc(List( LMonsNP(G), qq -> [[qq],[1]]),n,weights);;
  #I  number of entered polynomials is 3
  #I  number of polynomials after reduction is 3
  #I  End of phase I
  #I  Input is homogeneous
  #I  Reached level 16
  #I  end of the algorithm
  #I  The computation took 0 msecs.
  gap> B = B3;
  true
\end{Verbatim}
 A list of dimensions of the homogeneous parts of the quotient algebra up to
degree $n$ is obtained by means of \texttt{DimsQATrunc} (\ref{DimsQATrunc}) with arguments \texttt{G}, \texttt{n}, and \texttt{weights}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> DimsQATrunc(G,n,weights);
  #I  number of entered polynomials is 3
  #I  number of polynomials after reduction is 3
  #I  End of phase I
  #I  Input is homogeneous
  #I  Reached level 16
  #I  end of the algorithm
  #I  The computation took 4 msecs.
  [ 1, 0, 1, 1, 1, 2, 2, 3, 4, 5, 7, 9, 10, 16, 17, 24, 31 ]
\end{Verbatim}
 Even more detailed information is given by the list of frequences up to degree \texttt{n}. This is obtained by means of \texttt{FreqsQATrunc} (\ref{FreqsQATrunc}) with arguments \texttt{G}, \texttt{n}, and \texttt{weights}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> FreqsQATrunc(G,n,weights);
  #I  number of entered polynomials is 3
  #I  number of polynomials after reduction is 3
  #I  End of phase I
  #I  Input is homogeneous
  #I  Reached level 16
  #I  end of the algorithm
  #I  The computation took 0 msecs.
  [ [ [ [  ], 1 ] ], [ [ [ 1, 0 ], 1 ] ], [ [ [ 0, 1 ], 1 ] ], 
    [ [ [ 2, 0 ], 1 ] ], [ [ [ 1, 1 ], 2 ] ], 
    [ [ [ 3, 0 ], 1 ], [ [ 0, 2 ], 1 ] ], [ [ [ 2, 1 ], 3 ] ], 
    [ [ [ 4, 0 ], 1 ], [ [ 1, 2 ], 3 ] ], [ [ [ 3, 1 ], 4 ], [ [ 0, 3 ], 1 ] ], 
    [ [ [ 5, 0 ], 1 ], [ [ 2, 2 ], 6 ] ], [ [ [ 4, 1 ], 5 ], [ [ 1, 3 ], 4 ] ], 
    [ [ [ 3, 2 ], 9 ], [ [ 0, 4 ], 1 ] ], [ [ [ 5, 1 ], 6 ], [ [ 2, 3 ], 10 ] ],
    [ [ [ 4, 2 ], 12 ], [ [ 1, 4 ], 5 ] ], 
    [ [ [ 6, 1 ], 5 ], [ [ 3, 3 ], 18 ], [ [ 0, 5 ], 1 ] ], 
    [ [ [ 5, 2 ], 16 ], [ [ 2, 4 ], 15 ] ] ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{The order of the Weyl group of type E$_6$}}\label{Example03}
\logpage{[ "A", 5, 0 ]}
\hyperdef{L}{X7C7742957CEC6E7B}{}
{
 In order to show how the order of a finite group of manageable size with a
manageable presentation can be computed, we determine the order of the Weyl
group of type E$_6$. This number is well known to be 51840. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 1 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 2 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,1);
  gap> SetInfoLevel(InfoGBNPTime,2);
\end{Verbatim}
 Then input the relations in NP format (see \ref{NP}). They come from the presentation of the Weyl group as a Coxeter group. This
means that there are six variables, one for each generator. We let the
corresponding variables be printed as $r_1$, ..., $r_6$ by means of \texttt{GBNP.ConfigPrint} (\ref{GBNP.ConfigPrint}) 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBNP.ConfigPrint(6,"r");
\end{Verbatim}
 The relations are binomial and represent the group relations, which express
that the generators are involutions (that is, have order 2) and that the
orders of the products of any two generators is specified by the Coxeter
diagram (see any book on Coxeter groups for details). The relations will be
assigned to \texttt{KI}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> k1 := [[[1,3,1],[3,1,3]],[1,-1]];;
  gap> k2 := [[[4,3,4],[3,4,3]],[1,-1]];;
  gap> k3 := [[[4,2,4],[2,4,2]],[1,-1]];;
  gap> k4 := [[[4,5,4],[5,4,5]],[1,-1]];;
  gap> k5 := [[[6,5,6],[5,6,5]],[1,-1]];;
  gap> k6 := [[[1,2],[2,1]],[1,-1]];;
  gap> k7 := [[[1,4],[4,1]],[1,-1]];;
  gap> k8 := [[[1,5],[5,1]],[1,-1]];;
  gap> k9 := [[[1,6],[6,1]],[1,-1]];;
  gap> k10 := [[[2,3],[3,2]],[1,-1]];;
  gap> k11 := [[[2,5],[5,2]],[1,-1]];;
  gap> k12 := [[[2,6],[6,2]],[1,-1]];;
  gap> k13 := [[[3,5],[5,3]],[1,-1]];;
  gap> k14 := [[[3,6],[6,3]],[1,-1]];;
  gap> k15 := [[[4,6],[6,4]],[1,-1]];;
  gap> k16 := [[[1,1],[]],[1,-1]];;
  gap> k17 := [[[2,2],[]],[1,-1]];;
  gap> k18 := [[[3,3],[]],[1,-1]];;
  gap> k19 := [[[4,4],[]],[1,-1]];;
  gap> k20 := [[[5,5],[]],[1,-1]];;
  gap> k21 := [[[6,6],[]],[1,-1]];;
  gap> KI := [k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,
  >        k11,k12,k13,k14,k15,k16,k17,k18,k19,k20,k21
  >       ];;
\end{Verbatim}
 The relations can be shown with \texttt{PrintNPList} (\ref{PrintNPList}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(KI);
   r.1r.3r.1 - r.3r.1r.3 
   r.4r.3r.4 - r.3r.4r.3 
   r.4r.2r.4 - r.2r.4r.2 
   r.4r.5r.4 - r.5r.4r.5 
   r.6r.5r.6 - r.5r.6r.5 
   r.1r.2 - r.2r.1 
   r.1r.4 - r.4r.1 
   r.1r.5 - r.5r.1 
   r.1r.6 - r.6r.1 
   r.2r.3 - r.3r.2 
   r.2r.5 - r.5r.2 
   r.2r.6 - r.6r.2 
   r.3r.5 - r.5r.3 
   r.3r.6 - r.6r.3 
   r.4r.6 - r.6r.4 
   r.1^2 - 1 
   r.2^2 - 1 
   r.3^2 - 1 
   r.4^2 - 1 
   r.5^2 - 1 
   r.6^2 - 1 
\end{Verbatim}
 The Gr{\"o}bner basis can now be calculated with \texttt{SGrobner} (\ref{SGrobner}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := SGrobner(KI);;
  #I  number of entered polynomials is 21
  #I  number of polynomials after reduction is 21
  #I  End of phase I
  #I  End of phase II
  #I  End of phase III
  #I  Time needed to clean G :0
  #I  End of phase IV
  #I  The computation took 220 msecs.
  gap> PrintNPList(GB);
   r.1^2 - 1 
   r.2r.1 - r.1r.2 
   r.2^2 - 1 
   r.3r.2 - r.2r.3 
   r.3^2 - 1 
   r.4r.1 - r.1r.4 
   r.4^2 - 1 
   r.5r.1 - r.1r.5 
   r.5r.2 - r.2r.5 
   r.5r.3 - r.3r.5 
   r.5^2 - 1 
   r.6r.1 - r.1r.6 
   r.6r.2 - r.2r.6 
   r.6r.3 - r.3r.6 
   r.6r.4 - r.4r.6 
   r.6^2 - 1 
   r.3r.1r.2 - r.2r.3r.1 
   r.3r.1r.3 - r.1r.3r.1 
   r.4r.2r.4 - r.2r.4r.2 
   r.4r.3r.4 - r.3r.4r.3 
   r.5r.4r.5 - r.4r.5r.4 
   r.6r.5r.6 - r.5r.6r.5 
   r.4r.3r.1r.4 - r.3r.4r.3r.1 
   r.5r.4r.2r.5 - r.4r.5r.4r.2 
   r.5r.4r.3r.5 - r.4r.5r.4r.3 
   r.6r.5r.4r.6 - r.5r.6r.5r.4 
   r.4r.2r.3r.4r.2 - r.3r.4r.2r.3r.4 
   r.4r.2r.3r.4r.3 - r.2r.4r.2r.3r.4 
   r.5r.4r.2r.3r.5 - r.4r.5r.4r.2r.3 
   r.5r.4r.3r.1r.5 - r.4r.5r.4r.3r.1 
   r.6r.5r.4r.2r.6 - r.5r.6r.5r.4r.2 
   r.6r.5r.4r.3r.6 - r.5r.6r.5r.4r.3 
   r.4r.2r.3r.1r.4r.2 - r.3r.4r.2r.3r.1r.4 
   r.5r.4r.2r.3r.1r.5 - r.4r.5r.4r.2r.3r.1 
   r.6r.5r.4r.2r.3r.6 - r.5r.6r.5r.4r.2r.3 
   r.6r.5r.4r.3r.1r.6 - r.5r.6r.5r.4r.3r.1 
   r.4r.2r.3r.1r.4r.3r.1 - r.2r.4r.2r.3r.1r.4r.3 
   r.5r.4r.2r.3r.4r.5r.4 - r.4r.5r.4r.2r.3r.4r.5 
   r.6r.5r.4r.2r.3r.1r.6 - r.5r.6r.5r.4r.2r.3r.1 
   r.6r.5r.4r.2r.3r.4r.6 - r.5r.6r.5r.4r.2r.3r.4 
   r.5r.4r.2r.3r.1r.4r.5r.4 - r.4r.5r.4r.2r.3r.1r.4r.5 
   r.6r.5r.4r.2r.3r.1r.4r.6 - r.5r.6r.5r.4r.2r.3r.1r.4 
   r.6r.5r.4r.2r.3r.1r.4r.3r.6 - r.5r.6r.5r.4r.2r.3r.1r.4r.3 
   r.6r.5r.4r.2r.3r.4r.5r.6r.5 - r.5r.6r.5r.4r.2r.3r.4r.5r.6 
   r.5r.4r.2r.3r.1r.4r.3r.5r.4r.3 - r.4r.5r.4r.2r.3r.1r.4r.3r.5r.4 
   r.6r.5r.4r.2r.3r.1r.4r.5r.6r.5 - r.5r.6r.5r.4r.2r.3r.1r.4r.5r.6 
   r.5r.4r.2r.3r.1r.4r.3r.5r.4r.2r.3 - r.4r.5r.4r.2r.3r.1r.4r.3r.5r.4r.2 
   r.6r.5r.4r.2r.3r.1r.4r.3r.5r.6r.5 - r.5r.6r.5r.4r.2r.3r.1r.4r.3r.5r.6 
   r.6r.5r.4r.2r.3r.1r.4r.3r.5r.4r.6r.5r.4 - r.5r.6r.5r.4r.2r.3r.1r.4r.3r.5r.4r.\
  6r.5 
   r.6r.5r.4r.2r.3r.1r.4r.3r.5r.4r.2r.6r.5r.4r.2 - r.5r.6r.5r.4r.2r.3r.1r.4r.3r.\
  5r.4r.2r.6r.5r.4 
\end{Verbatim}
 The base of the quotient algebra can be calculated with \texttt{BaseQA} (\ref{BaseQA}), which has as arguments a Gr{\"o}bner basis \texttt{GB}, a number of symbols \texttt{6} and a maximum terms to be found (here 0 is entered, for a full base) . Since
it is very long we will not print it here. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> B:=BaseQA(GB,6,0);;
\end{Verbatim}
 The dimension of the quotient algebra can be calculated with \texttt{DimQA} (\ref{DimQA}), the arguments are the Gr{\"o}bner basis \texttt{GB} and the number of symbols \texttt{6}. Since \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) is set to 2, we get timing information from \texttt{DimQA} (\ref{DimQA}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> DimQA(GB,6);
  #I  The computation took 280 msecs.
  51840
\end{Verbatim}
 Note that the calculation of the dimension takes almost as long as calculating
the base. Since we have already calculated a base \texttt{B} it is much more efficient to calculate the dimension with \texttt{Length}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> Length(B);
  51840
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{The gcd of some univariate polynomials}}\label{Example05}
\logpage{[ "A", 6, 0 ]}
\hyperdef{L}{X7E39C9738509A036}{}
{
 A list of univariate polynomials is generated. The result of the Gr{\"o}bner
basis computation on this list should be a single monic polynomial, their gcd. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 2 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 1 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,2);
  gap> SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 Let the single variable be printed as x by means of \texttt{GBNP.ConfigPrint} (\ref{GBNP.ConfigPrint}) 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBNP.ConfigPrint("x");
\end{Verbatim}
 Now input the relations in NP format (see \ref{NP}). They will be assigned to \texttt{KI}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p0 := [[[1,1,1],[1,1],[1],[]],[1,2,2,1]];;
  gap> p1 := [[[1,1,1,1],[1,1],[]],[1,1,1]];;
  gap> KI := [p0,p1];;
  
  gap> for i in [2..12] do 
  >     h := AddNP(AddNP(KI[i],KI[i-1],1,3), 
  >     	AddNP(BimulNP([1],KI[i],[]),KI[i-1],2,1),3,-5);
  >     Add(KI,h);
  > od;
\end{Verbatim}
 The relations can be shown with \texttt{PrintNPList} (\ref{PrintNPList}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(KI);
   x^3 + 2x^2 + 2x + 1 
   x^4 + x^2 + 1 
   - 10x^5 + 3x^4 - 6x^3 + 11x^2 - 2x + 7 
   100x^6 - 60x^5 + 73x^4 - 128x^3 + 57x^2 - 76x + 25 
   - 1000x^7 + 900x^6 - 950x^5 + 1511x^4 - 978x^3 + 975x^2 - 486x + 103 
   10000x^8 - 12000x^7 + 12600x^6 - 18200x^5 + 14605x^4 - 13196x^3 + 8013x^2 - 2\
  792x + 409 
   - 100000x^9 + 150000x^8 - 166000x^7 + 223400x^6 - 204450x^5 + 181819x^4 - 123\
  630x^3 + 55859x^2 - 14410x + 1639 
   1000000x^10 - 1800000x^9 + 2150000x^8 - 2780000x^7 + 2765100x^6 - 2504340x^5 \
  + 1840177x^4 - 982264x^3 + 343729x^2 - 70788x + 6553 
   - 10000000x^11 + 21000000x^10 - 27300000x^9 + 34850000x^8 - 36655000x^7 + 342\
  32300x^6 - 26732590x^5 + 16070447x^4 - 6878602x^3 + 1962503x^2 - 335534x + 262\
  15 
   100000000x^12 - 240000000x^11 + 340000000x^10 - 437600000x^9 + 479700000x^8 -\
   463408000x^7 + 381083200x^6 - 250919600x^5 + 124358069x^4 - 44189892x^3 + 106\
  17765x^2 - 1551904x + 104857 
   - 1000000000x^13 + 2700000000x^12 - 4160000000x^11 + 5480000000x^10 - 6219000\
  000x^9 + 6212580000x^8 - 5347676000x^7 + 3789374800x^6 - 2103269850x^5 + 87925\
  4915x^4 - 266261734x^3 + 55222347x^2 - 7046418x + 419431 
   10000000000x^14 - 30000000000x^13 + 50100000000x^12 - 68240000000x^11 + 79990\
  000000x^10 - 82533200000x^9 + 74033300000x^8 - 55790408000x^7 + 33925155700x^6\
   - 16106037100x^5 + 5797814361x^4 - 1527768240x^3 + 278602281x^2 - 31541180x +\
   1677721 
   - 100000000000x^15 + 330000000000x^14 - 595000000000x^13 + 843500000000x^12 -\
   1021260000000x^11 + 1087222000000x^10 - 1012808600000x^9 + 804854300000x^8 - \
  528013485000x^7 + 277993337300x^6 - 114709334310x^5 + 36188145143x^4 - 8434374\
  466x^3 + 1372108031x^2 - 139586422x + 6710887 
  gap> Length(KI);
  13
\end{Verbatim}
 The Gr{\"o}bner basis can now be calculated with \texttt{SGrobner} (\ref{SGrobner}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := SGrobner(KI);;
  #I  number of entered polynomials is 13
  #I  number of polynomials after reduction is 1
  #I  End of phase I
  #I  End of phase II
  #I  List of todo lengths is [ 0 ]
  #I  End of phase III
  #I  G: Cleaning finished, 0 polynomials reduced
  #I  End of phase IV
  #I  The computation took 8 msecs.
\end{Verbatim}
 Printed it looks like: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(GB);
   x^2 + x + 1 
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{From the Tapas book}}\label{Example06}
\logpage{[ "A", 7, 0 ]}
\hyperdef{L}{X7F5A6ABA85CDB6E2}{}
{
 This example is a standard commutative Gr{\"o}bner basis computation from the
book Some Tapas of Computer Algebra \cite{CohenCuypersSterk1999}, page 339. There are six variables, named $a$, ... , $f$ by default. We work over the rationals and study the ideal generated by the
twelve polynomials occurring on the middle of page 339 of the Tapas book in a
project by De Boer and Pellikaan on the ternary cyclic code of length 11.
Below these are named \texttt{p1}, ..., \texttt{p12}. The result should be the union of $\{a,b\}$ and the set of 6 homogeneous binomials (that is, polynomials with two terms)
of degree 2 forcing commuting between $c$, $d$, $e$, and $f$. 

  

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 2 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 1 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,2);
  gap> SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 Now define some functions which will help in the construction of relations.
The function \texttt{powermon(g, exp)} will return the monomial $g^{exp}$. The function \texttt{comm(a, b)} will return a relation forcing commutativity between its two arguments \texttt{a} and \texttt{b}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> powermon := function(base, exp)
  >  local ans,i;
  >  ans := [];
  >  for i in [1..exp] do ans :=  Concatenation(ans,[base]); od;
  >  return ans;
  > end;;
  
  gap> comm := function(a,b)
  >   return [[[a,b],[b,a]],[1,-1]];
  > end;;
\end{Verbatim}
 Now the relations are entered. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[5,1]],[1]];;
  gap> p2 := [[powermon(1,3),[6,1]],[1,1]];;
  gap> p3 := [[powermon(1,9),Concatenation([3],powermon(1,3))],[1,1]];;
  gap> p4 := [[powermon(1,81),Concatenation([3],powermon(1,9)),
  > 	Concatenation([4],powermon(1,3))],[1,1,1]];;
  gap> p5 := [[Concatenation([3],powermon(1,81)),Concatenation([4],powermon(1,9)),
  > 	Concatenation([5],powermon(1,3))],[1,1,1]];;
  gap> p6 := [[powermon(1,27),Concatenation([4],powermon(1,81)),Concatenation([5],
  > 	powermon(1,9)),Concatenation([6],powermon(1,3))],[1,1,1,1]];;
  gap> p7 := [[powermon(2,1),Concatenation([3],powermon(1,27)),Concatenation([5],
  > 	powermon(1,81)),Concatenation([6],powermon(1,9))],[1,1,1,1]];;
  gap> p8 := [[Concatenation([3],powermon(2,1)),Concatenation([4],powermon(1,27)),
  > 	Concatenation([6],powermon(1,81))],[1,1,1]];;
  gap> p9 := [[Concatenation([],powermon(1,1)),Concatenation([4],powermon(2,1)),
  > 	Concatenation([5],powermon(1,27))],[1,1,1]];;
  gap> p10 := [[Concatenation([3],powermon(1,1)),Concatenation([5],powermon(2,1)),
  > 	Concatenation([6],powermon(1,27))],[1,1,1]];;
  gap> p11 := [[Concatenation([4],powermon(1,1)),Concatenation([6],powermon(2,1))],
  > 	[1,1]];;
  gap> p12 := [[Concatenation([],powermon(2,3)),Concatenation([],powermon(2,1))],
  > 	[1,-1]];;
  gap> KI := [p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12];;
  gap> for i in [1..5] do
  >     for j in [i+1..6] do
  >         Add(KI,comm(i,j));
  >     od;
  > od;
\end{Verbatim}
 The relations can be shown with \texttt{PrintNPList} (\ref{PrintNPList}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(KI);
   ea 
   a^3 + fa 
   a^9 + ca^3 
   a^81 + ca^9 + da^3 
   ca^81 + da^9 + ea^3 
   a^27 + da^81 + ea^9 + fa^3 
   b + ca^27 + ea^81 + fa^9 
   cb + da^27 + fa^81 
   a + db + ea^27 
   ca + eb + fa^27 
   da + fb 
   b^3 - b 
   ab - ba 
   ac - ca 
   ad - da 
   ae - ea 
   af - fa 
   bc - cb 
   bd - db 
   be - eb 
   bf - fb 
   cd - dc 
   ce - ec 
   cf - fc 
   de - ed 
   df - fd 
   ef - fe 
  gap> Length(KI);
  27
\end{Verbatim}
 It is sometimes easier to enter the relations as elements of a free algebra
and then use the function \texttt{GP2NP} (\ref{GP2NP}) or the function \texttt{GP2NPList} (\ref{GP2NPList}) to convert them. This will be demonstrated below. More about converting can be
read in Section \ref{TransitionFunctions}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> F:=Rationals;;
  gap> A:=FreeAssociativeAlgebraWithOne(F,"a","b","c","d","e","f");;
  gap> a:=A.a;; b:=A.b;; c:=A.c;; d:=A.d;; e:=A.e;; f:=A.f;;
  gap> KI_gp:=[e*a,                         #p1
  >         a^3 + f*a,                      #p2
  >         a^9 + c*a^3,                    #p3
  >         a^81 + c*a^9 + d*a^3,           #p4
  >         c*a^81 + d*a^9 + e*a^3,         #p5
  >         a^27 + d*a^81 + e*a^9 + f*a^3,  #p6
  >         b + c*a^27 + e*a^81 + f*a^9,    #p7
  >         c*b + d*a^27 + f*a^81,          #p8
  >         a + d*b + e*a^27,               #p9
  >         c*a + e*b + f*a^27,             #p10
  >         d*a + f*b,                      #p11
  >         b^3 - b];;                      #p12
\end{Verbatim}
 These relations can be converted to NP form (see \ref{NP}) with \texttt{GP2NPList} (\ref{GP2NPList}). For use in a Gr{\"o}bner basis computation we have to order the NP
polynomials in \texttt{KI}. This can be done with \texttt{CleanNP} (\ref{CleanNP}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> KI_np:=GP2NPList(KI_gp);;
  gap> Apply(KI,x->CleanNP(x));;
  gap> KI_np=KI{[1..12]};
  true
\end{Verbatim}
 The Gr{\"o}bner basis can now be calculated with \texttt{SGrobner} (\ref{SGrobner}) and printed with \texttt{PrintNPList} (\ref{PrintNPList}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := SGrobner(KI);;
  #I  number of entered polynomials is 27
  #I  number of polynomials after reduction is 8
  #I  End of phase I
  #I  End of phase II
  #I  List of todo lengths is [ 0 ]
  #I  End of phase III
  #I  G: Cleaning finished, 0 polynomials reduced
  #I  End of phase IV
  #I  The computation took 1220 msecs.
  gap> PrintNPList(GB);
   a 
   b 
   dc - cd 
   ec - ce 
   ed - de 
   fc - cf 
   fd - df 
   fe - ef 
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{The Birman-Murakami-Wenzl algebra of type A$_3$}}\label{Example07}
\logpage{[ "A", 8, 0 ]}
\hyperdef{L}{X7C2CD4FA838EEE64}{}
{
 We study the Birman-Murakami-Wenzl algebra of type A$_3$ as an algebra given by generators and relations. A reference for the relations
used is \cite{MR2124811}. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 1 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 1 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,1);
  gap> SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 The variables are $g_1$, $g_2$, $g_3$, $e_1$, $e_2$, $e_3$, in this order. In order to have the results printed out with these symbols,
we invoke \texttt{GBNP.ConfigPrint} (\ref{GBNP.ConfigPrint}) 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBNP.ConfigPrint("g1","g2","g3","e1","e2","e3");
\end{Verbatim}
 Now enter the relations. This will be done in NP form (see \ref{NP}). The inderminates $m$ and $l$ in the coefficient ring of the Birman-Murakami-Wenzl algebra are specialized
to 7 and 11 in order to make the computations more efficient. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> m:= 7;;
  gap> l:= 11;;
  
  gap> #relations Theorem 1.1
  gap> k1 := [[[4],[1,1],[1],[]],[1,-l/m,-l,l/m]];;
  gap> k2 := [[[5],[2,2],[2],[]],[1,-l/m,-l,l/m]];;
  gap> k3 := [[[6],[3,3],[3],[]],[1,-l/m,-l,l/m]];;
  
  gap> #relations B1
  gap> #empty set here
  
  gap> #relations B2:
  gap> k4 := [[[1,2,1],[2,1,2]],[1,-1]];;
  gap> k5 := [[[2,3,2],[3,2,3]],[1,-1]];;
  gap> k6 := [[[1,3],[3,1]],[1,-1]];;
  
  gap> #relations R1
  gap> kr1 := [[[1,4],[4]],[1,-1/l]];;
  gap> kr2 := [[[2,5],[5]],[1,-1/l]];;
  gap> kr3 := [[[3,6],[6]],[1,-1/l]];;
  
  gap> #relations R2:
  gap> kr4 := [[[4,2,4],[4]],[1,-l]];;
  gap> kr5 := [[[5,1,5],[5]],[1,-l]];;
  gap> kr6 := [[[5,3,5],[5]],[1,-l]];;
  gap> kr7 := [[[6,2,6],[6]],[1,-l]];;
  
  gap> #relations R2'
  gap> km1 := [[[4,5,4],[4]],[1,-1]];;
  gap> km2 := [[[5,4,5],[5]],[1,-1]];;
  gap> km3 := [[[5,6,5],[5]],[1,-1]];;
  gap> km4 := [[[6,5,6],[6]],[1,-1]];;
  
  gap> KI := [k1,k2,k3,k4,k5,k6,kr1,kr2,kr3,kr4,kr5,kr6,kr7,km1,km2,km3,km4];;
\end{Verbatim}
 Now print the relations with \texttt{PrintNPList} (\ref{PrintNPList}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(KI);
   e1 - 11/7g1^2 - 11g1 + 11/7 
   e2 - 11/7g2^2 - 11g2 + 11/7 
   e3 - 11/7g3^2 - 11g3 + 11/7 
   g1g2g1 - g2g1g2 
   g2g3g2 - g3g2g3 
   g1g3 - g3g1 
   g1e1 - 1/11e1 
   g2e2 - 1/11e2 
   g3e3 - 1/11e3 
   e1g2e1 - 11e1 
   e2g1e2 - 11e2 
   e2g3e2 - 11e2 
   e3g2e3 - 11e3 
   e1e2e1 - e1 
   e2e1e2 - e2 
   e2e3e2 - e2 
   e3e2e3 - e3 
  gap> Length(KI);
  17
\end{Verbatim}
 Now calculate the Gr{\"o}bner basis with \texttt{SGrobner} (\ref{SGrobner}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := SGrobner(KI);;
  #I  number of entered polynomials is 17
  #I  number of polynomials after reduction is 17
  #I  End of phase I
  #I  End of phase II
  #I  End of phase III
  #I  End of phase IV
  #I  The computation took 144 msecs.
  gap> PrintNPList(GB);
   g1^2 - 7/11e1 + 7g1 - 1 
   g1e1 - 1/11e1 
   g2^2 - 7/11e2 + 7g2 - 1 
   g2e2 - 1/11e2 
   g3g1 - g1g3 
   g3^2 - 7/11e3 + 7g3 - 1 
   g3e3 - 1/11e3 
   e1g1 - 1/11e1 
   e1g3 - g3e1 
   e1^2 + 43/77e1 
   e2g2 - 1/11e2 
   e2^2 + 43/77e2 
   e3g1 - g1e3 
   e3g3 - 1/11e3 
   e3e1 - e1e3 
   e3^2 + 43/77e3 
   g1g2e1 - e2e1 
   g1g3e1 - 1/11g3e1 
   g1e2e1 + 7e2e1 - g2e1 - 7e1 
   g2g1g2 - g1g2g1 
   g2g1e2 - e1e2 
   g2g3e2 - e3e2 
   g2e1g2 - g1e2g1 - 7e2g1 + 7e1g2 + 7g2e1 - 7g1e2 - 49e2 + 49e1 
   g2e1e2 + 7e1e2 - g1e2 - 7e2 
   g2e3e2 + 7e3e2 - g3e2 - 7e2 
   g3g2g3 - g2g3g2 
   g3g2e3 - e2e3 
   g3e1e3 - 1/11e1e3 
   g3e2g3 - g2e3g2 - 7e3g2 + 7e2g3 + 7g3e2 - 7g2e3 - 49e3 + 49e2 
   g3e2e3 + 7e2e3 - g2e3 - 7e3 
   e1g2g1 - e1e2 
   e1g2e1 - 11e1 
   e1e2g1 + 7e1e2 - e1g2 - 7e1 
   e1e2e1 - e1 
   e2g1g2 - e2e1 
   e2g1e2 - 11e2 
   e2g3g2 - e2e3 
   e2g3e2 - 11e2 
   e2e1g2 + 7e2e1 - e2g1 - 7e2 
   e2e1e2 - e2 
   e2e3g2 + 7e2e3 - e2g3 - 7e2 
   e2e3e2 - e2 
   e3g2g3 - e3e2 
   e3g2e3 - 11e3 
   e3e2g3 + 7e3e2 - e3g2 - 7e3 
   e3e2e3 - e3 
   g1g2g3e1 - e2g3e1 
   g1g3g2e1 - g3e2e1 
   g1g3e2e1 + 7g3e2e1 - g3g2e1 - 7g3e1 
   g1e2g3e1 + 7e2g3e1 - g2g3e1 - 7g3e1 
   g1e3g2e1 - e3e2e1 
   g1e3e2e1 + 7e3e2e1 - e3g2e1 - 7e1e3 
   g3g2g1g3 - g2g3g2g1 
   g3g2g1e3 - e2g1e3 
   g3g2e1e3 - e2e1e3 
   g3e1g2e3 - e1e2e3 
   g3e1e2e3 + 7e1e2e3 - e1g2e3 - 7e1e3 
   g3e2g1g3 - g2e3g2g1 - 7e3g2g1 + 7e2g1g3 + 7g3e2g1 - 7g2g1e3 + 49e2g1 - 49g1e3\
   
   g3e2g1e3 + 7e2g1e3 - g2g1e3 - 7g1e3 
   g3e2e1e3 + 7e2e1e3 - g2e1e3 - 7e1e3 
   e1g2g3g2 - g3e1g2g3 
   e1g2g3e1 - 11g3e1 
   e1g2e3g2 - g3e1e2g3 + 7e1e3g2 - 7e1e2g3 + 7e1g2e3 - 7g3e1e2 + 49e1e3 - 49e1e2\
   
   e1e2g3e1 - g3e1 
   e1e3g2g1 - e1e3e2 
   e1e3g2e1 - 11e1e3 
   e1e3e2g1 + 7e1e3e2 - e1e3g2 - 7e1e3 
   e1e3e2e1 - e1e3 
   e2g3e1e2 - e2g1e3e2 
   e2e1e3e2 + 7e2g1e3e2 - e2g1g3e2 - 77e2 
   e3g2g1g3 - e3e2g1 
   e3g2g1e3 - 11g1e3 
   e3g2e1e3 - 11e1e3 
   e3e2g1g3 + 7e3e2g1 - e3g2g1 - 7g1e3 
   e3e2g1e3 - g1e3 
   e3e2e1e3 - e1e3 
   g1g2g1g3e2 - g2g1e3e2 
   g1g2g1e3e2 + 7g2g1e3e2 - g2g1g3e2 - 7e1e2 
   g1g2g3g2e1 - g2e3g2e1 - 7e3g2e1 + 7e2g3e1 + 7g3e2e1 - 7g2e1e3 + 49e2e1 - 49e1\
  e3 
   g1g2e3g2e1 + 7g2e3g2e1 - g2g3g2e1 + 7e3e2e1 + 49e3g2e1 + 7e2e1e3 - 7g3g2e1 + \
  49g2e1e3 - 7g2g3e1 + 343e1e3 - 49g3e1 - 49g2e1 - 350e1 
   g1e2g1g3e2 + 7e2g1g3e2 - g2e1e3e2 - 7g2g3e1e2 - 7e1e3e2 - 49g3e1e2 + 77g1e2 +\
   539e2 
   g1e2g1e3e2 + 7e2g1e3e2 - g2g3e1e2 - 7g3e1e2 
   g2g3e1g2g3 - g1e2g1g3g2 - 7e2g1g3g2 + 7g3e1g2g3 + 7g2g3e1g2 + 49g3e1g2 - 7g1e\
  2e3 - 49e2e3 
   g2g3e1e2g3 - g1e2g1e3g2 - 7e2g1e3g2 + 7g3e1e2g3 + 7g2g3e1e2 - 7g1e2g1e3 - 49e\
  2g1e3 + 49g3e1e2 
   e2g1g3g2g1 - e2g1e3g2 
   e2g1g3e2g1 - e2e1e3g2 - 7e2g3e1g2 + 7e2g1g3e2 - 7e2e1e3 - 49e2g3e1 + 77e2g1 +\
   539e2 
   e2g1e3g2g1 + 7e2g1e3g2 - e2g1g3g2 - 7e2e1 
   e2g1e3e2g1 - e2g3e1g2 + 7e2g1e3e2 - 7e2g3e1 
   e2g3e1g2g3 + 7e2g3e1g2 - e2g1g3g2 - 7e2e3 
\end{Verbatim}
 Now calculate the dimension of the quotient algebra with \texttt{DimQA} (\ref{DimQA}) (the second argument is the number of symbols): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> DimQA(GB,6);
  105
\end{Verbatim}
 The conclusion is that the BMW algebra of type A3 has dimension 105. }

 
\section{\textcolor{Chapter }{The Birman-Murakami-Wenzl algebra of type A$_2$}}\label{Example08}
\logpage{[ "A", 9, 0 ]}
\hyperdef{L}{X7B5CA7F379B78CE0}{}
{
 The trace variant (see sections \ref{trace} and \ref{tracefun}) will be used for a presentation of the Birman-Murakami-Wenzl algebra of type
A$_2$ by generators and relations in order to find a proof that the algebra has
dimension 15. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 1 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 1 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,1);
  gap> SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 The variables are $g_1$, $g_2$, $e_1$, $e_2$, in this order. In order to have the results printed out with these symbols,
we invoke \texttt{GBNP.ConfigPrint} (\ref{GBNP.ConfigPrint}) 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBNP.ConfigPrint("g1","g2","e1","e2");
\end{Verbatim}
 Unlike Example \ref{Example07}, we work with a field of rational functions. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> ll := Indeterminate(Rationals,"l");
  l
  gap> mm := Indeterminate(Rationals,"m");
  m
  gap> F := Field(ll,mm);
  <field in characteristic 0>
  gap> gens := GeneratorsOfField(F);
  [ l, m ]
  gap> l := gens[1];;
  gap> m := gens[2];
  m
  gap> F1 := One(F);;
  gap> Print("identity element of F: ",F1,"\n");
  identity element of F: 1
\end{Verbatim}
 Now enter the relations. This will be done in NP form. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> #relations Theorem 1.1
  gap> k1 := [[[3],[1,1],[1],[]],[F1,-l/m,-l,l/m]];;
  gap> k2 := [[[4],[2,2],[2],[]],[F1,-l/m,-l,l/m]];;
  
  gap> #relations B1
  gap> #empty set here
  
  gap> #relations B2:
  gap> k3 := [[[1,2,1],[2,1,2]],[F1,-F1]];;
  
  gap> #relations R1
  gap> k4 := [[[1,3],[3]],[F1,-1/l]];;
  gap> k5 := [[[2,4],[4]],[F1,-1/l]];;
  
  gap> #relations R2:
  gap> k6 := [[[3,2,3],[3]],[F1,-l]];;
  gap> k7 := [[[4,1,4],[4]],[F1,-l]];;
  gap> k8 := [[[3,4,3],[3]],[F1,-F1]];;
  gap> k9 := [[[4,3,4],[4]],[F1,-F1]];;
  
  gap> KI := [k1,k2,k3,k4,k5,k6,k7,k8,k9];;
\end{Verbatim}
 The input can be displayed with \texttt{PrintNPList} (\ref{PrintNPList}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(KI);
   e1 + -l/mg1^2 + -lg1 + l/m 
   e2 + -l/mg2^2 + -lg2 + l/m 
   g1g2g1 + -1g2g1g2 
   g1e1 + -1/le1 
   g2e2 + -1/le2 
   e1g2e1 + -le1 
   e2g1e2 + -le2 
   e1e2e1 + -1e1 
   e2e1e2 + -1e2 
\end{Verbatim}
 Now calculate the Gr{\"o}bner basis with trace information, using the function \texttt{SGrobnerTrace} (\ref{SGrobnerTrace}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := SGrobnerTrace(KI);;
  #I  number of entered polynomials is 9
  #I  number of polynomials after reduction is 9
  #I  End of phase I
  #I  End of phase II
  #I  List of todo lengths is [ 8, 7, 6, 5, 4, 6, 4, 4, 4, 3, 3, 2, 1, 0 ]
  #I  End of phase III
  #I  End of phase IV
  #I  The computation took 1092 msecs.
\end{Verbatim}
 The full trace can be printed with \texttt{PrintTraceList} (\ref{PrintTraceList}), while printing only the relations (and no trace) can be invoked by \texttt{PrintNPListTrace} (\ref{PrintNPListTrace}). Since the total trace is very long we do not call \texttt{PrintTraceList(GB)} here but only show two polynomial expressions from the Gr{\"o}bner basis with \texttt{PrintTracePol} (\ref{PrintTracePol}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPListTrace(GB);
   g1^2 + m/-le1 + mg1 + -1 
   g1e1 + -1/le1 
   g2^2 + m/-le2 + mg2 + -1 
   g2e2 + -1/le2 
   e1g1 + 1/-le1 
   e1^2 + (l^2-l*m-1)/(l*m)e1 
   e2g2 + 1/-le2 
   e2^2 + (l^2-l*m-1)/(l*m)e2 
   g1g2e1 + -1e2e1 
   g1e2e1 + me2e1 + -1g2e1 + -me1 
   g2g1g2 + 1/-1g1g2g1 
   g2g1e2 + -1e1e2 
   g2e1g2 + -1g1e2g1 + -me2g1 + me1g2 + mg2e1 + -mg1e2 + -m^2e2 + m^2e1 
   g2e1e2 + me1e2 + -1g1e2 + -me2 
   e1g2g1 + -1e1e2 
   e1g2e1 + -le1 
   e1e2g1 + me1e2 + -1e1g2 + -me1 
   e1e2e1 + -1e1 
   e2g1g2 + -1e2e1 
   e2g1e2 + -le2 
   e2e1g2 + me2e1 + -1e2g1 + -me2 
   e2e1e2 + -1e2 
  gap> PrintTracePol(GB[1]);
   m/-lG(1) 
  gap> PrintTracePol(GB[10]);
   -l*m/(-l*m-1)G(1)g1e2e1 + -l*m/(l*m+1)g1G(1)e2e1 + l^2*m/(-l*m-1)G(
  1)g2g1e1 + l*m^2/(-l*m-1)G(1)g2g1e2e1 + -l/(-l*m-1)g2G(
  1)g1e2e1 + -l/(l*m+1)g2g1G(1)e2e1 + l^2/(-l*m-1)g2G(
  1)g2g1e1 + l*m/(-l*m-1)g2G(1)g2g1e2e1 + -l*m/(-l*m-1)e1g2G(
  1)g2g1e1 + -l/(-l*m-1)g2e1g2G(1)g2g1e1 + -m/-lG(
  2)g1e2e1 + -l^2*m/(-l*m-1)g2g1G(2)e1 + -l^2/(-l*m-1)g2^2g1G(
  2)e1 + m^2/(-l*m-1)e1G(2)g1e2e1 + m/(-l*m-1)g2e1G(
  2)g1e2e1 + -l*m/(l*m+1)e1g2^2g1G(2)e1 + -l/(l*m+1)g2e1g2^2g1G(
  2)e1 + l^3*m/(-l*m-1)G(3)e1 + l^3/(-l*m-1)g1G(3)e1 + l^3/(-l*m-1)G(
  3)g2e1 + l^3/(-l*m-1)g2G(3)e1 + l^2*m^2/(-l*m-1)G(3)e2e1 + l^2*m/(-l*m-1)g1G(
  3)e2e1 + l^3/(-l*m^2-m)g2g1G(3)e1 + l^3/(-l*m^2-m)g2G(
  3)g2e1 + l^2*m/(-l*m-1)G(3)g2e2e1 + l^2*m/(-l*m-1)g2G(
  3)e2e1 + -l^2*m/(-l*m-1)e1g2G(3)e1 + l^2/(-l*m-1)g2g1G(
  3)e2e1 + l^2/(-l*m-1)g2G(3)g2e2e1 + -l^2/(-l*m-1)g2e1g2G(
  3)e1 + -l^2/(-l*m-1)e1g2g1G(3)e1 + -l^2/(-l*m-1)e1g2G(
  3)g2e1 + -l^2/(-l*m^2-m)g2e1g2g1G(3)e1 + -l^2/(-l*m^2-m)g2e1g2G(
  3)g2e1 + -l*m/(-l*m-1)G(4)e2e1 + -l/(-l*m-1)g2G(4)e2e1 + -l*mg2g1G(
  5)e1 + l^2*m/(-l*m-1)g2g1g2G(5)e1 + -lg2^2g1G(5)e1 + l^2/(-l*m-1)g2^2g1g2G(
  5)e1 + l*m/(-l*m-1)G(6)g2g1e1 + l/(-l*m-1)g2G(6)g2g1e1 + m/-lG(
  7)e1 + -m^2/(-l*m-1)e1G(7)e1 + -m/(-l*m-1)g2e1G(7)e1 + mG(8) + g2G(8) 
\end{Verbatim}
 In order to test whether the expression for \texttt{GB[10]} is as claimed we use \texttt{EvalTrace} (\ref{EvalTrace}), For each traced polynomial \texttt{x} in \texttt{GB}, we equate the evaluated expression \texttt{x.trace}, in which each occurrence of \texttt{G(i)} is replaced by \texttt{KI[i]} by use of \texttt{EvalTrace} (\ref{EvalTrace}), with \texttt{x.pol}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> ForAll(GB,x->EvalTrace(x,KI)=x.pol);
  false
\end{Verbatim}
 As a result the dimension of the quotient algebra can be calculated with \texttt{DimQA} (\ref{DimQA}) and the quotient algebra itself with \texttt{BaseQA} (\ref{BaseQA}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB_pols:=List(GB,x->x.pol);;
  gap> PrintNPList(GB_pols);
   g1^2 + m/-le1 + mg1 + -1 
   g1e1 + -1/le1 
   g2^2 + m/-le2 + mg2 + -1 
   g2e2 + -1/le2 
   e1g1 + 1/-le1 
   e1^2 + (l^2-l*m-1)/(l*m)e1 
   e2g2 + 1/-le2 
   e2^2 + (l^2-l*m-1)/(l*m)e2 
   g1g2e1 + -1e2e1 
   g1e2e1 + me2e1 + -1g2e1 + -me1 
   g2g1g2 + 1/-1g1g2g1 
   g2g1e2 + -1e1e2 
   g2e1g2 + -1g1e2g1 + -me2g1 + me1g2 + mg2e1 + -mg1e2 + -m^2e2 + m^2e1 
   g2e1e2 + me1e2 + -1g1e2 + -me2 
   e1g2g1 + -1e1e2 
   e1g2e1 + -le1 
   e1e2g1 + me1e2 + -1e1g2 + -me1 
   e1e2e1 + -1e1 
   e2g1g2 + -1e2e1 
   e2g1e2 + -le2 
   e2e1g2 + me2e1 + -1e2g1 + -me2 
   e2e1e2 + -1e2 
  gap> DimQA(GB_pols,2);
  6
  gap> B:=BaseQA(GB_pols,2,0);;
  gap> PrintNPList(B);
   1 
   g1 
   g2 
   g1g2 
   g2g1 
   g1g2g1 
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{A commutative example by Mora}}\label{Example10}
\logpage{[ "A", 10, 0 ]}
\hyperdef{L}{X83C81C987A4DE15F}{}
{
 Here we present a commutative example from page 339 of ``An introduction to commutative and non-commutative Gr{\"o}bner Bases'', by Teo Mora \cite{TCS::Mora1994:131}. It involves the seven variables $a,b,c,d,e,f,g$. In order to force commuting between each pair from $\{a,b,c,d,e,f,g\}$, we let part of the input equations be the homogeneous binomials of the form $xy - yx$. GBNP is built for non-commutative polynomial arithmetic, and should handle
the commutative case by means of this forced commutation. But it should not be
considered as a serious alternative to the well-known Gr{\"o}bner bases
packages when it comes to efficiency. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 1 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 1 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,1);
  gap> SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 The relations will be entered as GAP polynomials and converted to NP form (see \ref{NP}) with \texttt{GP2NPList} (\ref{GP2NPList}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> F:=GF(7);; ef:=One(F);;
  gap> A:=FreeAssociativeAlgebraWithOne(F, "a", "b", "c", "d", "e", "f", "g");
  <algebra-with-one over GF(7), with 7 generators>
  gap> gens:=GeneratorsOfAlgebra(A);
  [ (Z(7)^0)*<identity ...>, (Z(7)^0)*a, (Z(7)^0)*b, (Z(7)^0)*c, (Z(7)^0)*d, 
    (Z(7)^0)*e, (Z(7)^0)*f, (Z(7)^0)*g ]
  gap> a:=gens[2];; b:=gens[3];; c:=gens[4];; d:=gens[5];; e:=gens[6];; f:=gens[7];;
  gap> g:=gens[8];; ea:=gens[1];;
  
  gap> rels := [ a^3 + f*a, 
  > 	a^9 + c*a^3 + g*a,
  > 	a^81 + c*a^9 + d*a^3,
  > 	c*a^81 + d*a^9 + e*a^3,
  > 	a^27 + d*a^81 + e*a^9 + f*a^3,
  > 	b + c*a^27 + e*a^81 + f*a^9 + g*a^3,
  > 	c*b + d*a^27 + f*a^81 + g*a^9,
  > 	a + d*b + e*a^27 + g*a^81,
  > 	c*a + e*b + f*a^27,
  > 	d*a + f*b + g*a^27,
  > 	e*a + g*b,
  > 	b^3 - b ];;
\end{Verbatim}
 Some relations added to enforce commutativity. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> for i in [1..6] do
  >     for j in [i+1..7] do
  >         Add(rels,gens[i+1]*gens[j+1]-gens[j+1]*gens[i+1]);
  >     od;
  > od;
\end{Verbatim}
 Now the relations are converted to NP form (see \ref{NP}) with the function \texttt{GP2NPList} (\ref{GP2NPList}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> KI:=GP2NPList(rels);;
\end{Verbatim}
 The Gr{\"o}bner basis can be calculated with \texttt{SGrobner} (\ref{SGrobner}) and printed with \texttt{PrintNPList} (\ref{PrintNPList}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := SGrobner(KI);;
  #I  number of entered polynomials is 33
  #I  number of polynomials after reduction is 33
  #I  End of phase I
  #I  End of phase II
  #I  End of phase III
  #I  End of phase IV
  #I  The computation took 49047 msecs.
  gap> PrintNPList(GB);
   a 
   b 
   dc + Z(7)^3cd 
   ec + Z(7)^3ce 
   ed + Z(7)^3de 
   fc + Z(7)^3cf 
   fd + Z(7)^3df 
   fe + Z(7)^3ef 
   gc + Z(7)^3cg 
   gd + Z(7)^3dg 
   ge + Z(7)^3eg 
   gf + Z(7)^3fg 
\end{Verbatim}
 To determine whether the quotient algebra is finite dimensional we invoke \texttt{FinCheckQA} (\ref{FinCheckQA}), using as arguments the leading monomials of \texttt{GB} and 7, the number of variables involved. The leading monomials of \texttt{GB} are obtained by \texttt{LMonsNP} (\ref{LMonsNP}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> F := LMonsNP(GB);;
  gap> FinCheckQA(F,7);
  false
\end{Verbatim}
 Thus, the quotient algebra turns out to be infinite dimensional. This is no
surprise as the Gr{\"o}bner basis shows it is actually the free commutative
algebra generated by $c,d,e,f,g$. In particular, it has polynomial growth of degree 5. This is confirmed by
application of \texttt{DetermineGrowthQA} (\ref{DetermineGrowthQA}), with the first two arguments as for \texttt{FinCheckQA} above and third argument \texttt{false}, indicating that an interval for the degree of the polynomial degree will
suffice. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> DetermineGrowthQA(F,7,false);
  5
\end{Verbatim}
 It turns out that this quick version already gives an exact answer. More time
consuming would be the algorithm run with third argument equal to \texttt{true}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> DetermineGrowthQA(F,7,true);
  5
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Tracing an example by Mora}}\label{Example09}
\logpage{[ "A", 11, 0 ]}
\hyperdef{L}{X7CAB94A37D580C4A}{}
{
 This example of a non-commutative Gr{\"o}bner basis computation is from page
18 of ``An introduction to commutative and non-commutative Gr{\"o}bner Bases'', by Teo Mora \cite{TCS::Mora1994:131}. The traced version of the algorithm will be used. The input is $\{xyx-y,yxy-y\}$. The answer should be $\{yy-xy,yx-xy,xxy-y\}$. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 2 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 1 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,2);
  gap> SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 Let the variables be printed as $x$ and $y$ instead of $a$ and $b$ by means of \texttt{GBNP.ConfigPrint} (\ref{GBNP.ConfigPrint}) 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBNP.ConfigPrint("x","y");
\end{Verbatim}
 Next we input the relations in NP format (see Section \ref{NP}). They will be assigned to \texttt{KI}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> xyx := [[[1,2,1],[2]],[1,-1]];;
  gap> yxy := [[[2,1,2],[2]],[1,-1]];;
  gap> KI:=[xyx,yxy];;
\end{Verbatim}
 The relations can be shown with \texttt{PrintNPList} (\ref{PrintNPList}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(KI);
   xyx - y 
   yxy - y 
\end{Verbatim}
 The Gr{\"o}bner basis with trace can now be calculated with \texttt{SGrobnerTrace} (\ref{SGrobnerTrace}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := SGrobnerTrace(KI);
  #I  number of entered polynomials is 2
  #I  number of polynomials after reduction is 2
  #I  End of phase I
  #I  End of phase II
  #I  j =2
  #I  Current number of elements in todo is 1
  #I  j =3
  #I  Current number of elements in todo is 0
  #I  List of todo lengths is [ 2, 1, 0 ]
  #I  End of phase III
  #I  End of phase IV
  #I  The computation took 8 msecs.
  [ rec( pol := [ [ [ 2, 1 ], [ 1, 2 ] ], [ 1, -1 ] ], 
        trace := [ [ [  ], 1, [ 2 ], -1 ], [ [ 2 ], 1, [  ], 1 ], 
            [ [ 1 ], 2, [  ], 1 ], [ [  ], 2, [ 1 ], -1 ] ] ), 
    rec( pol := [ [ [ 2, 2 ], [ 1, 2 ] ], [ 1, -1 ] ], 
        trace := [ [ [ 2 ], 1, [  ], -1 ], [ [  ], 1, [ 2 ], -1 ], 
            [ [ 2 ], 1, [  ], 1 ], [ [  ], 2, [ 1 ], 1 ], [ [ 1 ], 2, [  ], 1 ],
            [ [  ], 2, [ 1 ], -1 ] ] ), 
    rec( pol := [ [ [ 1, 1, 2 ], [ 2 ] ], [ 1, -1 ] ], 
        trace := [ [ [  ], 1, [  ], 1 ], [ [ 1 ], 1, [ 2 ], 1 ], 
            [ [ 1, 2 ], 1, [  ], -1 ], [ [ 1, 1 ], 2, [  ], -1 ], 
            [ [ 1 ], 2, [ 1 ], 1 ] ] ) ]
\end{Verbatim}
 The Gr{\"o}bner basis can be printed with \texttt{PrintNPListTrace} (\ref{PrintNPListTrace}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPListTrace(GB);
   yx - xy 
   y^2 - xy 
   x^2y - y 
\end{Verbatim}
 The trace of the Gr{\"o}bner basis can be printed with \texttt{PrintTraceList} (\ref{PrintTraceList}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintTraceList(GB);
  - G(1)y + yG(1) - G(2)x + xG(2) 
  
  - G(1)y + xG(2) 
  
   G(1) + xG(1)y - xyG(1) + xG(2)x - x^2G(2) 
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{ Finiteness of the Weyl group of type E$_6$}}\label{Example13}
\logpage{[ "A", 12, 0 ]}
\hyperdef{L}{X8599AE8F7E9E0368}{}
{
 

 This example extends \ref{Example03}, which computes the order of the Weyl group of type E$_6$. 

 Here, before the dimension is calculated, it is checked whether the quotient
algebra is finite dimensional or infinite dimensional. The function \texttt{FinCheckQA} (\ref{FinCheckQA}) is used for this computation. For the use of \texttt{PreprocessAnalysisQA} (\ref{PreprocessAnalysisQA}) to speed up the check, see Example \ref{Example14}. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 1 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 2 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,1);
  gap> SetInfoLevel(InfoGBNPTime,2);
\end{Verbatim}
 Then input the relations in NP format (see Section \ref{NP}). They will be assigned to \texttt{KI}. These relations are the same as those in Example 3. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> k1 := [[[1,3,1],[3,1,3]],[1,-1]];;
  gap> k2 := [[[4,3,4],[3,4,3]],[1,-1]];;
  gap> k3 := [[[4,2,4],[2,4,2]],[1,-1]];;
  gap> k4 := [[[4,5,4],[5,4,5]],[1,-1]];;
  gap> k5 := [[[6,5,6],[5,6,5]],[1,-1]];;
  gap> k6 := [[[1,2],[2,1]],[1,-1]];;
  gap> k7 := [[[1,4],[4,1]],[1,-1]];;
  gap> k8 := [[[1,5],[5,1]],[1,-1]];;
  gap> k9 := [[[1,6],[6,1]],[1,-1]];;
  gap> k10 := [[[2,3],[3,2]],[1,-1]];;
  gap> k11 := [[[2,5],[5,2]],[1,-1]];;
  gap> k12 := [[[2,6],[6,2]],[1,-1]];;
  gap> k13 := [[[3,5],[5,3]],[1,-1]];;
  gap> k14 := [[[3,6],[6,3]],[1,-1]];;
  gap> k15 := [[[4,6],[6,4]],[1,-1]];;
  gap> k16 := [[[1,1],[]],[1,-1]];;
  gap> k17 := [[[2,2],[]],[1,-1]];;
  gap> k18 := [[[3,3],[]],[1,-1]];;
  gap> k19 := [[[4,4],[]],[1,-1]];;
  gap> k20 := [[[5,5],[]],[1,-1]];;
  gap> k21 := [[[6,6],[]],[1,-1]];;
  gap> KI := [k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,
  >        k11,k12,k13,k14,k15,k16,k17,k18,k19,k20,k21
  >       ];;
\end{Verbatim}
 The Gr{\"o}bner basis can now be calculated with \texttt{SGrobner} (\ref{SGrobner}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := SGrobner(KI);;
  #I  number of entered polynomials is 21
  #I  number of polynomials after reduction is 21
  #I  End of phase I
  #I  End of phase II
  #I  End of phase III
  #I  Time needed to clean G :0
  #I  End of phase IV
  #I  The computation took 220 msecs.
\end{Verbatim}
 We will check whether the quotient algebra is finite dimensional or infinite
dimensional. The function \texttt{FinCheckQA} (\ref{FinCheckQA}) exists for this purpose. Its first argument is the list of leading monomials
of a Gr{\"o}bner basis and its second argument the number of symbols. The
leading monomials can be calculated with \texttt{LMonsNP} (\ref{LMonsNP}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> L:=LMonsNP(GB);;
  gap> FinCheckQA(L,6);
  true
  gap> time;
  84
\end{Verbatim}
 If a quotient algebra is finite dimensional, the dimension can be calculated
with \texttt{DimQA} (\ref{DimQA}), the arguments are the Gr{\"o}bner basis \texttt{GB} and the number of symbols \texttt{6}. Since \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) is set to 2, we get timing information from \texttt{DimQA} (\ref{DimQA}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> dim := DimQA(GB,6);
  #I  The computation took 272 msecs.
  51840
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Preprocessing for Weyl group computations}}\label{Example14}
\logpage{[ "A", 13, 0 ]}
\hyperdef{L}{X7B1822C67CF83041}{}
{
 This example extends Example \ref{Example03} with the following action: after the Gr{\"o}bner basis computation, we first
check if the quotient algebra is finite dimensional or infinite dimensional
before we possibly try to compute that dimension. Preprocessing of the set of
leading terms of the Gr{\"o}bner basis is used to speed up the check. The
functions \texttt{PreprocessAnalysisQA} (\ref{PreprocessAnalysisQA}) and \texttt{FinCheckQA} (\ref{FinCheckQA}) are used for the computations. Even without preprocessing this already goes
fast. Still, preprocessing can speed up more involved cases. For instance,
after adapting this example to run for E7, we found that preprocessing speeds
up the computation from 400 secs to about 40 secs. (Be aware that Gr{\"o}bner
basis computation will take a while for E7.) 

 More information about the preprocessing can be found in the preprint ``The dimensionality of quotient algebras'' \cite{Krook2003} which is part of the documentation. 

 Note: there is no information on the amount of preprocessing which is optimal,
but in general for big examples, even full preprocessing is better than using
no preprocessing at all. 

 Note: Example \ref{Example13} also determines if the quotient algebra appearing here is finite or infinite
dimensional but does not use preprocessing. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 0 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 2 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,0);
  gap> SetInfoLevel(InfoGBNPTime,2);
\end{Verbatim}
 Then input the relations in NP format (see Section \ref{NP}). They will be assigned to \texttt{KI}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> k1 := [[[1,3,1],[3,1,3]],[1,-1]];;
  gap> k2 := [[[4,3,4],[3,4,3]],[1,-1]];;
  gap> k3 := [[[4,2,4],[2,4,2]],[1,-1]];;
  gap> k4 := [[[4,5,4],[5,4,5]],[1,-1]];;
  gap> k5 := [[[6,5,6],[5,6,5]],[1,-1]];;
  gap> k6 := [[[1,2],[2,1]],[1,-1]];;
  gap> k7 := [[[1,4],[4,1]],[1,-1]];;
  gap> k8 := [[[1,5],[5,1]],[1,-1]];;
  gap> k9 := [[[1,6],[6,1]],[1,-1]];;
  gap> k10 := [[[2,3],[3,2]],[1,-1]];;
  gap> k11 := [[[2,5],[5,2]],[1,-1]];;
  gap> k12 := [[[2,6],[6,2]],[1,-1]];;
  gap> k13 := [[[3,5],[5,3]],[1,-1]];;
  gap> k14 := [[[3,6],[6,3]],[1,-1]];;
  gap> k15 := [[[4,6],[6,4]],[1,-1]];;
  gap> k16 := [[[1,1],[]],[1,-1]];;
  gap> k17 := [[[2,2],[]],[1,-1]];;
  gap> k18 := [[[3,3],[]],[1,-1]];;
  gap> k19 := [[[4,4],[]],[1,-1]];;
  gap> k20 := [[[5,5],[]],[1,-1]];;
  gap> k21 := [[[6,6],[]],[1,-1]];;
  gap> KI := [k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,
  >        k11,k12,k13,k14,k15,k16,k17,k18,k19,k20,k21
  >       ];;
\end{Verbatim}
 The Gr{\"o}bner basis can now be calculated with \texttt{SGrobner} (\ref{SGrobner}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := SGrobner(KI);;
  #I  Time needed to clean G :0
  #I  The computation took 220 msecs.
\end{Verbatim}
 Check the dimensionality of the quotient algebra. We will check whether it is
finite dimensional or infinite dimensional. In case of finite dimensionality
we can compute this dimension. 

 The function \texttt{FinCheckQA} (\ref{FinCheckQA}), which is used to check finite dimensionality has as first argument the list
of leading monomials of a Gr{\"o}bner basis and as second argument the number
of symbols. The monomials can be calculated with \texttt{LMonsNP} (\ref{LMonsNP}). They then will be preprocessed using 4 recursions. If you want full
preprocessing, use 0 instead of 4 as a parameter for the number of recursions. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> L:=LMonsNP(GB);;
  gap> L:=PreprocessAnalysisQA(L,6,4);;
  gap> time;
  12
  gap> fd:=FinCheckQA(L,6);
  true
  gap> time;
  8
\end{Verbatim}
 If a quotient algebra is finite dimensional, the dimension can be calculated
with \texttt{DimQA} (\ref{DimQA}), the arguments are the Gr{\"o}bner basis \texttt{GB} and the number of symbols \texttt{6}. Since \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) is set to 2, we get timing information from \texttt{DimQA} (\ref{DimQA}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> dim := DimQA(GB,6);
  #I  The computation took 276 msecs.
  51840
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{A quotient algebra with exponential growth}}\label{Example15}
\logpage{[ "A", 14, 0 ]}
\hyperdef{L}{X7BE4A97886B0930E}{}
{
 This example demonstrates an instance in which the quotient algebra is
infinite dimensional and has exponential growth. We start out with \texttt{KI}$:=[y^4-y^2,x^2y-xy]$ and obtain a Gr{\"o}bner basis with leading terms $[xxy,yyy]$. The quotient algebra will thus have exponential growth since the cycles $(xyyx)^n$ and $(xy)^m$ intersect in the common subwords $xy$ (and in $yx$). This is explained in \cite{Krook2003}. The function \texttt{DetermineGrowthQA} (\ref{DetermineGrowthQA}) is used for the computation. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 2 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 1 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,2);
  gap> SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 Let the variables be printed as $x$ and $y$ instead of $a$ and $b$ by means of \texttt{GBNP.ConfigPrint} (\ref{GBNP.ConfigPrint}) 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBNP.ConfigPrint("x","y");
\end{Verbatim}
 Then input the relations in NP format (see Section \ref{NP}). They will be assigned to \texttt{KI}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> k1 := [[[2,2,2,2],[2,2]],[1,-1]];;
  gap> k2 := [[[1,1,2],[1,2]],[1,-1]];;
  gap> KI := [k1,k2];;
  gap> PrintNPList(KI);
   y^4 - y^2 
   x^2y - xy 
\end{Verbatim}
 We calculate the Gr{\"o}bner basis with the function \texttt{SGrobner} (\ref{SGrobner}) and print it with \texttt{PrintNPList} (\ref{PrintNPList}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := SGrobner(KI);;
  #I  number of entered polynomials is 2
  #I  number of polynomials after reduction is 2
  #I  End of phase I
  #I  End of phase II
  #I  List of todo lengths is [ 0 ]
  #I  End of phase III
  #I  G: Cleaning finished, 0 polynomials reduced
  #I  End of phase IV
  #I  The computation took 8 msecs.
  gap> PrintNPList(GB);
   x^2y - xy 
   y^4 - y^2 
\end{Verbatim}
 Next we check the dimensionality of the quotient algebra with the function \texttt{FinCheckQA} (\ref{FinCheckQA}) or the function \texttt{DetermineGrowthQA} (\ref{DetermineGrowthQA}). These functions expect as first argument a list \mbox{\texttt{\slshape F}} of leading terms of a Gr{\"o}bner basis, which can be calculated with the
function \texttt{LMonsNP} (\ref{LMonsNP}) and as second argument the number of symbols (here equal to 2). The function \texttt{DetermineGrowthQA} (\ref{DetermineGrowthQA}) will not only report whether a Gr{\"o}bner basis is finite, but will also
provide information about its growth. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> L:=LMonsNP(GB);
  [ [ 1, 1, 2 ], [ 2, 2, 2, 2 ] ]
  gap> fd:=FinCheckQA(L,2);
  false
  gap> fd:=DetermineGrowthQA(L,2,false);
  "exponential growth"
\end{Verbatim}
 Although the quotient algebra is infinite dimensional, multiplication of two
elements can be carried out by \texttt{MulQA} (\ref{MulQA}). We print three positive powers of $x+y$. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> w := [[[1],[2]],[1,1]];;
  gap> hlp := [[[]],[1]];;
  gap> for i in [3..5] do 
  >   hlp := MulQA(hlp, w, GB);
  >   Print("\n (x+y)^",i," = \n"); 
  >   PrintNP(hlp);
  > od;
  
   (x+y)^3 = 
   y + x 
  
   (x+y)^4 = 
   y^2 + yx + xy + x^2 
  
   (x+y)^5 = 
   y^3 + y^2x + yxy + yx^2 + xy^2 + xyx + x^3 + xy 
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{A commutative quotient algebra of polynomial growth}}\label{Example16}
\logpage{[ "A", 15, 0 ]}
\hyperdef{L}{X78679D7D80CD8822}{}
{
 This example extends \ref{Example06}, a commutative example from Some Tapas of Computer Algebra \cite{CohenCuypersSterk1999}, page 339. 

 The result of the Gr{\"o}bner basis computation should be the union of $\{a,b\}$ and the set of 6 homogeneous binomials (that is, polynomials with two terms)
of degree 2 forcing commuting between $c$, $d$, $e$, and $f$, as before. After computation of the Gr{\"o}bner basis, the quotient algebra
is studied and found to be infinite dimensional of polynomial growth of degree
4. The function \texttt{DetermineGrowthQA} (\ref{DetermineGrowthQA}) is used for this computation. Then part of its Hilbert series is computed. The
function \texttt{HilbertSeriesQA} (\ref{HilbertSeriesQA}) is used for the computations. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 2 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 1 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,2);
  gap> SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 Now define some functions which will help in the construction of relations.
The function \texttt{powermon(i, exp)} will return the monomial $i^{exp}$. The function \texttt{comm(aa, bb)} will return a relation forcing commutativity between its two arguments \texttt{aa} and \texttt{bb}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> powermon := function(base, exp)
  >  local ans,i;
  >  ans := [];
  >  for i in [1..exp] do ans :=  Concatenation(ans,[base]); od;
  >  return ans;
  > end;;
  
  gap> comm := function(aa,bb)
  >   return [[[aa,bb],[bb,aa]],[1,-1]];
  > end;;
\end{Verbatim}
 Now the relations are entered: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p1 := [[[5,1]],[1]];;
  gap> p2 := [[powermon(1,3),[6,1]],[1,1]];;
  gap> p3 := [[powermon(1,9),Concatenation([3],powermon(1,3))],[1,1]];;
  gap> p4 := [[powermon(1,81),Concatenation([3],powermon(1,9)),Concatenation([4],
  > 	powermon(1,3))],[1,1,1]];;
  gap> p5 := [[Concatenation([3],powermon(1,81)),Concatenation([4],powermon(1,9)),
  > 	Concatenation([5],powermon(1,3))],[1,1,1]];;
  gap> p6 := [[powermon(1,27),Concatenation([4],powermon(1,81)),Concatenation([5],
  > 	powermon(1,9)),Concatenation([6],powermon(1,3))],[1,1,1,1]];;
  gap> p7 := [[powermon(2,1),Concatenation([3],powermon(1,27)),Concatenation([5],
  > 	powermon(1,81)),Concatenation([6],powermon(1,9))],[1,1,1,1]];;
  gap> p8 := [[Concatenation([3],powermon(2,1)),Concatenation([4],powermon(1,27)),
  > 	Concatenation([6],powermon(1,81))],[1,1,1]];;
  gap> p9 := [[Concatenation([],powermon(1,1)),Concatenation([4],powermon(2,1)),
  > 	Concatenation([5],powermon(1,27))],[1,1,1]];;
  gap> p10 := [[Concatenation([3],powermon(1,1)),Concatenation([5],powermon(2,1)),
  > 	Concatenation([6],powermon(1,27))],[1,1,1]];;
  gap> p11 := [[Concatenation([4],powermon(1,1)),Concatenation([6],powermon(2,1))],
  > 	[1,1]];;
  gap> p12 := [[Concatenation([],powermon(2,3)),Concatenation([],powermon(2,1))],
  > 	[1,-1]];;
  gap> KI := [p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12];;
  gap> for i in [1..5] do
  >     for j in [i+1..6] do
  >         Add(KI,comm(i,j));
  >     od;
  > od;
\end{Verbatim}
 The relations can be shown with \texttt{PrintNPList} (\ref{PrintNPList}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(KI);
   ea 
   a^3 + fa 
   a^9 + ca^3 
   a^81 + ca^9 + da^3 
   ca^81 + da^9 + ea^3 
   a^27 + da^81 + ea^9 + fa^3 
   b + ca^27 + ea^81 + fa^9 
   cb + da^27 + fa^81 
   a + db + ea^27 
   ca + eb + fa^27 
   da + fb 
   b^3 - b 
   ab - ba 
   ac - ca 
   ad - da 
   ae - ea 
   af - fa 
   bc - cb 
   bd - db 
   be - eb 
   bf - fb 
   cd - dc 
   ce - ec 
   cf - fc 
   de - ed 
   df - fd 
   ef - fe 
\end{Verbatim}
 It is usually easier to use the function \texttt{GP2NP} (\ref{GP2NP}) or the function \texttt{GP2NPList} (\ref{GP2NPList}) to enter relations. Entering the first twelve relations and then converting
them with \texttt{GP2NPList} (\ref{GP2NPList}) is demonstrated in example 6 (\ref{Example06}). More about converting can be read in Section \ref{TransitionFunctions}. 

 The Gr{\"o}bner basis can now be calculated with \texttt{SGrobner} (\ref{SGrobner}) and printed with \texttt{PrintNPList} (\ref{PrintNPList}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := SGrobner(KI);
  #I  number of entered polynomials is 27
  #I  number of polynomials after reduction is 8
  #I  End of phase I
  #I  End of phase II
  #I  List of todo lengths is [ 0 ]
  #I  End of phase III
  #I  G: Cleaning finished, 0 polynomials reduced
  #I  End of phase IV
  #I  The computation took 1224 msecs.
  [ [ [ [ 1 ] ], [ 1 ] ], [ [ [ 2 ] ], [ 1 ] ], 
    [ [ [ 4, 3 ], [ 3, 4 ] ], [ 1, -1 ] ], [ [ [ 5, 3 ], [ 3, 5 ] ], [ 1, -1 ] ]
      , [ [ [ 5, 4 ], [ 4, 5 ] ], [ 1, -1 ] ], 
    [ [ [ 6, 3 ], [ 3, 6 ] ], [ 1, -1 ] ], [ [ [ 6, 4 ], [ 4, 6 ] ], [ 1, -1 ] ]
      , [ [ [ 6, 5 ], [ 5, 6 ] ], [ 1, -1 ] ] ]
  gap> PrintNPList(GB);
   a 
   b 
   dc - cd 
   ec - ce 
   ed - de 
   fc - cf 
   fd - df 
   fe - ef 
\end{Verbatim}
 The growth of the quotient algebra can be studied with \texttt{DetermineGrowthQA} (\ref{DetermineGrowthQA}). The first argument is the list of leading monomials, which can be calculated
with \texttt{LMonsNP} (\ref{LMonsNP}). The second argument is the size of the alphabet. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> L:=LMonsNP(GB);;
  gap> DetermineGrowthQA(L,6,false);
  4
  gap> time;
  0
\end{Verbatim}
 Now compute the first 10 terms of the Hilbert Series with \texttt{HilbertSeriesQA} (\ref{HilbertSeriesQA}) (note that trailing zeroes are removed): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> HilbertSeriesQA(L,6,10);
  [ 1, 4, 10, 20, 35, 56, 84, 120, 165, 220, 286 ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{An algebra over a finite field}}\label{Example17}
\logpage{[ "A", 16, 0 ]}
\hyperdef{L}{X7CE3005580EF632D}{}
{
 A small example over a field other than the rationals, using the conversion
functions from \ref{TransitionFunctions}. The input relations define the symmetric group of degree 3, denoted $S_3$. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 2 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 1 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,2);
  gap> SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 Let \texttt{F} be the field GF(2). The relations can be entered as elements of a free
associative algebra with one \texttt{A} (see  \textbf{Reference: FreeAssociativeAlgebraWithOne}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> F:=GF(2);;
  gap> A:=FreeAssociativeAlgebraWithOne(F,"a","b");
  <algebra-with-one over GF(2), with 2 generators>
  gap> g:=GeneratorsOfAlgebraWithOne(A);
  [ (Z(2)^0)*a, (Z(2)^0)*b ]
\end{Verbatim}
 Enter the relations $\{a^2-1,b^2-1,(ab)^3-1\}$, convert them to NP-form, see Section \ref{NP}, with \texttt{GP2NPList} (\ref{GP2NPList}) and print them with \texttt{PrintNPList} (\ref{PrintNPList}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> KI_GP := [ g[1]^2-g[1]^0, g[2]^2-g[1]^0, (g[1]*g[2])^3-g[1]^0];
  [ (Z(2)^0)*<identity ...>+(Z(2)^0)*a^2, (Z(2)^0)*<identity ...>+(Z(2)^0)*b^2, 
    (Z(2)^0)*<identity ...>+(Z(2)^0)*a*b*a*b*a*b ]
  gap> KI:=GP2NPList(KI_GP);;
  gap> PrintNPList(KI);
   a^2 + Z(2)^0 
   b^2 + Z(2)^0 
   ababab + Z(2)^0 
\end{Verbatim}
 Now calculate the Gr{\"o}bner basis with \texttt{SGrobner} (\ref{SGrobner}) and print it with \texttt{PrintNPList} (\ref{PrintNPList}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB:=SGrobner(KI);;
  #I  number of entered polynomials is 3
  #I  number of polynomials after reduction is 3
  #I  End of phase I
  #I  End of phase II
  #I  length of G =3
  #I  length of todo is 2
  #I  length of G =3
  #I  length of todo is 1
  #I  length of G =3
  #I  length of todo is 0
  #I  List of todo lengths is [ 2, 2, 1, 0 ]
  #I  End of phase III
  #I  G: Cleaning finished, 0 polynomials reduced
  #I  End of phase IV
  #I  The computation took 8 msecs.
  gap> PrintNPList(GB);
   a^2 + Z(2)^0 
   b^2 + Z(2)^0 
   bab + aba 
\end{Verbatim}
 Now calculate the dimension of the quotient algebra with \texttt{DimQA} (\ref{DimQA}) (2 symbols) and a base with \texttt{BaseQA} (\ref{BaseQA}) (2 symbols, 0 for whole base) and print the base. This will give a list of
elements of the group. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> DimQA(GB,2);
  6
  gap> B:=BaseQA(GB,2,0);;
  gap> PrintNPList(B);
   Z(2)^0 
   a 
   b 
   ab 
   ba 
   aba 
\end{Verbatim}
 We can print the Gr{\"o}bner basis and the basis of the quotient algebra,
converted back to GAP polynomials with \texttt{NP2GPList} (\ref{NP2GPList}). The functions used to convert the polynomials also require the algebra as an
argument. The result is useful for further computations in $A$. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> NP2GPList(GB,A);
  [ (Z(2)^0)*a^2+(Z(2)^0)*<identity ...>, (Z(2)^0)*b^2+(Z(2)^0)*<identity ...>, 
    (Z(2)^0)*b*a*b+(Z(2)^0)*a*b*a ]
  gap> NP2GPList(B,A);
  [ (Z(2)^0)*<identity ...>, (Z(2)^0)*a, (Z(2)^0)*b, (Z(2)^0)*a*b, 
    (Z(2)^0)*b*a, (Z(2)^0)*a*b*a ]
\end{Verbatim}
 The matrix of right multiplication with the image of the first variable can be
computed by \texttt{MatrixQA} (\ref{MatrixQA}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> Display(MatrixQA(1,B,GB));
   . 1 . . . .
   1 . . . . .
   . . . . 1 .
   . . . . . 1
   . . 1 . . .
   . . . 1 . .
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{The dihedral group of order 8}}\label{Example18}
\logpage{[ "A", 17, 0 ]}
\hyperdef{L}{X7E4CEC577A18C8ED}{}
{
 In this example (Example 1 from Linton \cite{MR94k:20022}) the two-sided relations give the group algebra of the group with
presentation $\langle a,b \mid a^4=b^2=(ab)^2=1\rangle$, the dihedral group of order 8. It is possible to construct a permutation
module of degree 4, over a field \texttt{k}. In this example \texttt{k} will be the field of rational numbers. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 1 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 1 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,1);
  gap> SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 Now enter the relations as GAP polynomials. It is possible to enter them with
and without module generators. First it is shown how to enter the relations
without using a module. It is possible to enter them with a free associative
algebra with one over the field (the rational numbers) (see also  \textbf{Reference: FreeAssociativeAlgebraWithOne}). For convenience we use the variables \texttt{a} and \texttt{b} for the generators of the algebra and \texttt{e} for the one of the algebra. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> A:=FreeAssociativeAlgebraWithOne(Rationals, "a", "b");
  <algebra-with-one over Rationals, with 2 generators>
  gap> a:=A.a;;b:=A.b;;e:=One(A);;
\end{Verbatim}
 Now the relations are entered: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> twosidrels:=[a^4-e,b^2-e,(a*b)^2-e];;
  gap> prefixrels:=[b-e];;
\end{Verbatim}
 First the relations are converted into NP format, see Section \ref{NP}, after which the function \texttt{SGrobnerModule} (\ref{SGrobnerModule}) is called to calculate a Gr{\"o}bner basis record. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBR:=SGrobnerModule(GP2NPList(prefixrels),GP2NPList(twosidrels));;
  #I  number of entered polynomials is 3
  #I  number of polynomials after reduction is 3
  #I  End of phase I
  #I  End of phase II
  #I  End of phase III
  #I  End of phase IV
  #I  The computation took 8 msecs.
  #I  number of entered polynomials is 7
  #I  number of polynomials after reduction is 7
  #I  End of phase I
  #I  End of phase II
  #I  End of phase III
  #I  End of phase IV
  #I  The computation took 0 msecs.
\end{Verbatim}
 The record GBR has two members: the two-sided relations \texttt{GBR.ts} and the prefix relations \texttt{GBR.p}. It is possible to print these using the function \texttt{PrintNPList} (\ref{PrintNPList}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(GBR.ts);
   b^2 - 1 
   aba - b 
   ba^2 - a^2b 
   bab - a^3 
   a^4 - 1 
   a^3b - ba 
  gap> PrintNPList(GBR.p);
  [ b - 1 ]
  [ a^3 - ab ]
  [ a^2b - a^2 ]
\end{Verbatim}
 It is now possible to calculate the standard basis of the quotient module with
the function \texttt{BaseQM} (\ref{BaseQM}). This function has as arguments the Gr{\"o}bner basis record \texttt{GBR}, the number of generators of the algebra (2), the number of generators of the
module (1), and a variable \texttt{maxno} for returning partial bases (0 means full basis). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> B:=BaseQM(GBR,2,1,0);;
  gap> PrintNPList(B);
  [ 1 ]
  [ a ]
  [ a^2 ]
  [ ab ]
\end{Verbatim}
 It is also possible to use a module with one generator to enter these
relations: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> D:=A^1;;
  gap> gd:=GeneratorsOfLeftModule(D);;
  gap> prefixrelsdom:=[gd[1]*(b-e)];;
\end{Verbatim}
 It is possible to use the two-sided Gr{\"o}bner basis which was already
calculated. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBR:=SGrobnerModule(GP2NPList(prefixrelsdom),GBR.ts);;
  #I  number of entered polynomials is 6
  #I  number of polynomials after reduction is 6
  #I  End of phase I
  #I  End of phase II
  #I  End of phase III
  #I  End of phase IV
  #I  The computation took 4 msecs.
  #I  number of entered polynomials is 7
  #I  number of polynomials after reduction is 7
  #I  End of phase I
  #I  End of phase II
  #I  End of phase III
  #I  End of phase IV
  #I  The computation took 0 msecs.
  gap> PrintNPList(GBR.p);;
  [ b - 1 ]
  [ a^3 - ab ]
  [ a^2b - a^2 ]
  gap> B:=BaseQM(GBR,2,1,0);;
  gap> PrintNPList(B);
  [ 1 ]
  [ a ]
  [ a^2 ]
  [ ab ]
\end{Verbatim}
 To compute the image of right multiplication of the basis element \texttt{B[Length(B)]} of the module with the quotient algebra element corresponding to $ab$ we use the function \texttt{MulQM} (\ref{MulQM}) with arguments \texttt{B[Length(B)]}, \texttt{GB2NP(a*b)}, and \texttt{GBR} We subsequently use \texttt{PrintNP} (\ref{PrintNP}) to display the result as a 1-dimensional vector with an entry from $A$. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> v := MulQM(B[Length(B)],GP2NP(a*b),GBR);
  [ [ [ -1 ] ], [ 1 ] ]
  gap> PrintNP(v);
  [ 1 ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{The dihedral group of order 8 on another module}}\label{Example19}
\logpage{[ "A", 18, 0 ]}
\hyperdef{L}{X83328C357FB33D17}{}
{
 In this example (Example 2 from Linton \cite{MR94k:20022}) the two-sided relations give the group algebra of the group with
presentation $\langle a,b\mid a^4=b^2=(ab)^2=1\rangle$, the dihedral group of order 8. This module relation fixes the all-one vector
of Example \ref{Example18}: $1 + a(1+a+b)$. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 0 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 0 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,0);
  gap> SetInfoLevel(InfoGBNPTime,0);
\end{Verbatim}
 We will enter the relations as GAP polynomials. It is possible to enter these
with and without a module. How to do this is shown in \ref{Example18}. The relations here are entered without a module, since the module is only
one-dimensional. It is possible to enter them using a free associative algebra
with one over the field (the rational numbers) (see also  \textbf{Reference: FreeAssociativeAlgebraWithOne}). For convenience we use the variables \texttt{a} and \texttt{b} for the generators of the algebra and \texttt{e} for the one of the algebra. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> A:=FreeAssociativeAlgebraWithOne(Rationals, "a", "b");
  <algebra-with-one over Rationals, with 2 generators>
  gap> g:=GeneratorsOfAlgebra(A);;
  gap> a:=g[2];;b:=g[3];;e:=g[1];;
\end{Verbatim}
 Now the relations are entered: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> twosidrels:=[a^4-e,b^2-e,(a*b)^2-e];;
  gap> prefrels:=[ b-e, e + a * (e + a + b) ];;
\end{Verbatim}
 First the relations are converted into NP format (see \ref{NP}) after which the function \texttt{SGrobnerModule} (\ref{SGrobnerModule}) is called to calculate a Gr{\"o}bner basis record. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBR:=SGrobnerModule(GP2NPList(prefrels),GP2NPList(twosidrels));;
\end{Verbatim}
 The record GBR has two members: the two-sided relations \texttt{GBR.ts} and the prefix relations \texttt{GBR.p}. It is possible to print these using the function \texttt{PrintNPList} (\ref{PrintNPList}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(GBR.ts);
   b^2 - 1 
   aba - b 
   ba^2 - a^2b 
   bab - a^3 
   a^4 - 1 
   a^3b - ba 
  gap> PrintNPList(GBR.p);
  [ b - 1 ]
  [ ab + a^2 + a + 1 ]
  [ a^3 + a^2 + a + 1 ]
  [ a^2b - a^2 ]
\end{Verbatim}
 It is now possible to calculate the standard basis of the quotient module with
the function \texttt{BaseQM} (\ref{BaseQM}). This function has as arguments the Gr{\"o}bner basis record \texttt{GBR}, the number of generators of the algebra (here it is 2), the number of
generators of the mdoule (here it is 1), and a variable \texttt{maxno} for returning partial bases (0 means full basis). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> B:=BaseQM(GBR,2,1,0);;
  gap> PrintNPList(B);
  [ 1 ]
  [ a ]
  [ a^2 ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{The dihedral group on a non-cyclic module}}\label{Example20}
\logpage{[ "A", 19, 0 ]}
\hyperdef{L}{X85DBF3967C4DF5FE}{}
{
 In this example (Example 3 from Linton \cite{MR94k:20022}), the two-sided relations give the group algebra of the group with
presentation $\langle a,b\mid a^4=b^2=(ab)^2=1\rangle$, the dihedral group of order 8. The module under construction is a non-cyclic
module, obtained by taking two copies of the representation of Example \ref{Example18} and fusing their one-dimensional submodules. 

 Load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 1 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 1 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,1);
  gap> SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 Create the free associative algebra to enter the relations in: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> A:=FreeAssociativeAlgebraWithOne(Rationals, "a", "b");
  <algebra-with-one over Rationals, with 2 generators>
  gap> g:=GeneratorsOfAlgebra(A);;
  gap> a:=g[2];;b:=g[3];;e:=g[1];;
\end{Verbatim}
 Now the relations are entered: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> twosidrels:=[a^4-e,b^2-e,(a*b)^2-e];;
  gap> D:=A^2;;
  gap> y:=GeneratorsOfLeftModule(D);;
  gap> modrels:=[y[1]*b-y[1], y[2]*b-y[2], y[1]+y[1]*a*(e+a+b) -y[2]-y[2]*a*(e+a+b)];;
\end{Verbatim}
 First the relations are converted into NP format (see \ref{NP}) with the function \texttt{GP2NPList} (\ref{GP2NPList}). They are printed in raw form and subsequently in a more legible format. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> modrelsNP:=GP2NPList(modrels);
  [ [ [ [ -1, 2 ], [ -1 ] ], [ 1, -1 ] ], [ [ [ -2, 2 ], [ -2 ] ], [ 1, -1 ] ], 
    [ [ [ -1, 1, 2 ], [ -1, 1, 1 ], [ -2, 1, 2 ], [ -2, 1, 1 ], [ -1, 1 ], 
            [ -2, 1 ], [ -1 ], [ -2 ] ], [ 1, 1, -1, -1, 1, -1, 1, -1 ] ] ]
  gap> PrintNPList(modrelsNP);
  [ b - 1 , 0]
  [ 0, b - 1 ]
  [ ab + a^2 + a + 1 , - ab - a^2 - a - 1 ]
\end{Verbatim}
 Next the function \texttt{SGrobnerModule} (\ref{SGrobnerModule}) is called to calculate a Gr{\"o}bner basis record (see \ref{GBR}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBR:=SGrobnerModule(modrelsNP,GP2NPList(twosidrels));;
  #I  number of entered polynomials is 3
  #I  number of polynomials after reduction is 3
  #I  End of phase I
  #I  End of phase II
  #I  End of phase III
  #I  End of phase IV
  #I  The computation took 8 msecs.
  #I  number of entered polynomials is 9
  #I  number of polynomials after reduction is 9
  #I  End of phase I
  #I  End of phase II
  #I  End of phase III
  #I  End of phase IV
  #I  The computation took 4 msecs.
\end{Verbatim}
 The record \texttt{GBR} has two members: the two-sided relations \texttt{GBR.ts} and the prefix relations \texttt{GBR.p}. It is possible to print these using the function \texttt{PrintNPList} (\ref{PrintNPList}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(GBR.ts);
   b^2 - 1 
   aba - b 
   ba^2 - a^2b 
   bab - a^3 
   a^4 - 1 
   a^3b - ba 
  gap> PrintNPList(GBR.p);
  [ 0, b - 1 ]
  [ b - 1 , 0]
  [ ab + a^2 + a + 1 , - ab - a^2 - a - 1 ]
  [ 0, a^3 - ab ]
  [ 0, a^2b - a^2 ]
  [ a^3 + a^2 + a + 1 , - ab - a^2 - a - 1 ]
  [ a^2b - a^2 , 0]
\end{Verbatim}
 It is now possible to calculate the standard basis of the quotient module with
the function \texttt{BaseQM} (\ref{BaseQM}). This function has as arguments the Gr{\"o}bner basis record \texttt{GBR}, the number of generators of the algebra (in this case 2), the number of
generators of the module (in this case 2), and a variable \texttt{maxno} for returning partial bases (0 means full basis). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> B:=BaseQM(GBR,2,2,0);;
  gap> PrintNPList(B);
  [ 0, 1 ]
  [ 1 , 0]
  [ 0, a ]
  [ a , 0]
  [ 0, a^2 ]
  [ 0, ab ]
  [ a^2 , 0]
\end{Verbatim}
 It is also possible to convert each member of the list \texttt{B} of polynomials in NP form to GAP polynomials to do further calculations within
the algebra or module. This can be done with the function \texttt{NP2GPList} (\ref{NP2GPList}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> NP2GPList(B,D);
  [ [ <zero> of ..., (1)*<identity ...> ], [ (1)*<identity ...>, <zero> of ... ]
      , [ <zero> of ..., (1)*a ], [ (1)*a, <zero> of ... ], 
    [ <zero> of ..., (1)*a^2 ], [ <zero> of ..., (1)*a*b ], 
    [ (1)*a^2, <zero> of ... ] ]
\end{Verbatim}
 Individual GAP polynomials can be obtained from polynomials in NP form with
the function \texttt{NP2GP} (\ref{NP2GP}). This also holds for elements of the free module \texttt{D} in NP form. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> Display(NP2GP(B[Length(B)],D));
  [ (1)*a^2, <zero> of ... ]
\end{Verbatim}
 Next we write down the matrices for the right action of the generators on the
module by means of \texttt{MatrixQA} (\ref{MatrixQA}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> Display(MatrixQA(1,B,GBR));
  [ [   0,   0,   1,   0,   0,   0,   0 ],
    [   0,   0,   0,   1,   0,   0,   0 ],
    [   0,   0,   0,   0,   1,   0,   0 ],
    [   0,   0,   0,   0,   0,   0,   1 ],
    [   0,   0,   0,   0,   0,   1,   0 ],
    [   1,   0,   0,   0,   0,   0,   0 ],
    [   1,  -1,   1,  -1,   1,   1,  -1 ] ]
  gap> Display(MatrixQA(2,B,GBR)); 
  [ [   1,   0,   0,   0,   0,   0,   0 ],
    [   0,   1,   0,   0,   0,   0,   0 ],
    [   0,   0,   0,   0,   0,   1,   0 ],
    [   1,  -1,   1,  -1,   1,   1,  -1 ],
    [   0,   0,   0,   0,   1,   0,   0 ],
    [   0,   0,   1,   0,   0,   0,   0 ],
    [   0,   0,   0,   0,   0,   0,   1 ] ]
\end{Verbatim}
 In order to compute the image of the vector $2y[1]+3y[2]$ of the two standard generators of the module under the action of the element $aab$, we use \texttt{StrongNormalFormNPM} (\ref{StrongNormalFormNPM}). Its first argument will be the vector and its second the Gr{\"o}bner basis.
The transformation \texttt{GP2NP} (\ref{GP2NP}) to the NP format needs to be applied to the vector before it can be used as an
argument. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> v:=StrongNormalFormNPM(GP2NP((y[1]*2+y[2]*3)*a*a*b), GBR);;
  gap> PrintNP(v);
  [ 2a^2 , 3a^2 ]
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{The icosahedral group}}\label{Example04}
\logpage{[ "A", 20, 0 ]}
\hyperdef{L}{X78FCAC347D9D607E}{}
{
  In this example the two-sided relations give the group algebra of the group
with presentation $\langle a,b,c \mid a^2=b^2=c^2=(ab)^3=(bc)^5=(ac)^2=1\rangle$, the icosahedral group of order 120. This is the Coxeter group of type H$_3$. The module under construction is a 3-dimensional reflection representation, 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 1 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 1 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,1);
  gap> SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 Create the field containing the golden ratio \texttt{tau}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> x := Indeterminate(Rationals,"x");
  x
  gap> p := x^2+ x-1;
  x^2+x-1
  gap> K := AlgebraicExtension(Rationals,p);
  <algebraic extension over the Rationals of degree 2>
  gap> tau:=RootOfDefiningPolynomial(K);
  (a)
\end{Verbatim}
 Create the free algebra with three generators over this field: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> A:=FreeAssociativeAlgebraWithOne(K, "a", "b", "c");
  <algebra-with-one over <algebraic extension over the Rationals of degree 
  2>, with 3 generators>
  gap> e:=One(A);; a:=A.a;; b:=A.b;; c:=A.c;;
\end{Verbatim}
 The ideal for a quotient of the icosahedral group algebra over this field, in
which \texttt{b}$*$\texttt{c} has a quadratic minimal polynomial involving \texttt{tau}: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> #(b*c)^2-tau*b*c+e
  gap> Irels:=[a^2-e,b^2-e,c^2-e,a*b*a-b*a*b,((b*c)^2-tau*b*c+e)*(b*c-e),a*c-c*a];
  [ (!-1)*<identity ...>+(!1)*a^2, (!-1)*<identity ...>+(!1)*b^2, 
    (!-1)*<identity ...>+(!1)*c^2, (!1)*a*b*a+(!-1)*b*a*b, 
    (!-1)*<identity ...>+((1+a))*b*c+((-1-1*a))*b*c*b*c+(!1)*b*c*b*c*b*c, 
    (!1)*a*c+(!-1)*c*a ]
\end{Verbatim}
 We now give module relations. The first two describe group elements of a
vector stabilizer, the third forces the central element $(abc)^5$ to be nontrivial. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> Mrels:=[b*c-e,b-e,(a*b*c)^5+e];;
\end{Verbatim}
 First the relations are converted into NP format (see \ref{NP}) with the function \texttt{GP2NPList} (\ref{GP2NPList}). Next the function \texttt{SGrobnerModule} (\ref{SGrobnerModule}) is called to calculate a Gr{\"o}bner basis record (see \ref{GBR}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBR:=SGrobnerModule(GP2NPList(Mrels),GP2NPList(Irels));;
  #I  number of entered polynomials is 6
  #I  number of polynomials after reduction is 6
  #I  End of phase I
  #I  End of phase II
  #I  End of phase III
  #I  End of phase IV
  #I  The computation took 28 msecs.
  #I  number of entered polynomials is 12
  #I  number of polynomials after reduction is 12
  #I  End of phase I
  #I  End of phase II
  #I  End of phase III
  #I  End of phase IV
  #I  The computation took 136 msecs.
  gap> PrintNPList(GBR.ts);;
   a^2 + !-1 
   b^2 + !-1 
   ca + !-1ac 
   c^2 + !-1 
   bab + !-1aba 
   cbc + !-1bcb + (-1-1*a)c + (1+a)b 
   bcba + !-1acba + !-1abcb + abac + cb + !-1bc + (-2-1*a)ba + (2+a)ab 
   cbac + !-1acba + !-1abcb + abac + cb + !-1bc + !-1ba + (-1-1*a)ac + (2+a)ab 
   bacba + abacb + !-1cba + !-1bcb + !-1abc + (-2-1*a)aba + c + (2+a)a 
  gap> PrintNPList(GBR.p);;
  [ b + !-1 ]
  [ c + !-1 ]
  [ ac + !-1a ]
  [ aba + !-1ab ]
  [ abc + ab + (-1*a)a + (-1*a) ]
\end{Verbatim}
 It is now possible to calculate the basis of the quotient algebra with the
function \texttt{BaseQM} (\ref{BaseQM}). This function has as arguments the Gr{\"o}bner basis record \texttt{GBR}, the number of generators of the algebra (in this case 3), the number of
generators of the free module in which the vectors are chosen (in this case
1), and a variable \texttt{maxno} for returning partial quotient algebras (0 means full basis). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> B:=BaseQM(GBR,3,1,0);;
  gap> PrintNPList(B);
  [ !1 ]
  [ a ]
  [ ab ]
\end{Verbatim}
 Calculate the dimension of the quotient algebra with the function \texttt{DimQM} (\ref{DimQM}). This function has as arguments the Gr{\"o}bner basis record \texttt{GBR}, the number of generators of the algebra (in this case 3) and the number of
generators of the module (in this case 1). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> DimQM(GBR,3,1);
  3
\end{Verbatim}
 Next we write down the matrices for the right action of the generators on the
module by means of \texttt{MatrixQA} (\ref{MatrixQA}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> aa := MatrixQA(1,B,GBR);;
  gap> Display(aa);
  [ [  !0,  !1,  !0 ],
    [  !1,  !0,  !0 ],
    [  !0,  !0,  !1 ] ]
  gap> bb := MatrixQA(2,B,GBR);;
  gap> Display(bb);
  [ [  !1,  !0,  !0 ],
    [  !0,  !0,  !1 ],
    [  !0,  !1,  !0 ] ]
  gap> cc := MatrixQA(3,B,GBR);;
  gap> Display(cc);
  [ [   !1,   !0,   !0 ],
    [   !0,   !1,   !0 ],
    [  (a),  (a),  !-1 ] ]
\end{Verbatim}
 Finally we check the defining relations for the icosahedral group on the three
new matrix generators. This can be done by verifying if the result is equal to
the identity matrix or with the function \texttt{IsOne} (\textbf{Reference: IsOne}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> ee := IdentityMat(3,K);;
  gap> Display(ee);
  [ [  !1,  !0,  !0 ],
    [  !0,  !1,  !0 ],
    [  !0,  !0,  !1 ] ]
  gap> aa^2 = ee;
  true
  gap> IsOne(aa^2);
  true
  gap> IsOne(bb^2);
  true
  gap> IsOne(cc^2);
  true
  gap> IsOne((aa*bb)^3);
  true
  gap> IsOne((aa*cc)^2);
  true
  gap> IsOne((bb*cc)^5);
  true
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{The symmetric inverse monoid for a set of size four}}\label{Example21}
\logpage{[ "A", 21, 0 ]}
\hyperdef{L}{X780C4B777FEA9080}{}
{
 The algebra we will consider is from Example 4 from Linton \cite{MR94k:20022}. Its monomials form the symmetric inverse monoid, that is, the monoid of all
partial bijections on a given set, for a set of size four. The presentation is $\langle s_1,s_2,s_3,e\mid s_i^2=(s_1s_2)^3=(s_2s_3)^3=(s_1s_3)^2=1, e^2=e,
s_1e=es_1,s_2e=es_2,es_3e=(es_3)^2=(s_3e)^2\rangle$. The dimension of the monoid algebra is 209. The monoid has a natural
representation of degree 4 by means of partial permutation matrices, which can
be obtained by taking prefix relations $\{e,s_1-1, s_2-1, s_3e-s_3\}$. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 1 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 1 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,1);
  gap> SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 Now enter the relations as GAP polynomials. The module is one dimensional so
it is possible to enter it with and without a module. In Example 18 (\ref{Example18}) both ways are shown. Here the relations will be entered without a module,
with a free associative algebra with one over the field (the rational numbers)
(see also  \textbf{Reference: FreeAssociativeAlgebraWithOne}). For convenience we use the variables \texttt{s1}, \texttt{s2}, \texttt{s3}, and \texttt{e} for the generators of the algebra, and \texttt{o} for the identity element of the algebra. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> A:=FreeAssociativeAlgebraWithOne(Rationals, "s1", "s2", "s3", "e");
  <algebra-with-one over Rationals, with 4 generators>
  gap> g:=GeneratorsOfAlgebra(A);;
  gap> s1:=g[2];;s2:=g[3];;s3:=g[4];;e:=g[5];;o:=g[1];;
\end{Verbatim}
 It is possible to print symbols like they are printed in the algebra \texttt{A} with the function \texttt{GBNP.ConfigPrint} (\ref{GBNP.ConfigPrint}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBNP.ConfigPrint(A);
\end{Verbatim}
 Now the relations are entered: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> twosidrels:=[s1^2-o,s2^2-o,s3^2-o,(s1*s2)^3-o,(s2*s3)^3-o,(s1*s3)^2-o,
  > 	e^2-e,s1*e-e*s1,s2*e-e*s2,e*s3*e-(e*s3)^2,e*s3*e-(s3*e)^2];
  [ (-1)*<identity ...>+(1)*s1^2, (-1)*<identity ...>+(1)*s2^2, 
    (-1)*<identity ...>+(1)*s3^2, (-1)*<identity ...>+(1)*s1*s2*s1*s2*s1*s2, 
    (-1)*<identity ...>+(1)*s2*s3*s2*s3*s2*s3, 
    (-1)*<identity ...>+(1)*s1*s3*s1*s3, (-1)*e+(1)*e^2, (1)*s1*e+(-1)*e*s1, 
    (1)*s2*e+(-1)*e*s2, (1)*e*s3*e+(-1)*e*s3*e*s3, (1)*e*s3*e+(-1)*s3*e*s3*e ]
  gap> prefixrels:=[e,s1-o,s2-o,s3*e-s3];
  [ (1)*e, (-1)*<identity ...>+(1)*s1, (-1)*<identity ...>+(1)*s2, 
    (-1)*s3+(1)*s3*e ]
\end{Verbatim}
 First the relations are converted into NP format (see \ref{NP}) and next the function \texttt{SGrobnerModule} (\ref{SGrobnerModule}) is called to calculate a Gr{\"o}bner basis record. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBR:=SGrobnerModule(GP2NPList(prefixrels),GP2NPList(twosidrels));;
  #I  number of entered polynomials is 11
  #I  number of polynomials after reduction is 11
  #I  End of phase I
  #I  End of phase II
  #I  End of phase III
  #I  End of phase IV
  #I  The computation took 36 msecs.
  #I  number of entered polynomials is 42
  #I  number of polynomials after reduction is 42
  #I  End of phase I
  #I  End of phase II
  #I  End of phase III
  #I  End of phase IV
  #I  The computation took 24 msecs.
\end{Verbatim}
 The record GBR has two members: the two-sided relations \texttt{GBR.ts} and the prefix relations \texttt{GBR.p}. We print these using the function \texttt{PrintNPList} (\ref{PrintNPList}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(GBR.ts);
   s1^2 - 1 
   s2^2 - 1 
   s3s1 - s1s3 
   s3^2 - 1 
   es1 - s1e 
   es2 - s2e 
   e^2 - e 
   s2s1s2 - s1s2s1 
   s3s2s3 - s2s3s2 
   s3s2s1s3 - s2s3s2s1 
   s3es3e - es3e 
   es3es3 - es3e 
   s3es3s2e - es3s2e 
   s2s3s2es3e - s3s2es3e 
   s3es3s2s1e - es3s2s1e 
   es3s2es3s2 - es3s2es3 
   s2s3s2s1es3e - s3s2s1es3e 
   s2s3s2es3s2e - s3s2es3s2e 
   s2es3s2es3e - es3s2es3e 
   s1s2s1s3s2es3e - s2s1s3s2es3e 
   s2s3s2s1es3s2e - s3s2s1es3s2e 
   s2s3s2es3s2s1e - s3s2es3s2s1e 
   s2es3s2s1es3e - es3s2s1es3e 
   es3s2s1es3s2s1 - es3s2s1es3s2 
   s1s2s1s3s2s1es3e - s2s1s3s2s1es3e 
   s1s2s1s3s2es3s2e - s2s1s3s2es3s2e 
   s1s2s1es3s2es3e - s2s1es3s2es3e 
   s2s3s2s1es3s2s1e - s3s2s1es3s2s1e 
   s2es3s2s1es3s2e - es3s2s1es3s2e 
   s1s2s1s3s2s1es3s2e - s2s1s3s2s1es3s2e 
   s1s2s1s3s2es3s2s1e - s2s1s3s2es3s2s1e 
   s1s2s1es3s2s1es3e - s2s1es3s2s1es3e 
   s1s3s2s1es3s2es3e - s3s2s1es3s2es3e 
   s1s2s1s3s2s1es3s2s1e - s2s1s3s2s1es3s2s1e 
   s1s2s1es3s2s1es3s2e - s2s1es3s2s1es3s2e 
   s1s3s2s1es3s2s1es3e - s3s2s1es3s2s1es3e 
   s1es3s2s1es3s2es3e - es3s2s1es3s2es3e 
   s1s3s2s1es3s2s1es3s2e - s3s2s1es3s2s1es3s2e 
  gap> PrintNPList(GBR.p);
  [ s1 - 1 ]
  [ s2 - 1 ]
  [ e ]
  [ s3e - s3 ]
  [ s3s2e - s3s2 ]
  [ s3s2s1e - s3s2s1 ]
\end{Verbatim}
 It is now possible to calculate the standard basis of the quotient module with
the function \texttt{BaseQM} (\ref{BaseQM}). This function has as arguments the Gr{\"o}bner basis record \texttt{GBR}, the number of generators of the algebra (here this is 4), the number of
generators of the module (here this is 1), and a variable \texttt{maxno} for returning partial bases (0 means full basis). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> B:=BaseQM(GBR,4,1,0);;
  gap> PrintNPList(B);
  [ 1 ]
  [ s3 ]
  [ s3s2 ]
  [ s3s2s1 ]
\end{Verbatim}
 Next we write down the matrices for the right action of the generators on the
module. First by means of the list command \texttt{MatricesQA} (\ref{MatricesQA}), next one by one by means of \texttt{MatrixQA} (\ref{MatrixQA}) within a loop. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> MatricesQA(4,B,GBR);
  [ [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 0, 1 ], [ 0, 0, 1, 0 ] ], 
    [ [ 1, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 0, 1 ] ], 
    [ [ 0, 1, 0, 0 ], [ 1, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ], 
    [ [ 0, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ] ]
  gap> for i in [1..4] do 
  >   Display(MatrixQA(i,B,GBR)); Print("\n");
  > od;
  [ [  1,  0,  0,  0 ],
    [  0,  1,  0,  0 ],
    [  0,  0,  0,  1 ],
    [  0,  0,  1,  0 ] ]
  
  [ [  1,  0,  0,  0 ],
    [  0,  0,  1,  0 ],
    [  0,  1,  0,  0 ],
    [  0,  0,  0,  1 ] ]
  
  [ [  0,  1,  0,  0 ],
    [  1,  0,  0,  0 ],
    [  0,  0,  1,  0 ],
    [  0,  0,  0,  1 ] ]
  
  [ [  0,  0,  0,  0 ],
    [  0,  1,  0,  0 ],
    [  0,  0,  1,  0 ],
    [  0,  0,  0,  1 ] ]
  
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{A module of the Hecke algebra of type A$_3$ over GF(3)}}\label{Example22}
\logpage{[ "A", 22, 0 ]}
\hyperdef{L}{X84C07DC479FBBCD5}{}
{
 This example is an extension of Example 5 from Linton, \cite{MR94k:20022}. It concerns the Hecke Algebra of type A$_3$. By reducing mod 3 but without evaluating at $q=1$ it is possible to obtain the following representation of the Hecke algebra of
type A$_3$ over GF(3): $\langle x, y, z\mid x^2+(1-q)*x-q,y^2+(1-q)*y-q,z^2+(1-q)*z-q,y*x*y-x*y*x,
z*y*z-y*z*y, z*x-x*z\rangle$. It has a natural representation of the same dimension as the Lie algebra of
type A$_3$, namely 4. This representation can be obtained with the module relations $\{x+1,y+1\}$. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 1 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 1 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,1);
  gap> SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 Now enter the relations as GAP polynomials. The module is one dimensional so
it is possible to enter it with and without a module. Both are used in Example \ref{Example18}. Here the relations will be entered without using a module. First a free
associative algebra with one is created over the field (GF(3)) (see also  \textbf{Reference: FreeAssociativeAlgebraWithOne}). For convenience we use the variables \texttt{a} and \texttt{b} for the generators of the algebra and \texttt{e} for the one of the algebra. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> q:=Indeterminate(GF(3),"q");
  q
  gap> A:=FreeAssociativeAlgebraWithOne(Field(q), "x", "y", "z");;
  gap> g:=GeneratorsOfAlgebra(A);;
  gap> x:=g[2];;y:=g[3];;z:=g[4];;e:=g[1];;q:=q*e;;
\end{Verbatim}
 In order to print the variables like they are printed in the algebra \texttt{A} with the function \texttt{GBNP.ConfigPrint} (\ref{GBNP.ConfigPrint}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBNP.ConfigPrint(A);
\end{Verbatim}
 Now the relations are entered: 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> twosidrels:=[x^2+(e-q)*x-q,y^2+(e-q)*y-q,z^2+(e-q)*z-q,
  >   y*x*y-x*y*x,z*y*z-y*z*y,z*x-x*z];
  [ (-q)*<identity ...>+(-q+Z(3)^0)*x+(Z(3)^0)*x^2, 
    (-q)*<identity ...>+(-q+Z(3)^0)*y+(Z(3)^0)*y^2, 
    (-q)*<identity ...>+(-q+Z(3)^0)*z+(Z(3)^0)*z^2, 
    (-Z(3)^0)*x*y*x+(Z(3)^0)*y*x*y, (-Z(3)^0)*y*z*y+(Z(3)^0)*z*y*z, 
    (-Z(3)^0)*x*z+(Z(3)^0)*z*x ]
  gap> prefixrels:=[x+e,y+e];
  [ (Z(3)^0)*<identity ...>+(Z(3)^0)*x, (Z(3)^0)*<identity ...>+(Z(3)^0)*y ]
\end{Verbatim}
 First the relations are converted into NP format (see \ref{NP}) after which the function \texttt{SGrobnerModule} (\ref{SGrobnerModule}) is called to calculate a Gr{\"o}bner basis record. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBR:=SGrobnerModule(GP2NPList(prefixrels),GP2NPList(twosidrels));;
  #I  number of entered polynomials is 6
  #I  number of polynomials after reduction is 6
  #I  End of phase I
  #I  End of phase II
  #I  End of phase III
  #I  End of phase IV
  #I  The computation took 16 msecs.
  #I  number of entered polynomials is 9
  #I  number of polynomials after reduction is 9
  #I  End of phase I
  #I  End of phase II
  #I  End of phase III
  #I  End of phase IV
  #I  The computation took 8 msecs.
\end{Verbatim}
 The record GBR has three members: the two-sided relations \texttt{GBR.ts}, the prefix relations \texttt{GBR.p}, and the number \texttt{GBR.pg} of generators of the free module. It is possible to print the first two using
the function \texttt{PrintNPList} (\ref{PrintNPList}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPList(GBR.ts);
   x^2 + -q+Z(3)^0x + -q 
   y^2 + -q+Z(3)^0y + -q 
   zx + -Z(3)^0xz 
   z^2 + -q+Z(3)^0z + -q 
   yxy + -Z(3)^0xyx 
   zyz + -Z(3)^0yzy 
   zyxz + -Z(3)^0yzyx 
  gap> PrintNPList(GBR.p);
  [ x + Z(3)^0 ]
  [ y + Z(3)^0 ]
\end{Verbatim}
 It is now possible to calculate the standard basis of the quotient module with
the function \texttt{BaseQM} (\ref{BaseQM}). This function has as arguments the Gr{\"o}bner basis record \texttt{GBR}, the number of generators of the algebra (here this is 3), the number of
generators of the module (here this is 1), and a variable \texttt{maxno} for returning partial bases (0 means full basis). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> B:=BaseQM(GBR,3,1,0);;
  gap> PrintNPList(B);
  [ Z(3)^0 ]
  [ z ]
  [ zy ]
  [ zyx ]
\end{Verbatim}
 Next we write down the matrices for the right action of the generators on the
module, by means of the command \texttt{MatricesQA} (\ref{MatricesQA}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> MM := MatricesQA(3,B,GBR);;
  gap> for i in [1..Length(MM)] do 
  > Display(MM[i]); Print("\n"); 
  > od;
  [ [   -Z(3)^0,    0*Z(3),    0*Z(3),    0*Z(3) ],
    [    0*Z(3),   -Z(3)^0,    0*Z(3),    0*Z(3) ],
    [    0*Z(3),    0*Z(3),    0*Z(3),    Z(3)^0 ],
    [    0*Z(3),    0*Z(3),         q,  q-Z(3)^0 ] ]
  
  [ [   -Z(3)^0,    0*Z(3),    0*Z(3),    0*Z(3) ],
    [    0*Z(3),    0*Z(3),    Z(3)^0,    0*Z(3) ],
    [    0*Z(3),         q,  q-Z(3)^0,    0*Z(3) ],
    [    0*Z(3),    0*Z(3),    0*Z(3),   -Z(3)^0 ] ]
  
  [ [    0*Z(3),    Z(3)^0,    0*Z(3),    0*Z(3) ],
    [         q,  q-Z(3)^0,    0*Z(3),    0*Z(3) ],
    [    0*Z(3),    0*Z(3),   -Z(3)^0,    0*Z(3) ],
    [    0*Z(3),    0*Z(3),    0*Z(3),   -Z(3)^0 ] ]
  
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Generalized Temperley-Lieb algebras}}\label{Example23}
\logpage{[ "A", 23, 0 ]}
\hyperdef{L}{X78C01D1987FEF3FE}{}
{
 This example shows how the dimension of a Generalized Temperley-Lieb Algebra
of type A, D, or E can be calculated. For $\textrm{A}_{n-1}$ this is the usual Temperley-Lieb Algebra on $n$ strands with dimension $\textrm{dim TL}(A_{n-1})={{2n \choose n}}/{(n+1)}$. For more information see \cite{Graham1995}. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 0 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 1 (for more information about timing; see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,0);
  gap> SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 The relations are generated automatically from the Coxeter diagram. This
example can be easily adapted by specifying the number of points and the set
of edges describing another Coxeter diagram. First enter the number of points, \texttt{numpoints}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> numpoints:=8;
  8
\end{Verbatim}
 Now define some edges describing the diagrams of $\textrm{E}_n$, (these can be easily extended). In this example the dimension of the
Generalized Temperley-Lieb algebra of type $\textrm{E}_8$ will be calculated. For $\textrm{A}_{1\ldots 10}$ the command 

 \texttt{edges:=[[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10]];} 

 can be used. For $\textrm{D}_{1\ldots 10}$ the command 

 \texttt{edges:=[[1,3],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10]];} can 

 be used. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> edges:=[[1,3],[2,4],[3,4],[4,5],[5,6],[6,7],[7,8]]; # for E6..8
  [ [ 1, 3 ], [ 2, 4 ], [ 3, 4 ], [ 4, 5 ], [ 5, 6 ], [ 6, 7 ], [ 7, 8 ] ]
\end{Verbatim}
 Now enter the relations as GAP polynomials. First a free associative algebra
with identity element is created over the Rationals (see also  \textbf{Reference: FreeAssociativeAlgebraWithOne}). For convenience the generators are stored in \texttt{gens}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> A:=FreeAssociativeAlgebraWithOne(Rationals,numpoints,"e");;
  gap> e := GeneratorsOfAlgebraWithOne(A);
  [ (1)*e.1, (1)*e.2, (1)*e.3, (1)*e.4, (1)*e.5, (1)*e.6, (1)*e.7, (1)*e.8 ]
\end{Verbatim}
 It is possible to print symbols like they are printed in the algebra \texttt{A} with the function \texttt{GBNP.ConfigPrint} (\ref{GBNP.ConfigPrint}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBNP.ConfigPrint(A);
\end{Verbatim}
 Now the relations are generated automatically. For this we need to make sure
the edges are sorted and converted to a set. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> edges:=Set(edges, x->SortedList(x));
  [ [ 1, 3 ], [ 2, 4 ], [ 3, 4 ], [ 4, 5 ], [ 5, 6 ], [ 6, 7 ], [ 7, 8 ] ]
\end{Verbatim}
 Now the relations can be generated. The relations are $e_i*e_i=e_i$, for all $i$ and $e_i*e_j*e_i=e_i$ for all $i$,$j$ that are connected in the Coxeter diagram and $e_i*e_j=e_j*e_i$ for all $i$, $j$ that are not connected in the Coxeter diagram. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> rels:=[];;
  gap> for i in [1..numpoints] do
  >   for j in [1..numpoints] do
  >     if (i=j) then
  >       # if i=j then add e.i*e.i=e.i
  >       Add(rels, e[i]*e[i]-e[i]);
  >     elif ([i,j] in edges) or ([j,i] in edges) then
  >       # if {i,j} is an edge then add e.i*e.j*e.i=e.i 
  >       Add(rels, e[i]*e[j]*e[i]- e[i]);
  >     else
  >       # if {i,j} is not an edge then add e.i*e.j=e.j*e.i 
  >       # (note: this causes double rules, but that's ok)
  >       Add(rels, e[i]*e[j]- e[j]*e[i]);
  >     fi;
  >   od;
  > od;
\end{Verbatim}
 Then the relations are converted into NP format (see \ref{NP}) after which the function \texttt{SGrobner} (\ref{SGrobner}) is called to calculate a Gr{\"o}bner basis. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> relsNP:=GP2NPList(rels);;
  gap> GB:=SGrobner(relsNP);;
  #I  The computation took 396 msecs.
\end{Verbatim}
 It is now possible to calculate the dimension of the quotient algebra with the
function \texttt{DimQA} (\ref{DimQA}). This function has as arguments the Gr{\"o}bner basis \texttt{GB} and the number of generators of the algebra (here this is \texttt{numpoints}). To get the full basis the function \texttt{BaseQA} (\ref{BaseQA}) can be used. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> DimQA(GB,numpoints);
  10846
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{The universal enveloping algebra of a Lie algebra}}\label{Example12}
\logpage{[ "A", 24, 0 ]}
\hyperdef{L}{X85A9CEF087F3936B}{}
{
 Consider the Lie algebra with generators $e$, $f$ and $h$, and relations $[e,f]=h$, $[e,h]=-2e$, $[f,h]=2f$. This is the well-known Lie algebra of type A$_1$. We construct the corresponding universal enveloping algebra of this Lie
algebra and show how one can prove that $f^2$ belongs to the ideal generated by $e^2$ in that associative algebra. The example is from Knopper's report \cite{Knopper2004}. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 0 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 0 (for more information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP");
  -----------------------------------------------------------------------------
  Loading  GBNP 1.0.1 (Non-commutative Grbner bases)
  by A.M. Cohen (http://www.win.tue.nl/~amc) and
     J.W. Knopper (J.W.Knopper@tue.nl).
  -----------------------------------------------------------------------------
  true
  
  gap> SetInfoLevel(InfoGBNP,0);
  gap> SetInfoLevel(InfoGBNPTime,0);
\end{Verbatim}
 Then define the algebra and enter the relations as polynomials in GAP. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> A:=FreeAssociativeAlgebraWithOne(Rationals, "e", "f", "h");
  <algebra-with-one over Rationals, with 3 generators>
  gap> e:=A.e;; f:=A.f;; h:=A.h;; o:=One(A);;
  gap> uerels:=[f*e-e*f+h,h*e-e*h-2*e,h*f-f*h+2*f];
  [ (1)*h+(-1)*e*f+(1)*f*e, (-2)*e+(-1)*e*h+(1)*h*e, (2)*f+(-1)*f*h+(1)*h*f ]
\end{Verbatim}
 The relations can be converted to NP format (see \ref{NP}) with the function \texttt{GP2NPList} (\ref{GP2NPList}) and can be subsequently displayed with \texttt{PrintNPList} (\ref{PrintNPList}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> uerelsNP:=GP2NPList(uerels);;
  gap> PrintNPList(uerelsNP);
   ba - ab + c 
   ca - ac - 2a 
   cb - bc + 2b 
\end{Verbatim}
 Now configure printing in such a way that this algebra is used with the
function \texttt{GBNP.ConfigPrint} (\ref{GBNP.ConfigPrint}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBNP.ConfigPrint(A);
\end{Verbatim}
 The set is actually a Gr{\"o}bner basis, as can be verified by calculating the
Gr{\"o}bner basis with \texttt{SGrobner} (\ref{SGrobner}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB:=SGrobner(uerelsNP);;
  gap> PrintNPList(GB);
   fe - ef + h 
   he - eh - 2e 
   hf - fh + 2f 
\end{Verbatim}
 Determine whether the quotient algebra is finite dimensional by means of \texttt{FinCheckQA} (\ref{FinCheckQA}), with arguments the leading monomials of \texttt{GB} and 3, the number of variables involved. The leading monomials of \texttt{GB} are found by invoking \texttt{LMonsNP} (\ref{LMonsNP}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> F:=LMonsNP(GB);
  [ [ 2, 1 ], [ 3, 1 ], [ 3, 2 ] ]
  gap> FinCheckQA(F,3);
  false
\end{Verbatim}
 Adding the relation $e^2=0$ results in a finite quotient algebra. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> extendedrels:=[f*e-e*f+h,h*e-e*h-2*e,h*f-f*h+2*f,e^2];
  [ (1)*h+(-1)*e*f+(1)*f*e, (-2)*e+(-1)*e*h+(1)*h*e, (2)*f+(-1)*f*h+(1)*h*f, 
    (1)*e^2 ]
  gap> extendedrelsNP:=GP2NPList(extendedrels);;
\end{Verbatim}
 With the function \texttt{SGrobnerTrace} (\ref{SGrobnerTrace}) it is possible to calculate a Gr{\"o}bner basis with trace information. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB:=SGrobnerTrace(extendedrelsNP);;
\end{Verbatim}
 The Gr{\"o}bner basis can now be displayed with \texttt{PrintNPListTrace} (\ref{PrintNPListTrace}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPListTrace(GB);
   e^2 
   eh + e 
   fe - ef + h 
   f^2 
   fh - f 
   he - e 
   hf + f 
   h^2 - 2ef + h 
\end{Verbatim}
 Note the fourth relation: $f^2=0$. To view a trace one can use the function \texttt{PrintTracePol} (\ref{PrintTracePol}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintTracePol(GB[4]);
  - 1/12G(1)f^2 + 1/12f^2G(1) + 1/12f^2G(1)h - 1/6fG(1)hf + 1/12G(1)hf^2 + 1/
  24G(1)ef^3 + 1/24eG(1)f^3 - 1/8fG(1)ef^2 - 1/8feG(1)f^2 + 1/8f^2G(1)ef + 1/
  8f^2eG(1)f - 1/24f^3G(1)e - 1/24f^3eG(1) - 1/24G(2)f^3 + 1/8fG(2)f^2 - 1/
  8f^2G(2)f + 1/24f^3G(2) + 1/4G(3)f + 1/4fG(3) + 1/12fG(3)h + 1/12fhG(3) - 1/
  12G(3)hf - 1/12hG(3)f - 1/12eG(3)f^2 + 1/6feG(3)f - 1/12f^2eG(3) + 1/24G(
  4)f^4 - 1/6fG(4)f^3 + 1/4f^2G(4)f^2 - 1/6f^3G(4)f + 1/24f^4G(4) 
\end{Verbatim}
 This proves that $f^2=0$ is a consequence of $e^2=0$ in the universal enveloping algebra of the simple Lie algebra of type A$_1$. 

 The function \texttt{StrongNormalFormTraceDiff} (\ref{StrongNormalFormTraceDiff}) can be used to trace the difference between an element and its strong normal
form in the terms of \texttt{extendedrels}. Apparently, in the first example the strong normal form of \texttt{r} is \texttt{r - s.pol=0}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> r := [[[2,2,2,2,1,1,1,1]],[1]];;
  gap> s := StrongNormalFormTraceDiff(r, GB);;
  
  gap> PrintNP(s.pol);
   f^4e^4 
  gap> PrintTracePol(s);
   f^4G(4)e^2 
  gap> PrintNP(AddNP(r,s.pol,1,-1));
   0
\end{Verbatim}
 One more example where the strong normal form is not zero. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> r := [[[3,3,3]],[1]];;
  gap> s := StrongNormalFormTraceDiff(r, GB);;
  
  gap> PrintNP(s.pol);
   h^3 - h 
  gap> PrintTracePol(s);
  - G(1) - 1/2G(1)ef - 1/6eG(1)f + 1/3efG(1) + 1/2fG(1)e + 1/2feG(1) + G(
  1)h^2 + 1/2G(1)efh + 1/2eG(1)fh + 1/3efG(1)h - 1/3eG(1)hf - 1/2fG(1)eh - 1/
  2feG(1)h - 1/6eG(1)ef^2 - 1/6e^2G(1)f^2 + 1/3efG(1)ef + 1/3efeG(1)f - 1/
  6ef^2G(1)e - 1/6ef^2eG(1) + 1/2G(2)f - 1/2fG(2) - 1/2G(2)fh + 1/2fG(2)h + 1/
  6eG(2)f^2 - 1/3efG(2)f + 1/6ef^2G(2) - 2/3eG(3)h + 1/3ehG(3) + 1/3e^2G(3)f - 
  1/3efeG(3) - 1/2G(4)f^2 + fG(4)f - 1/2f^2G(4) + 1/2G(4)f^2h - fG(4)fh + 1/
  2f^2G(4)h - 1/6eG(4)f^3 + 1/2efG(4)f^2 - 1/2ef^2G(4)f + 1/6ef^3G(4) 
  gap> PrintNP(AddNP(r,s.pol,1,-1));
   h 
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Serre's exercise}}\label{Example24}
\logpage{[ "A", 25, 0 ]}
\hyperdef{L}{X8498D69D8160E5FF}{}
{
 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,1);
  gap> SetInfoLevel(InfoGBNPTime,1);
\end{Verbatim}
 In Serre's book \cite{MR1954121} the following exercise can be found: Prove that the group $ \langle \{a,b,c\}\mid \{ bab^{-1}a^{-2}, cbc^{-1}b^{-2},
aca^{-1}c^{-2}\}\right\rangle$ is the trivial group. Here we solve the exercise by running the trace variant
of the Gr{\"o}bner basis function with input the set of equations $ba - a^2 b, cb - b^2c, ac - c^2a$ together with relations forcing that $a,b,c$ are invertible with inverse $A,B,C$. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> KI := [ [[[2,1],[1,1,2]],[1,-1]],
  >         [[[3,2],[2,2,3]],[1,-1]],
  >         [[[1,3],[3,3,1]],[1,-1]],
  >         [[[1,4], []],[1,-1]],
  >         [[[4,1], []],[1,-1]],
  >         [[[2,5], []],[1,-1]],
  >         [[[5,2], []],[1,-1]],
  >         [[[3,6], []],[1,-1]],
  >         [[[6,3], []],[1,-1]],
  >       ];;
  gap> PrintNPList(KI);
   ba - a^2b 
   cb - b^2c 
   ac - c^2a 
   ad - 1 
   da - 1 
   be - 1 
   eb - 1 
   cf - 1 
   fc - 1 
\end{Verbatim}
 We use \texttt{SGrobnerTrace} (\ref{SGrobnerTrace}), the trace variant of the Gr{\"o}bner basis computation, 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := SGrobnerTrace(KI);;
  #I  number of entered polynomials is 9
  #I  number of polynomials after reduction is 9
  #I  End of phase I
  #I  End of phase II
  #I  List of todo lengths is [ 9, 10, 11, 12, 14, 16, 18, 20, 21, 22, 24, 26, 
    28, 31, 34, 33, 35, 37, 40, 43, 46, 49, 52, 56, 59, 62, 61, 60, 64, 64, 65, 
    65, 68, 71, 76, 76, 80, 88, 93, 94, 99, 110, 115, 117, 131, 139, 146, 150, 
    158, 171, 186, 198, 206, 220, 229, 246, 260, 263, 102, 40, 19, 9, 3, 0 ]
  #I  End of phase III
  #I  End of phase IV
  #I  The computation took 209905 msecs.
\end{Verbatim}
 The dimension of the quotient algebra is 1, showing that the group algebra is
1-dimensional. This implies that the group with the above presentation is
trivial. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBpols := List([1..Length(GB)], x -> GB[x].pol);;
  gap> PrintNPList(GBpols);
   a - 1 
   b - 1 
   c - 1 
   d - 1 
   e - 1 
   f - 1 
  gap> DimQA(GBpols,6);
  1
\end{Verbatim}
 Since the output is large and might spoil the exercise, we confine ourselves
to the printing first polynomial \texttt{GB[1]} and the length of its trace. As the trace polynomial expresses \texttt{GB[1]}, which is equal to $a-1$, as a combination of the binomials in \texttt{KI}, it gives a proof that $a$ can be rewritten within the group to the trivial element. It is easy to derive
from this that $b$ and $c$ are also trivial in the group. This justifies the restriction to \texttt{GB[1]}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNP(GB[1].pol);
   a - 1 
  gap> Length(GB[1].trace);
  1119
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Baur and Draisma's transformations}}\label{Example25}
\logpage{[ "A", 26, 0 ]}
\hyperdef{L}{X8116448A84D69022}{}
{
 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,0);
  gap> SetInfoLevel(InfoGBNPTime,0);
\end{Verbatim}
 The paper \cite{MR2090062} by Baur and Draisma uses the computation of a quotient algebra of dimension
37, which we repeat here. The set of equations, after specialisation of the
scalars to 1, is as follows. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> KI := [ [[[2,2]],[1]],
  >         [[[1,1]],[1]],
  >         [[[3,3]],[1]],
  >         [[[1,2,1],[1]],[1,-1]],
  >         [[[2,1,2],[2]],[1,-1]],
  >         [[[3,2,3],[3]],[1,-1]],
  >         [[[2,3,2],[2]],[1,-1]],
  >         [[[1,3,1],[1]],[1,-1]],
  >         [[[3,1,3],[3]],[1,-1]],
  >         [[[1,2,3,1,2,3,1],[1,3,2,1,3,2,1],[1]],[1,1,-1]],
  >         [[[3,1,2,3,1,2,3],[3,2,1,3,2,1,3],[3]],[1,1,-1]],
  >         [[[2,3,1,2,3,1,2],[2,1,3,2,1,3,2],[2]],[1,1,-1]],
  >       ];;
  gap> PrintNPList(KI);
   b^2 
   a^2 
   c^2 
   aba - a 
   bab - b 
   cbc - c 
   bcb - b 
   aca - a 
   cac - c 
   abcabca + acbacba - a 
   cabcabc + cbacbac - c 
   bcabcab + bacbacb - b 
\end{Verbatim}
 We carry out a traced Gr{\"o}bner basis computation by use of \texttt{SGrobnerTrace} (\ref{SGrobnerTrace}), and form the usual Gr{\"o}bner basis by extracting the polynomials from the
traced polynomials using the field indicator \texttt{.pol}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBT := SGrobnerTrace(KI);;
  gap> GB := List([1..Length(GBT)], i -> GBT[i].pol);;
\end{Verbatim}
 The dimension of the quotient algebra is computable with \texttt{DimQA} (\ref{DimQA}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> DimQA(GB,3);
  37
\end{Verbatim}
 In order to express the last GB element, viz. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNP(GB[Length(GB)]);
   cabcabca + cbacba - ca 
\end{Verbatim}
 as a combination of elements of \texttt{KI}, we use \texttt{PrintTracePol} (\ref{PrintTracePol}): 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintTracePol(GBT[Length(GBT)]);  
  - G(9)bacba + cG(10) 
\end{Verbatim}
 We compute matrices for left multiplication by generators using \texttt{MatricesQA} (\ref{MatricesQA}) and determine the minimal polynomial of the sum of the three matrices. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> B := BaseQA(GB,3,0);;
  gap> M := MatricesQA(3,B,GB);;
  gap> f := MinimalPolynomial(Rationals,M[1]+M[2]+M[3]);
  x_1^7-6*x_1^5+9*x_1^3-3*x_1
  gap> Factors(f);
  [ x_1, x_1^6-6*x_1^4+9*x_1^2-3 ]
\end{Verbatim}
 It turns out that there are three non-zero numbers $u,v,w$ such that the eigenvalues of the sum are $0,u,v,w,-u,-v,-w$. This is the information used in \cite{MR2090062}. }

 
\section{\textcolor{Chapter }{The cola gene puzzle}}\label{ExampleColagen}
\logpage{[ "A", 27, 0 ]}
\hyperdef{L}{X7912E411867E5F8B}{}
{
 

 A prize question appearing in the January 2005 issue of the Dutch journal
"Natuur en Techniek" asked for a DNA change of cows so that they could produce
Cola instead of milk. A team of genetic manipulators has tools to perform the
following five DNA string operations. (Here the strings before and after the
equality sign can be interchanged at will.) 

 operation 1: TCAT = T; 

 operation 2: GAG = AG; 

 operation 3: CTC = TC; 

 operation 4: AGTA = A; 

 operation 5: TAT = CT. 

 The first question is to show how they can transform the milk gene
TAGCTAGCTAGCT to the cola gene CTGACTGACT. 

 A second question is to show that mad cow disease related retro virus
CTGCTACTGACT can be avoided at all times. Can this be guaranteed? 

 We answer these questions using the trace functions of the Gr{\"o}bner basis
package GBNP in Section \ref{tracefun}. 

 First load the package and set the standard infolevel \texttt{InfoGBNP} (\ref{InfoGBNP}) to 0 and the time infolevel \texttt{InfoGBNPTime} (\ref{InfoGBNPTime}) to 0 to minimize the printing of data regarding the computation (for more
information about the info level, see Chapter \ref{Info}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> LoadPackage("GBNP","0",false);;
  gap> SetInfoLevel(InfoGBNP,0);
  gap> SetInfoLevel(InfoGBNPTime,0);
\end{Verbatim}
 We introduce the free algebra \texttt{ALG} on the generators corresponding to the four letters in the DNA code and
express the milk gene and cola gene as monomials in this algebra. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> ALG:=FreeAssociativeAlgebraWithOne(Rationals, "A", "C", "G", "T");;
  gap> g:=GeneratorsOfAlgebra(ALG);;
  gap> A:=g[2];;
  gap> C:=g[3];;
  gap> G:=g[4];;
  gap> T:=g[5];;
  
  gap> milk := T*A*G*C*T*A*G*C*T*A*G*C*T;;
  gap> cola := C*T*G*A*C*T*G*A*C*T;;
\end{Verbatim}
 We next enter the set $K$ of binomials $x-y$ corresponding to the five operations $x = y$ listed above. We enter the binomials as members of \texttt{ALG} and let \texttt{KNP} be the corresponding set of NP polynomials. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> rule1 := T*C*A*T - T;;
  gap> rule2 :=  G*A*G -  A*G;;
  gap> rule3 :=  C*T*C - T*C;;
  gap> rule4 := A*G*T*A - A;;
  gap> rule5 := T*A*T -  C*T;;
  gap> K := [rule1,rule2,rule3,rule4,rule5];;
  gap> KNP := List(K,x-> GP2NP(x));;
\end{Verbatim}
 We stipulate how the variables will be printed and print \texttt{KNP}. See \texttt{PrintNPList} (\ref{PrintNPList}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GBNP.ConfigPrint("A","C","G","T");
  gap> PrintNPList(KNP);
   TCAT - T 
   GAG - AG 
   CTC - TC 
   AGTA - A 
   TAT - CT 
\end{Verbatim}
 Now calculate the usual Gr{\"o}bner basis with \texttt{SGrobner} (\ref{SGrobner}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GB := SGrobner(KNP);;
\end{Verbatim}
 Compare milk and cola after taking their strong normal forms with respect to \texttt{GB} using \texttt{StrongNormalFormNP} (\ref{StrongNormalFormNP}). We oberve that they have the same normal form and so there is a way to
transform the milk gene into the cola gene. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> milkNP := GP2NP(milk);;
  gap> colaNP := GP2NP(cola);;
  gap> milkRed := NP2GP(StrongNormalFormNP(milkNP,GB),ALG);
  (1)*T
  gap> colaRed := NP2GP(StrongNormalFormNP(colaNP,GB),ALG);
  (1)*T
\end{Verbatim}
 But this information does not yet show us how to perform the transformation.
To this end we calculate the Gr{\"o}bner basis with trace information, using
the function \texttt{SGrobnerTrace} (\ref{SGrobnerTrace}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> GTrace := SGrobnerTrace(KNP);;
\end{Verbatim}
 The full trace can be printed with \texttt{PrintTraceList} (\ref{PrintTraceList}), but we only print the relations (and no trace) by invoking \texttt{PrintNPListTrace} (\ref{PrintNPListTrace}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> PrintNPListTrace(GTrace);
   CT - T 
   GA - A 
   AGT - AT 
   ATA - A 
   TAT - T 
   TCA - TA 
\end{Verbatim}
 In order to display a proof that $milk-cola$ belongs to the ideal we use \texttt{StrongNormalFormTraceDiff} (\ref{StrongNormalFormTraceDiff}), The result is a record, \texttt{p} say, containing \texttt{milk-cola} in the field \texttt{p.pol} (the normal form will be subtracted from the argument \texttt{milk-cola} to obtain \texttt{p.pol}, but the normal form is zero because the argument belongs to the ideal
generated by \texttt{K}). The other field of the record \texttt{p} is \texttt{p.trace}, the traced polynomial, which is best displayed by use of \texttt{PrintTracePol} (\ref{PrintTracePol}). 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> p := StrongNormalFormTraceDiff(CleanNP(GP2NP(milk-cola)),GTrace);;
  gap> NP2GP(p.pol,ALG);
  (1)*T*A*G*C*T*A*G*C*T*A*G*C*T+(-1)*C*T*G*A*C*T*G*A*C*T
  gap> PrintTracePol(p);
  - TGATGAG(1) + TAGG(1)ATAT - TATATAGG(1) - TGAG(1)GACT + TGATGACG(1) - G(
  1)GACTGACT - TAGCG(1)ATAT - TATAGG(1)AGT + TATATAGCG(1) + TGACG(1)GACT + CG(
  1)GACTGACT - TAGG(1)AGTAGT + TAGTAGTAGG(1) + TATAGCG(1)AGT + TAGCG(
  1)AGTAGT + TAGTAGG(1)AGCT - TAGTAGTAGCG(1) + TAGG(1)AGCTAGCT - TAGTAGCG(
  1)AGCT - TAGCG(1)AGCTAGCT - TATG(2)TAT - TG(2)TATGAT - TGATGAG(3)AT + TAGG(
  3)ATATAT - TATATAGG(3)AT - TGAG(3)ATGACT - G(3)ATGACTGACT - TATAGG(
  3)ATAGT - TAGG(3)ATAGTAGT + TAGTAGTAGG(3)AT + TAGTAGG(3)ATAGCT + TAGG(
  3)ATAGCTAGCT - TATG(4)T + TG(4)TAT + TATGG(4)T - TG(4)TGAT + TATATG(4)T + TGG(
  4)TGAT - TG(4)TATAT + TATG(4)TAGT + TG(4)TAGTAGT + TAGG(5)ATAT - TATATAGG(
  5) - TATAGG(5)AGT - TAGG(5)AGTAGT 
\end{Verbatim}
 In order to give a precise answer to the first question we need to work a
little on \texttt{p.trace}. To do so, we introduce the following function, which creates the NP
polynomial corresponding to the \texttt{i}-th term in the expression \texttt{p.trace} of \texttt{p.pol} as a linear combination of members of \texttt{KNP}. It is used to obtain the list \texttt{EvalList} of polynomials for all \texttt{i}. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> EvalTracePol := function(i,p,KNP)
  >   local x,pi;
  >   pi := p.trace[i];
  >   x := BimulNP(pi[1],KNP[pi[2]],pi[3]);
  >   return  [x[1],pi[4]*x[2]];
  > end;;
  
  gap> lev :=  Length(p.trace);;
  gap> EvalList := List([1..lev], y -> CleanNP(EvalTracePol(y,p,KNP)));;
\end{Verbatim}
 In order to find the rewrite from the milk gene to the cola gene as required
for an answer to the first question, we match leading terms recursively. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> UnusedIndices := Set([1..lev]);;
  gap> RunningTerm :=  milkNP[1][1];;
  gap> stepno := 0;;
  gap> NP2GP(milkNP,ALG);
  (1)*T*A*G*C*T*A*G*C*T*A*G*C*T
  gap> while Length(UnusedIndices) > 0 do
  >   i := 0;
  >   notfnd := true;
  >   while i < lev and notfnd do 
  >     i := i+1;
  >     if EvalList[i][1][1] = RunningTerm and i in UnusedIndices then 
  >        notfnd := false;
  >        RemoveSet(UnusedIndices, i);
  >        RunningTerm :=  EvalList[i][1][2];
  >        stepno := stepno+1;
  >     elif EvalList[i][1][2] = RunningTerm and i in UnusedIndices then 
  >        notfnd := false;
  >        RemoveSet(UnusedIndices, i);
  >        RunningTerm :=  EvalList[i][1][1];
  >        stepno := stepno+1;
  >     fi; 
  >   od;
  >   if i = lev and notfnd = true then Print("error not fnd in"); fi;
  >   Print(" -(",stepno,")- ");
  >   PrintNP([[p.trace[i][1]],[1]]);
  >   Print("         K[",p.trace[i][2],"]\n        ");
  >   PrintNP([[p.trace[i][3]],[1]]);
  >   Print(" --> ");
  >   PrintNP([[EvalList[i][1][2]],[1]]);
  > od;;
   -(1)-  TAGC 
           K[1]
           AGCTAGCT 
   -->  TAGCTAGCTAGCT 
   -(2)-  TAG 
           K[3]
           ATAGCTAGCT 
   -->  TAGTCATAGCTAGCT 
   -(3)-  TAG 
           K[1]
           AGCTAGCT 
   -->  TAGTAGCTAGCT 
   -(4)-  TAGTAGC 
           K[1]
           AGCT 
   -->  TAGTAGCTAGCT 
   -(5)-  TAGTAG 
           K[3]
           ATAGCT 
   -->  TAGTAGTCATAGCT 
   -(6)-  TAGTAG 
           K[1]
           AGCT 
   -->  TAGTAGTAGCT 
   -(7)-  TAGTAGTAGC 
           K[1]
           1 
   -->  TAGTAGTAGCT 
   -(8)-  TAGTAGTAG 
           K[3]
           AT 
   -->  TAGTAGTAGTCAT 
   -(9)-  TAGTAGTAG 
           K[1]
           1 
   -->  TAGTAGTAGT 
   -(10)-  TAG 
           K[1]
           AGTAGT 
   -->  TAGTAGTAGT 
   -(11)-  TAG 
           K[3]
           ATAGTAGT 
   -->  TAGTCATAGTAGT 
   -(12)-  TAGC 
           K[1]
           AGTAGT 
   -->  TAGCTAGTAGT 
   -(13)-  TAG 
           K[5]
           AGTAGT 
   -->  TAGCTAGTAGT 
   -(14)-  T 
           K[4]
           TAGTAGT 
   -->  TATAGTAGT 
   -(15)-  TATAG 
           K[1]
           AGT 
   -->  TATAGTAGT 
   -(16)-  TATAG 
           K[3]
           ATAGT 
   -->  TATAGTCATAGT 
   -(17)-  TATAGC 
           K[1]
           AGT 
   -->  TATAGCTAGT 
   -(18)-  TATAG 
           K[5]
           AGT 
   -->  TATAGCTAGT 
   -(19)-  TAT 
           K[4]
           TAGT 
   -->  TATATAGT 
   -(20)-  TATATAG 
           K[1]
           1 
   -->  TATATAGT 
   -(21)-  TATATAG 
           K[3]
           AT 
   -->  TATATAGTCAT 
   -(22)-  TATATAGC 
           K[1]
           1 
   -->  TATATAGCT 
   -(23)-  TATATAG 
           K[5]
           1 
   -->  TATATAGCT 
   -(24)-  TATAT 
           K[4]
           T 
   -->  TATATAT 
   -(25)-  T 
           K[4]
           TATAT 
   -->  TATATAT 
   -(26)-  TAG 
           K[5]
           ATAT 
   -->  TAGCTATAT 
   -(27)-  TAGC 
           K[1]
           ATAT 
   -->  TAGCTATAT 
   -(28)-  TAG 
           K[3]
           ATATAT 
   -->  TAGTCATATAT 
   -(29)-  TAG 
           K[1]
           ATAT 
   -->  TAGTATAT 
   -(30)-  T 
           K[4]
           TAT 
   -->  TATAT 
   -(31)-  TAT 
           K[4]
           T 
   -->  TATAT 
   -(32)-  TAT 
           K[2]
           TAT 
   -->  TATAGTAT 
   -(33)-  TATG 
           K[4]
           T 
   -->  TATGAT 
   -(34)-  T 
           K[4]
           TGAT 
   -->  TATGAT 
   -(35)-  T 
           K[2]
           TATGAT 
   -->  TAGTATGAT 
   -(36)-  TG 
           K[4]
           TGAT 
   -->  TGATGAT 
   -(37)-  TGATGA 
           K[1]
           1 
   -->  TGATGAT 
   -(38)-  TGATGA 
           K[3]
           AT 
   -->  TGATGATCAT 
   -(39)-  TGATGAC 
           K[1]
           1 
   -->  TGATGACT 
   -(40)-  TGA 
           K[1]
           GACT 
   -->  TGATGACT 
   -(41)-  TGA 
           K[3]
           ATGACT 
   -->  TGATCATGACT 
   -(42)-  TGAC 
           K[1]
           GACT 
   -->  TGACTGACT 
   -(43)-  1 
           K[1]
           GACTGACT 
   -->  TGACTGACT 
   -(44)-  1 
           K[3]
           ATGACTGACT 
   -->  TCATGACTGACT 
   -(45)-  C 
           K[1]
           GACTGACT 
   -->  CTGACTGACT 
  gap> NP2GP(colaNP,ALG);
  (1)*C*T*G*A*C*T*G*A*C*T
\end{Verbatim}
 And now the second question regarding the retro virus. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> retro := C*T*G*C*T*A*C*T*G*A*C*T;;
\end{Verbatim}
 We compute the Strong Normal Form \texttt{StrongNormalFormNP} (\ref{StrongNormalFormNP}) of \texttt{retro} with respect to \texttt{GB}. As it is \texttt{TGT}, distinct to \texttt{T}, the strong normal form of milk, there is no transformation from milk to
retro. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> NP2GP(StrongNormalFormNP(CleanNP(GP2NP(retro)),GB), ALG);
  (1)*T*G*T
\end{Verbatim}
 Of course, here too we can verify the reduction, by computing \texttt{StrongNormalFormTraceDiff} (\ref{StrongNormalFormTraceDiff}) with input the NP polynomial corresponding to \texttt{retro} and with respect to \texttt{K}; it is called \texttt{retroTrace}. The symbol \texttt{G} in expression like \texttt{G(2)} are not to be confused with the single symbols \texttt{G} representing the DNA element. 
\begin{Verbatim}[fontsize=\small,frame=single,label=]
  gap> retroTrace := StrongNormalFormTraceDiff(CleanNP(GP2NP(retro)),GTrace);;
  gap> PrintTracePol(retroTrace);
   TGG(1) - TGC^2G(1) - TGTAG(1) + TGTACG(1) + TGTAGG(1)AT + TGTATGAG(
  1) + TGTAG(1)GACT - TGTAGCG(1)AT - TGTATGACG(1) + TGG(1)ACTGACT - TGTACG(
  1)GACT + G(1)GCTACTGACT - TGCG(1)ACTGACT - CG(1)GCTACTGACT + TGTATG(
  2)TAT + TGG(3)AT + TGCG(3)AT - TGTAG(3)AT + TGTAGG(3)ATAT + TGTATGAG(
  3)AT + TGTAG(3)ATGACT + TGG(3)ATACTGACT + G(3)ATGCTACTGACT + TGTG(
  4)T + TGTATG(4)T - TGTG(4)TAT - TGTATGG(4)T + TGCG(5) + TGG(5)AT - TGTAG(
  5) + TGTAGG(5)AT 
\end{Verbatim}
 }

 }

\def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{plainurl}
\bibliography{gbnp_doc}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
