  
  [1XA [33X[0;0YExamples[133X[101X
  
  
  [1XA.1 [33X[0;0YIntroduction[133X[101X
  
  [33X[0;0YIn this chapter all available commented examples can be found. Those without
  comments  are in the directory [11Xgbnp/examples[111X. Timing results are obtained on
  an  Intel(R)  Xeon(R)  CPU  E5-2630  v3  @  2.40GHz  processor running Linux
  (3.19.0-42-generic  #48~14.04.1-Ubuntu SMP Fri Dec 18 10:24:49 UTC 2015) and
  using GAP 4.6.5.[133X
  
  [30X    [33X[0;6Y[14XA.2[114X [14X'[33X[0;0YA simple commutative GrÃ¶bner basis computation[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.3[114X [14X'[33X[0;0YA truncated GrÃ¶bner basis for Leonard pairs[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.4[114X [14X'[33X[0;0YThe truncated variant on two weighted homogeneous polynomials[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.5[114X [14X'[33X[0;0YThe order of the Weyl group of type E[22X_6[122X[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.6[114X [14X'[33X[0;0YThe gcd of some univariate polynomials[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.7[114X [14X'[33X[0;0YFrom the Tapas book[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.8[114X [14X'[33X[0;0YThe Birman-Murakami-Wenzl algebra of type A[22X_3[122X[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.9[114X [14X'[33X[0;0YThe Birman-Murakami-Wenzl algebra of type A[22X_2[122X[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.10[114X [14X'[33X[0;0YA commutative example by Mora[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.11[114X [14X'[33X[0;0YTracing an example by Mora[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.12[114X [14X'[33X[0;0YFiniteness of the Weyl group of type E[22X_6[122X[133X'[114X[133X
  
        [33X[0;6YThis extends Example [14XA.5[114X.[133X
  
  [30X    [33X[0;6Y[14XA.13[114X [14X'[33X[0;0YPreprocessing for Weyl group computations[133X'[114X[133X
  
        [33X[0;6YThis extends two earlier examples [14XA.5[114X and [14XA.12[114X.[133X
  
  [30X    [33X[0;6Y[14XA.14[114X [14X'[33X[0;0YA quotient algebra with exponential growth[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.15[114X [14X'[33X[0;0YA commutative quotient algebra of polynomial growth[133X'[114X[133X
  
        [33X[0;6YThis extends Example [14XA.7[114X.[133X
  
  [30X    [33X[0;6Y[14XA.16[114X [14X'[33X[0;0YAn algebra over a finite field[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.17[114X [14X'[33X[0;0YThe dihedral group of order 8[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.18[114X [14X'[33X[0;0YThe dihedral group of order 8 on another module[133X'[114X[133X
  
        [33X[0;6YThis extends Example [14XA.17[114X.[133X
  
  [30X    [33X[0;6Y[14XA.19[114X [14X'[33X[0;0YThe dihedral group on a non-cyclic module[133X'[114X[133X
  
        [33X[0;6YThis example also extends Example [14XA.17[114X.[133X
  
  [30X    [33X[0;6Y[14XA.20[114X [14X'[33X[0;0YThe icosahedral group[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.21[114X [14X'[33X[0;0YThe symmetric inverse monoid for a set of size four[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.22[114X [14X'[33X[0;0YA module of the Hecke algebra of type A[22X_3[122X over GF(3)[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.23[114X [14X'[33X[0;0YGeneralized Temperley-Lieb algebras[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.24[114X [14X'[33X[0;0YThe universal enveloping algebra of a Lie algebra[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.25[114X [14X'[33X[0;0YSerre's exercise[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.26[114X [14X'[33X[0;0YBaur and Draisma's transformations[133X'[114X[133X
  
  [30X    [33X[0;6Y[14XA.27[114X [14X'[33X[0;0YThe cola gene puzzle[133X'[114X[133X
  
  
  [1XA.2 [33X[0;0YA simple commutative GrÃ¶bner basis computation[133X[101X
  
  [33X[0;0YIn  this  commutative  example  the  relations are [22Xx^2y-1[122X and [22Xxy^2-1[122X; we add
  [22Xxy-yx[122X  to  enforce  that  [22Xx[122X and [22Xy[122X commute. The answer should be [22X{x^3-1, x-y,
  xy-yx}[122X,   as   the  reduction  ordering  is  total  degree  first  and  then
  lexicographic with [22Xx[122X smaller than [22Xy[122X.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 2
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 1 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,2);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[104X
  [4X[32X[104X
  
  [33X[0;0YThen input the relations in NP format (see Section [14X2.1[114X). They will be put in
  the list [10XLnp[110X.[133X
  
  [4X[32X[104X
    [4Xgap> Lnp := [ [[[1,2],[2,1]],[1,-1]]   ];[104X
    [4X[ [ [ [ 1, 2 ], [ 2, 1 ] ], [ 1, -1 ] ] ][104X
    [4Xgap> x2y := [[[1,1,2],[]],[1,-1]];[104X
    [4X[ [ [ 1, 1, 2 ], [  ] ], [ 1, -1 ] ][104X
    [4Xgap>     AddSet(Lnp,x2y);   [104X
    [4Xgap> xy2 := [[[1,2,2],[]],[1,-1]];[104X
    [4X[ [ [ 1, 2, 2 ], [  ] ], [ 1, -1 ] ][104X
    [4Xgap>     AddSet(Lnp,xy2);[104X
  [4X[32X[104X
  
  [33X[0;0YThe relations can be exhibited with [2XPrintNPList[102X ([14X3.2-3[114X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(Lnp);[104X
    [4X a^2b - 1 [104X
    [4X ab - ba [104X
    [4X ab^2 - 1 [104X
  [4X[32X[104X
  
  [33X[0;0YLet  the  variables  be  printed  as  [22Xx[122X and [22Xy[122X instead of [22Xa[122X and [22Xb[122X by means of
  [2XGBNP.ConfigPrint[102X ([14X3.2-2[114X)[133X
  
  [4X[32X[104X
    [4Xgap> GBNP.ConfigPrint("x","y");[104X
  [4X[32X[104X
  
  [33X[0;0YThe GrÃ¶bner basis can now be calculated with [2XSGrobner[102X ([14X3.4-2[114X):[133X
  
  [4X[32X[104X
    [4Xgap> GB := SGrobner(Lnp);[104X
    [4X#I  number of entered polynomials is 3[104X
    [4X#I  number of polynomials after reduction is 3[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  length of G =1[104X
    [4X#I  length of todo is 1[104X
    [4X#I  length of G =2[104X
    [4X#I  length of todo is 0[104X
    [4X#I  List of todo lengths is [ 1, 1, 0 ][104X
    [4X#I  End of phase III[104X
    [4X#I  G: Cleaning finished, 0 polynomials reduced[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 4 msecs.[104X
    [4X[ [ [ [ 2 ], [ 1 ] ], [ 1, -1 ] ], [ [ [ 1, 1, 1 ], [  ] ], [ 1, -1 ] ] ][104X
  [4X[32X[104X
  
  [33X[0;0YWhen printed, it looks like:[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(GB);[104X
    [4X y - x [104X
    [4X x^3 - 1 [104X
  [4X[32X[104X
  
  [33X[0;0YThe  dimension of the quotient algebra can be calculated with [2XDimQA[102X ([14X3.5-2[114X).
  The arguments are the GrÃ¶bner basis [10XGB[110X and the number of variables is [10X2[110X:[133X
  
  [4X[32X[104X
    [4Xgap> DimQA(GB,2);[104X
    [4X3[104X
  [4X[32X[104X
  
  [33X[0;0YA  basis of this quotient algebra can be calculated with [2XBaseQA[102X ([14X3.5-1[114X). The
  arguments  are  a  GrÃ¶bner  basis  [10XGB[110X,  the number of variables [3Xt[103X ([22X=2[122X) and a
  variable [3Xmaxno[103X for returning partial quotient algebras (0 means full basis).
  The calculated basis will be printed as well.[133X
  
  [4X[32X[104X
    [4Xgap> B:=BaseQA(GB,2,0);;[104X
    [4Xgap> PrintNPList(B);[104X
    [4X 1 [104X
    [4X x [104X
    [4X x^2 [104X
  [4X[32X[104X
  
  [33X[0;0YThe  strong  normal  form  of  the  element  [22Xxyxyxyx[122X  can be found by use of
  [2XStrongNormalFormNP[102X  ([14X3.5-6[114X).  The arguments are this element and the GrÃ¶bner
  basis [10XGB[110X.[133X
  
  [4X[32X[104X
    [4Xgap> f:=[[[1,2,1,2,1,2,1]],[1]];;[104X
    [4Xgap> PrintNP(f);[104X
    [4X xyxyxyx [104X
    [4Xgap> p:=StrongNormalFormNP(f,GB);;[104X
    [4Xgap> PrintNP(p);[104X
    [4X x [104X
  [4X[32X[104X
  
  
  [1XA.3 [33X[0;0YA truncated GrÃ¶bner basis for Leonard pairs[133X[101X
  
  [33X[0;0YTo  provide  Terwilliger  with  experimental  dimension  information  in low
  degrees   for  his  theory  of  Leonard  pairs  a  truncated  GrÃ¶bner  basis
  computation was carried out as follows.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 1
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 2 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,2);[104X
  [4X[32X[104X
  
  [33X[0;0YWe truncate the example by putting all monomials of degree [22Xn[122X in the ideal by
  means  of  the  function  [10XMkTrLst[110X  to  be  introduced below; a better way to
  compute the result is by means of the truncated GB algorithms (See [14XA.24[114X).[133X
  
  [33X[0;0YWe want to truncate at degree 7 so we have fixed [22Xn = 8[122X.[133X
  
  [4X[32X[104X
    [4Xgap> n := 8;;[104X
  [4X[32X[104X
  
  [33X[0;0YNow  enter  the relations in NP form (see [14X2.1[114X). The function [10XMkTrLst[110X will be
  introduced,  which  will return all monomials of degree [10Xn[110X. The list of ideal
  generators of interest is called [10XI[110X.[133X
  
  [4X[32X[104X
    [4Xgap> sqbr := function(n,q) ; return (q^3-q^-3)/(q-q^(-1)); end;;[104X
    [4X[104X
    [4Xgap> c := sqbr(3,5);[104X
    [4X651/25[104X
    [4X[104X
    [4Xgap> s1 :=[[[1,1,1,2],[1,1,2,1],[1,2,1,1],[2,1,1,1]],[1,-c,c,-1]];;[104X
    [4Xgap> s2 :=[[[2,2,2,1],[2,2,1,2],[2,1,2,2],[1,2,2,2]],[1,-c,c,-1]];;[104X
    [4X[104X
    [4Xgap> MkTrLst := function(l) local ans, h1, h2, a, i;[104X
    [4X>    ans := [[1],[2]];[104X
    [4X>    for i in [2..l] do[104X
    [4X>       h1 := [];[104X
    [4X>       h2 := [];[104X
    [4X>       for a in ans do[104X
    [4X>         Add(h1,Concatenation([1],a));[104X
    [4X>         Add(h2,Concatenation([2],a));[104X
    [4X>       od;[104X
    [4X>       ans := Concatenation(h1,h2);[104X
    [4X>    od;[104X
    [4X>    return List(ans, a -> [[a],[1]]);[104X
    [4X> end;;[104X
    [4X[104X
    [4Xgap> I := Concatenation([s1,s2],MkTrLst(n));;[104X
  [4X[32X[104X
  
  [33X[0;0YTo give an impression, we print the first 20 entries of this list:[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(I{[1..20]});[104X
    [4X a^3b - 651/25a^2ba + 651/25aba^2 - ba^3 [104X
    [4X b^3a - 651/25b^2ab + 651/25bab^2 - ab^3 [104X
    [4X a^8 [104X
    [4X a^7b [104X
    [4X a^6ba [104X
    [4X a^6b^2 [104X
    [4X a^5ba^2 [104X
    [4X a^5bab [104X
    [4X a^5b^2a [104X
    [4X a^5b^3 [104X
    [4X a^4ba^3 [104X
    [4X a^4ba^2b [104X
    [4X a^4baba [104X
    [4X a^4bab^2 [104X
    [4X a^4b^2a^2 [104X
    [4X a^4b^2ab [104X
    [4X a^4b^3a [104X
    [4X a^4b^4 [104X
    [4X a^3ba^4 [104X
    [4X a^3ba^3b [104X
  [4X[32X[104X
  
  [33X[0;0YWe calculate the GrÃ¶bner basis with [2XSGrobner[102X ([14X3.4-2[114X):[133X
  
  [4X[32X[104X
    [4Xgap> GB := SGrobner(I);;[104X
    [4X#I  number of entered polynomials is 258[104X
    [4X#I  number of polynomials after reduction is 114[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  End of phase III[104X
    [4X#I  Time needed to clean G :0[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 176 msecs.[104X
  [4X[32X[104X
  
  [33X[0;0YNow print the first part of the GrÃ¶bner basis with [2XPrintNPList[102X ([14X3.2-3[114X) (only
  the  first  20  polynomials  are printed here, the full GrÃ¶bner basis can be
  printed with [10XPrintNPList(GB)[110X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(GB{[1..20]});[104X
    [4X ba^3 - 651/25aba^2 + 651/25a^2ba - a^3b [104X
    [4X b^3a - 651/25b^2ab + 651/25bab^2 - ab^3 [104X
    [4X b^2a^2ba - bab^2a^2 - baba^2b + ba^2bab + ab^2aba - abab^2a - aba^2b^2 + a^2b\[104X
    [4X^2ab [104X
    [4X b^2ab^2a^2 - 651/25b^2ababa + b^2aba^2b + 626/25bab^2aba - bab^2a^2b + babab^\[104X
    [4X2a - ba^2b^2ab + ba^2bab^2 - 651/25ab^2ab^2a + ab^2abab + 423176/625abab^2ab -\[104X
    [4X 423801/625ababab^2 + 626/25aba^2b^3 - 406901/625a^2b^2ab^2 + 423176/625a^2bab\[104X
    [4X^3 - 651/25a^3b^4 [104X
    [4X a^8 [104X
    [4X a^7b [104X
    [4X a^6ba [104X
    [4X a^6b^2 [104X
    [4X a^5ba^2 [104X
    [4X a^5bab [104X
    [4X a^5b^2a [104X
    [4X a^5b^3 [104X
    [4X a^4ba^2b [104X
    [4X a^4baba [104X
    [4X a^4bab^2 [104X
    [4X a^4b^2a^2 [104X
    [4X a^4b^2ab [104X
    [4X a^4b^4 [104X
    [4X a^3ba^2ba [104X
    [4X a^3ba^2b^2 [104X
  [4X[32X[104X
  
  [33X[0;0YThe  truncated  quotient  algebra  is  obtained  by  factoring out the ideal
  generated  by  the  GrÃ¶bner  basis [10XGB[110X and so its dimension can be calculated
  with [2XDimQA[102X ([14X3.5-2[114X):[133X
  
  [4X[32X[104X
    [4Xgap> DimQA(GB,2);[104X
    [4X#I  The computation took 0 msecs.[104X
    [4X157[104X
  [4X[32X[104X
  
  [33X[0;0YHere  is  what Paul Terwilliger wrote in reaction to the computation carried
  out by this example:[133X
  
  [33X[0;0YI  just  wanted  to  thank you again for the dimension data that you gave me
  after  the  Durham  meeting.  It  ended  up  having  a large impact. See the
  attached paper; joint with Tatsuro Ito.[133X
  
  [33X[0;0YI  spent  several weeks in Japan this past January, working with Tatsuro and
  trying  to  find  a good basis for the algebra on two symbols subject to the
  [22Xq[122X-Serre  relations.  After much frustration, we thought of feeding your data
  into  Sloane's  online  handbook  of  integer  sequences.  We  did it out of
  curiosity  more  than  anything;  we  did not expect the handbook data to be
  particularly useful. But it was.[133X
  
  [33X[0;0YThe  handbook  told  us that the graded dimension generating function, using
  your  data for the coefficients, matched the [22Xq[122X-series for the inverse of the
  Jacobi theta function [22XÏ‘_4[122X; armed with this overwhelming hint we were able to
  prove  that the graded dimension generating function was indeed given by the
  inverse  of  [22XÏ‘_4[122X.  With that info we were able to get a nice result about td
  pairs.[133X
  
  [33X[0;0YPaul[133X
  
  
  [1XA.4 [33X[0;0YThe truncated variant on two weighted homogeneous polynomials[133X[101X
  
  [33X[0;0YHere  we  exhibit  a  truncated non-commutative homogeneous weighted GrÃ¶bner
  basis  computation.  This  example  uses the functions from Section [14X3.8[114X, the
  truncation variants (see also Section [14X2.6[114X).[133X
  
  [33X[0;0YThe input is a set of polynomials in [22Xx[122X and [22Xy[122X, which are homogeneous when the
  weight    of    [22Xx[122X    is    2    and    of    [22Xy[122X    is   3.   The   input   is
  [22X{x^3y^2-x^6+y^4,y^2x^3+xyxyx+x^2yxy}[122X.  We truncate the computation at degree
  16.          The          truncated         GrÃ¶bner         basis         is
  [22X{y^2x^3+xyxyx+x^2yxy,x^6-x^3y^2-y^4,x^3y^2x-x^4y^2-xy^4}[122X  and  the dimension
  of the quotient algebra is 134.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 1
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 1 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[104X
  [4X[32X[104X
  
  [33X[0;0YThe variables will be printed as [22Xx[122X and [22Xy[122X.[133X
  
  [4X[32X[104X
    [4Xgap> GBNP.ConfigPrint("x","y");[104X
  [4X[32X[104X
  
  [33X[0;0YThe level to truncate at is assigned to [22Xn[122X.[133X
  
  [4X[32X[104X
    [4Xgap> n := 16;;[104X
  [4X[32X[104X
  
  [33X[0;0YNow enter the relations in NP form (see Section [14X2.1[114X) and the weights.[133X
  
  [4X[32X[104X
    [4Xgap> s1 :=[[[1,1,1,2,2],[1,1,1,1,1,1],[2,2,2,2]],[1,-1,1]];;[104X
    [4Xgap> s2 :=[[[2,2,1,1,1],[1,2,1,2,1],[1,1,2,1,2]],[1,1,1]];;[104X
    [4Xgap> K := [s1,s2];;[104X
    [4Xgap> weights:=[2,3];;[104X
  [4X[32X[104X
  
  [33X[0;0YThe input can be printed with [2XPrintNPList[102X ([14X3.2-3[114X)[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(K);[104X
    [4X x^3y^2 - x^6 + y^4 [104X
    [4X y^2x^3 + xyxyx + x^2yxy [104X
  [4X[32X[104X
  
  [33X[0;0YVerify  whether the list [10XK[110X consists only of polynomials that are homogeneous
  with respect to [10Xweights[110X by means of [2XCheckHomogeneousNPs[102X ([14X3.8-3[114X).[133X
  
  [4X[32X[104X
    [4Xgap> CheckHomogeneousNPs(K,weights);[104X
    [4X#I  Input is homogeneous[104X
    [4X[ 12, 12 ][104X
  [4X[32X[104X
  
  [33X[0;0YNow  calculate  the  truncated GrÃ¶bner basis with [2XSGrobnerTrunc[102X ([14X3.8-2[114X). The
  output will only contain homogeneous polynomials of degree at most [10Xn[110X.[133X
  
  [4X[32X[104X
    [4Xgap> G := SGrobnerTrunc(K,n,weights);;[104X
    [4X#I  number of entered polynomials is 2[104X
    [4X#I  number of polynomials after reduction is 2[104X
    [4X#I  End of phase I[104X
    [4X#I  Input is homogeneous[104X
    [4X#I  Reached level 16[104X
    [4X#I  end of the algorithm[104X
    [4X#I  The computation took 4 msecs.[104X
  [4X[32X[104X
  
  [33X[0;0YThe  GrÃ¶bner  basis  of  the  truncated quotient algebra can be printed with
  [2XPrintNPList[102X ([14X3.2-3[114X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(G);[104X
    [4X y^2x^3 + xyxyx + x^2yxy [104X
    [4X x^6 - x^3y^2 - y^4 [104X
    [4X x^3y^2x - x^4y^2 + y^4x - xy^4 [104X
  [4X[32X[104X
  
  [33X[0;0YThe  standard  basis of the quotient of the free noncommutative algebra on [22Xn[122X
  variables,  where  [22Xn[122X is the length of the vector [10Xweights[110X, by the homogeneous
  ideal  generated  by  [10XK[110X  up to degree [22Xn[122X is obtained by means of the function
  [2XBaseQATrunc[102X ([14X3.8-4[114X) applied to [10XK[110X, [10Xn[110X, and [10Xweights[110X.[133X
  
  [4X[32X[104X
    [4Xgap> B := BaseQATrunc(K,n,weights);;[104X
    [4X#I  number of entered polynomials is 2[104X
    [4X#I  number of polynomials after reduction is 2[104X
    [4X#I  End of phase I[104X
    [4X#I  Input is homogeneous[104X
    [4X#I  Reached level 16[104X
    [4X#I  end of the algorithm[104X
    [4X#I  The computation took 0 msecs.[104X
    [4Xgap> i := Length(B);[104X
    [4X17[104X
    [4Xgap> Print("at level ",i-1," the standard monomials are:\n");[104X
    [4Xat level 16 the standard monomials are:[104X
    [4Xgap> PrintNPList(List(B[i], qq -> [[qq],[1]]));[104X
    [4X yxyx^4 [104X
    [4X yx^2yx^3 [104X
    [4X xyxyx^3 [104X
    [4X yx^3yx^2 [104X
    [4X xyx^2yx^2 [104X
    [4X x^2yxyx^2 [104X
    [4X y^4x^2 [104X
    [4X yx^4yx [104X
    [4X xyx^3yx [104X
    [4X x^2yx^2yx [104X
    [4X x^3yxyx [104X
    [4X y^3xyx [104X
    [4X y^2xy^2x [104X
    [4X yxy^3x [104X
    [4X xy^4x [104X
    [4X yx^5y [104X
    [4X xyx^4y [104X
    [4X x^2yx^3y [104X
    [4X x^3yx^2y [104X
    [4X y^3x^2y [104X
    [4X x^4yxy [104X
    [4X y^2xyxy [104X
    [4X yxy^2xy [104X
    [4X xy^3xy [104X
    [4X x^5y^2 [104X
    [4X y^2x^2y^2 [104X
    [4X yxyxy^2 [104X
    [4X xy^2xy^2 [104X
    [4X yx^2y^3 [104X
    [4X xyxy^3 [104X
    [4X x^2y^4 [104X
  [4X[32X[104X
  
  [33X[0;0YThe  same  result can be obtained by using the truncated GrÃ¶bner basis found
  for [10XG[110X instead of [10XK[110X.[133X
  
  [4X[32X[104X
    [4Xgap> B2 := BaseQATrunc(G,n,weights);;[104X
    [4X#I  number of entered polynomials is 3[104X
    [4X#I  number of polynomials after reduction is 3[104X
    [4X#I  End of phase I[104X
    [4X#I  Input is homogeneous[104X
    [4X#I  Reached level 16[104X
    [4X#I  end of the algorithm[104X
    [4X#I  The computation took 0 msecs.[104X
    [4Xgap> B = B2;[104X
    [4Xtrue[104X
  [4X[32X[104X
  
  [33X[0;0YAlso,  the  same  result  can  be obtained by using the leading terms of the
  truncated GrÃ¶bner basis found for [10XG[110X instead of [10XK[110X.[133X
  
  [4X[32X[104X
    [4Xgap> B3 := BaseQATrunc(List( LMonsNP(G), qq -> [[qq],[1]]),n,weights);;[104X
    [4X#I  number of entered polynomials is 3[104X
    [4X#I  number of polynomials after reduction is 3[104X
    [4X#I  End of phase I[104X
    [4X#I  Input is homogeneous[104X
    [4X#I  Reached level 16[104X
    [4X#I  end of the algorithm[104X
    [4X#I  The computation took 0 msecs.[104X
    [4Xgap> B = B3;[104X
    [4Xtrue[104X
  [4X[32X[104X
  
  [33X[0;0YA  list of dimensions of the homogeneous parts of the quotient algebra up to
  degree  [22Xn[122X  is  obtained by means of [2XDimsQATrunc[102X ([14X3.8-5[114X) with arguments [10XG[110X, [10Xn[110X,
  and [10Xweights[110X.[133X
  
  [4X[32X[104X
    [4Xgap> DimsQATrunc(G,n,weights);[104X
    [4X#I  number of entered polynomials is 3[104X
    [4X#I  number of polynomials after reduction is 3[104X
    [4X#I  End of phase I[104X
    [4X#I  Input is homogeneous[104X
    [4X#I  Reached level 16[104X
    [4X#I  end of the algorithm[104X
    [4X#I  The computation took 4 msecs.[104X
    [4X[ 1, 0, 1, 1, 1, 2, 2, 3, 4, 5, 7, 9, 10, 16, 17, 24, 31 ][104X
  [4X[32X[104X
  
  [33X[0;0YEven  more  detailed  information  is  given by the list of frequences up to
  degree  [10Xn[110X.  This is obtained by means of [2XFreqsQATrunc[102X ([14X3.8-6[114X) with arguments
  [10XG[110X, [10Xn[110X, and [10Xweights[110X.[133X
  
  [4X[32X[104X
    [4Xgap> FreqsQATrunc(G,n,weights);[104X
    [4X#I  number of entered polynomials is 3[104X
    [4X#I  number of polynomials after reduction is 3[104X
    [4X#I  End of phase I[104X
    [4X#I  Input is homogeneous[104X
    [4X#I  Reached level 16[104X
    [4X#I  end of the algorithm[104X
    [4X#I  The computation took 0 msecs.[104X
    [4X[ [ [ [  ], 1 ] ], [ [ [ 1, 0 ], 1 ] ], [ [ [ 0, 1 ], 1 ] ], [104X
    [4X  [ [ [ 2, 0 ], 1 ] ], [ [ [ 1, 1 ], 2 ] ], [104X
    [4X  [ [ [ 3, 0 ], 1 ], [ [ 0, 2 ], 1 ] ], [ [ [ 2, 1 ], 3 ] ], [104X
    [4X  [ [ [ 4, 0 ], 1 ], [ [ 1, 2 ], 3 ] ], [ [ [ 3, 1 ], 4 ], [ [ 0, 3 ], 1 ] ], [104X
    [4X  [ [ [ 5, 0 ], 1 ], [ [ 2, 2 ], 6 ] ], [ [ [ 4, 1 ], 5 ], [ [ 1, 3 ], 4 ] ], [104X
    [4X  [ [ [ 3, 2 ], 9 ], [ [ 0, 4 ], 1 ] ], [ [ [ 5, 1 ], 6 ], [ [ 2, 3 ], 10 ] ],[104X
    [4X  [ [ [ 4, 2 ], 12 ], [ [ 1, 4 ], 5 ] ], [104X
    [4X  [ [ [ 6, 1 ], 5 ], [ [ 3, 3 ], 18 ], [ [ 0, 5 ], 1 ] ], [104X
    [4X  [ [ [ 5, 2 ], 16 ], [ [ 2, 4 ], 15 ] ] ][104X
  [4X[32X[104X
  
  
  [1XA.5 [33X[0;0YThe order of the Weyl group of type E[22X_6[122X[101X[1X[133X[101X
  
  [33X[0;0YIn  order  to show how the order of a finite group of manageable size with a
  manageable  presentation can be computed, we determine the order of the Weyl
  group of type E[22X_6[122X. This number is well known to be 51840.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 1
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 2 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,2);[104X
  [4X[32X[104X
  
  [33X[0;0YThen  input  the  relations  in  NP  format  (see  [14X2.1[114X).  They come from the
  presentation of the Weyl group as a Coxeter group. This means that there are
  six variables, one for each generator. We let the corresponding variables be
  printed as [22Xr_1[122X, ..., [22Xr_6[122X by means of [2XGBNP.ConfigPrint[102X ([14X3.2-2[114X)[133X
  
  [4X[32X[104X
    [4Xgap> GBNP.ConfigPrint(6,"r");[104X
  [4X[32X[104X
  
  [33X[0;0YThe  relations are binomial and represent the group relations, which express
  that  the  generators  are  involutions (that is, have order 2) and that the
  orders  of  the  products  of any two generators is specified by the Coxeter
  diagram  (see any book on Coxeter groups for details). The relations will be
  assigned to [10XKI[110X.[133X
  
  [4X[32X[104X
    [4Xgap> k1 := [[[1,3,1],[3,1,3]],[1,-1]];;[104X
    [4Xgap> k2 := [[[4,3,4],[3,4,3]],[1,-1]];;[104X
    [4Xgap> k3 := [[[4,2,4],[2,4,2]],[1,-1]];;[104X
    [4Xgap> k4 := [[[4,5,4],[5,4,5]],[1,-1]];;[104X
    [4Xgap> k5 := [[[6,5,6],[5,6,5]],[1,-1]];;[104X
    [4Xgap> k6 := [[[1,2],[2,1]],[1,-1]];;[104X
    [4Xgap> k7 := [[[1,4],[4,1]],[1,-1]];;[104X
    [4Xgap> k8 := [[[1,5],[5,1]],[1,-1]];;[104X
    [4Xgap> k9 := [[[1,6],[6,1]],[1,-1]];;[104X
    [4Xgap> k10 := [[[2,3],[3,2]],[1,-1]];;[104X
    [4Xgap> k11 := [[[2,5],[5,2]],[1,-1]];;[104X
    [4Xgap> k12 := [[[2,6],[6,2]],[1,-1]];;[104X
    [4Xgap> k13 := [[[3,5],[5,3]],[1,-1]];;[104X
    [4Xgap> k14 := [[[3,6],[6,3]],[1,-1]];;[104X
    [4Xgap> k15 := [[[4,6],[6,4]],[1,-1]];;[104X
    [4Xgap> k16 := [[[1,1],[]],[1,-1]];;[104X
    [4Xgap> k17 := [[[2,2],[]],[1,-1]];;[104X
    [4Xgap> k18 := [[[3,3],[]],[1,-1]];;[104X
    [4Xgap> k19 := [[[4,4],[]],[1,-1]];;[104X
    [4Xgap> k20 := [[[5,5],[]],[1,-1]];;[104X
    [4Xgap> k21 := [[[6,6],[]],[1,-1]];;[104X
    [4Xgap> KI := [k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,[104X
    [4X>        k11,k12,k13,k14,k15,k16,k17,k18,k19,k20,k21[104X
    [4X>       ];;[104X
  [4X[32X[104X
  
  [33X[0;0YThe relations can be shown with [2XPrintNPList[102X ([14X3.2-3[114X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(KI);[104X
    [4X r.1r.3r.1 - r.3r.1r.3 [104X
    [4X r.4r.3r.4 - r.3r.4r.3 [104X
    [4X r.4r.2r.4 - r.2r.4r.2 [104X
    [4X r.4r.5r.4 - r.5r.4r.5 [104X
    [4X r.6r.5r.6 - r.5r.6r.5 [104X
    [4X r.1r.2 - r.2r.1 [104X
    [4X r.1r.4 - r.4r.1 [104X
    [4X r.1r.5 - r.5r.1 [104X
    [4X r.1r.6 - r.6r.1 [104X
    [4X r.2r.3 - r.3r.2 [104X
    [4X r.2r.5 - r.5r.2 [104X
    [4X r.2r.6 - r.6r.2 [104X
    [4X r.3r.5 - r.5r.3 [104X
    [4X r.3r.6 - r.6r.3 [104X
    [4X r.4r.6 - r.6r.4 [104X
    [4X r.1^2 - 1 [104X
    [4X r.2^2 - 1 [104X
    [4X r.3^2 - 1 [104X
    [4X r.4^2 - 1 [104X
    [4X r.5^2 - 1 [104X
    [4X r.6^2 - 1 [104X
  [4X[32X[104X
  
  [33X[0;0YThe GrÃ¶bner basis can now be calculated with [2XSGrobner[102X ([14X3.4-2[114X):[133X
  
  [4X[32X[104X
    [4Xgap> GB := SGrobner(KI);;[104X
    [4X#I  number of entered polynomials is 21[104X
    [4X#I  number of polynomials after reduction is 21[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  End of phase III[104X
    [4X#I  Time needed to clean G :0[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 132 msecs.[104X
    [4Xgap> PrintNPList(GB);[104X
    [4X r.1^2 - 1 [104X
    [4X r.2r.1 - r.1r.2 [104X
    [4X r.2^2 - 1 [104X
    [4X r.3r.2 - r.2r.3 [104X
    [4X r.3^2 - 1 [104X
    [4X r.4r.1 - r.1r.4 [104X
    [4X r.4^2 - 1 [104X
    [4X r.5r.1 - r.1r.5 [104X
    [4X r.5r.2 - r.2r.5 [104X
    [4X r.5r.3 - r.3r.5 [104X
    [4X r.5^2 - 1 [104X
    [4X r.6r.1 - r.1r.6 [104X
    [4X r.6r.2 - r.2r.6 [104X
    [4X r.6r.3 - r.3r.6 [104X
    [4X r.6r.4 - r.4r.6 [104X
    [4X r.6^2 - 1 [104X
    [4X r.3r.1r.2 - r.2r.3r.1 [104X
    [4X r.3r.1r.3 - r.1r.3r.1 [104X
    [4X r.4r.2r.4 - r.2r.4r.2 [104X
    [4X r.4r.3r.4 - r.3r.4r.3 [104X
    [4X r.5r.4r.5 - r.4r.5r.4 [104X
    [4X r.6r.5r.6 - r.5r.6r.5 [104X
    [4X r.4r.3r.1r.4 - r.3r.4r.3r.1 [104X
    [4X r.5r.4r.2r.5 - r.4r.5r.4r.2 [104X
    [4X r.5r.4r.3r.5 - r.4r.5r.4r.3 [104X
    [4X r.6r.5r.4r.6 - r.5r.6r.5r.4 [104X
    [4X r.4r.2r.3r.4r.2 - r.3r.4r.2r.3r.4 [104X
    [4X r.4r.2r.3r.4r.3 - r.2r.4r.2r.3r.4 [104X
    [4X r.5r.4r.2r.3r.5 - r.4r.5r.4r.2r.3 [104X
    [4X r.5r.4r.3r.1r.5 - r.4r.5r.4r.3r.1 [104X
    [4X r.6r.5r.4r.2r.6 - r.5r.6r.5r.4r.2 [104X
    [4X r.6r.5r.4r.3r.6 - r.5r.6r.5r.4r.3 [104X
    [4X r.4r.2r.3r.1r.4r.2 - r.3r.4r.2r.3r.1r.4 [104X
    [4X r.5r.4r.2r.3r.1r.5 - r.4r.5r.4r.2r.3r.1 [104X
    [4X r.6r.5r.4r.2r.3r.6 - r.5r.6r.5r.4r.2r.3 [104X
    [4X r.6r.5r.4r.3r.1r.6 - r.5r.6r.5r.4r.3r.1 [104X
    [4X r.4r.2r.3r.1r.4r.3r.1 - r.2r.4r.2r.3r.1r.4r.3 [104X
    [4X r.5r.4r.2r.3r.4r.5r.4 - r.4r.5r.4r.2r.3r.4r.5 [104X
    [4X r.6r.5r.4r.2r.3r.1r.6 - r.5r.6r.5r.4r.2r.3r.1 [104X
    [4X r.6r.5r.4r.2r.3r.4r.6 - r.5r.6r.5r.4r.2r.3r.4 [104X
    [4X r.5r.4r.2r.3r.1r.4r.5r.4 - r.4r.5r.4r.2r.3r.1r.4r.5 [104X
    [4X r.6r.5r.4r.2r.3r.1r.4r.6 - r.5r.6r.5r.4r.2r.3r.1r.4 [104X
    [4X r.6r.5r.4r.2r.3r.1r.4r.3r.6 - r.5r.6r.5r.4r.2r.3r.1r.4r.3 [104X
    [4X r.6r.5r.4r.2r.3r.4r.5r.6r.5 - r.5r.6r.5r.4r.2r.3r.4r.5r.6 [104X
    [4X r.5r.4r.2r.3r.1r.4r.3r.5r.4r.3 - r.4r.5r.4r.2r.3r.1r.4r.3r.5r.4 [104X
    [4X r.6r.5r.4r.2r.3r.1r.4r.5r.6r.5 - r.5r.6r.5r.4r.2r.3r.1r.4r.5r.6 [104X
    [4X r.5r.4r.2r.3r.1r.4r.3r.5r.4r.2r.3 - r.4r.5r.4r.2r.3r.1r.4r.3r.5r.4r.2 [104X
    [4X r.6r.5r.4r.2r.3r.1r.4r.3r.5r.6r.5 - r.5r.6r.5r.4r.2r.3r.1r.4r.3r.5r.6 [104X
    [4X r.6r.5r.4r.2r.3r.1r.4r.3r.5r.4r.6r.5r.4 - r.5r.6r.5r.4r.2r.3r.1r.4r.3r.5r.4r.\[104X
    [4X6r.5 [104X
    [4X r.6r.5r.4r.2r.3r.1r.4r.3r.5r.4r.2r.6r.5r.4r.2 - r.5r.6r.5r.4r.2r.3r.1r.4r.3r.\[104X
    [4X5r.4r.2r.6r.5r.4 [104X
  [4X[32X[104X
  
  [33X[0;0YThe  base  of  the  quotient  algebra can be calculated with [2XBaseQA[102X ([14X3.5-1[114X),
  which  has  as  arguments  a  GrÃ¶bner  basis [10XGB[110X, a number of symbols [10X6[110X and a
  maximum terms to be found (here 0 is entered, for a full base) . Since it is
  very long we will not print it here.[133X
  
  [4X[32X[104X
    [4Xgap> B:=BaseQA(GB,6,0);;[104X
  [4X[32X[104X
  
  [33X[0;0YThe  dimension of the quotient algebra can be calculated with [2XDimQA[102X ([14X3.5-2[114X),
  the  arguments  are  the GrÃ¶bner basis [10XGB[110X and the number of symbols [10X6[110X. Since
  [2XInfoGBNPTime[102X  ([14X4.3-1[114X)  is  set  to  2,  we get timing information from [2XDimQA[102X
  ([14X3.5-2[114X):[133X
  
  [4X[32X[104X
    [4Xgap> DimQA(GB,6);[104X
    [4X#I  The computation took 172 msecs.[104X
    [4X51840[104X
  [4X[32X[104X
  
  [33X[0;0YNote  that  the  calculation  of  the  dimension  takes  almost  as  long as
  calculating  the  base. Since we have already calculated a base [10XB[110X it is much
  more efficient to calculate the dimension with [10XLength[110X:[133X
  
  [4X[32X[104X
    [4Xgap> Length(B);[104X
    [4X51840[104X
  [4X[32X[104X
  
  
  [1XA.6 [33X[0;0YThe gcd of some univariate polynomials[133X[101X
  
  [33X[0;0YA  list  of  univariate  polynomials is generated. The result of the GrÃ¶bner
  basis  computation  on  this list should be a single monic polynomial, their
  gcd.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 2
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 1 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,2);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[104X
  [4X[32X[104X
  
  [33X[0;0YLet the single variable be printed as x by means of [2XGBNP.ConfigPrint[102X ([14X3.2-2[114X)[133X
  
  [4X[32X[104X
    [4Xgap> GBNP.ConfigPrint("x");[104X
  [4X[32X[104X
  
  [33X[0;0YNow input the relations in NP format (see [14X2.1[114X). They will be assigned to [10XKI[110X.[133X
  
  [4X[32X[104X
    [4Xgap> p0 := [[[1,1,1],[1,1],[1],[]],[1,2,2,1]];;[104X
    [4Xgap> p1 := [[[1,1,1,1],[1,1],[]],[1,1,1]];;[104X
    [4Xgap> KI := [p0,p1];;[104X
    [4X[104X
    [4Xgap> for i in [2..12] do [104X
    [4X>     h := AddNP(AddNP(KI[i],KI[i-1],1,3), [104X
    [4X>     	AddNP(BimulNP([1],KI[i],[]),KI[i-1],2,1),3,-5);[104X
    [4X>     Add(KI,h);[104X
    [4X> od;[104X
  [4X[32X[104X
  
  [33X[0;0YThe relations can be shown with [2XPrintNPList[102X ([14X3.2-3[114X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(KI);[104X
    [4X x^3 + 2x^2 + 2x + 1 [104X
    [4X x^4 + x^2 + 1 [104X
    [4X - 10x^5 + 3x^4 - 6x^3 + 11x^2 - 2x + 7 [104X
    [4X 100x^6 - 60x^5 + 73x^4 - 128x^3 + 57x^2 - 76x + 25 [104X
    [4X - 1000x^7 + 900x^6 - 950x^5 + 1511x^4 - 978x^3 + 975x^2 - 486x + 103 [104X
    [4X 10000x^8 - 12000x^7 + 12600x^6 - 18200x^5 + 14605x^4 - 13196x^3 + 8013x^2 - 2\[104X
    [4X792x + 409 [104X
    [4X - 100000x^9 + 150000x^8 - 166000x^7 + 223400x^6 - 204450x^5 + 181819x^4 - 123\[104X
    [4X630x^3 + 55859x^2 - 14410x + 1639 [104X
    [4X 1000000x^10 - 1800000x^9 + 2150000x^8 - 2780000x^7 + 2765100x^6 - 2504340x^5 \[104X
    [4X+ 1840177x^4 - 982264x^3 + 343729x^2 - 70788x + 6553 [104X
    [4X - 10000000x^11 + 21000000x^10 - 27300000x^9 + 34850000x^8 - 36655000x^7 + 342\[104X
    [4X32300x^6 - 26732590x^5 + 16070447x^4 - 6878602x^3 + 1962503x^2 - 335534x + 262\[104X
    [4X15 [104X
    [4X 100000000x^12 - 240000000x^11 + 340000000x^10 - 437600000x^9 + 479700000x^8 -\[104X
    [4X 463408000x^7 + 381083200x^6 - 250919600x^5 + 124358069x^4 - 44189892x^3 + 106\[104X
    [4X17765x^2 - 1551904x + 104857 [104X
    [4X - 1000000000x^13 + 2700000000x^12 - 4160000000x^11 + 5480000000x^10 - 6219000\[104X
    [4X000x^9 + 6212580000x^8 - 5347676000x^7 + 3789374800x^6 - 2103269850x^5 + 87925\[104X
    [4X4915x^4 - 266261734x^3 + 55222347x^2 - 7046418x + 419431 [104X
    [4X 10000000000x^14 - 30000000000x^13 + 50100000000x^12 - 68240000000x^11 + 79990\[104X
    [4X000000x^10 - 82533200000x^9 + 74033300000x^8 - 55790408000x^7 + 33925155700x^6\[104X
    [4X - 16106037100x^5 + 5797814361x^4 - 1527768240x^3 + 278602281x^2 - 31541180x +\[104X
    [4X 1677721 [104X
    [4X - 100000000000x^15 + 330000000000x^14 - 595000000000x^13 + 843500000000x^12 -\[104X
    [4X 1021260000000x^11 + 1087222000000x^10 - 1012808600000x^9 + 804854300000x^8 - \[104X
    [4X528013485000x^7 + 277993337300x^6 - 114709334310x^5 + 36188145143x^4 - 8434374\[104X
    [4X466x^3 + 1372108031x^2 - 139586422x + 6710887 [104X
    [4Xgap> Length(KI);[104X
    [4X13[104X
  [4X[32X[104X
  
  [33X[0;0YThe GrÃ¶bner basis can now be calculated with [2XSGrobner[102X ([14X3.4-2[114X):[133X
  
  [4X[32X[104X
    [4Xgap> GB := SGrobner(KI);;[104X
    [4X#I  number of entered polynomials is 13[104X
    [4X#I  number of polynomials after reduction is 1[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  List of todo lengths is [ 0 ][104X
    [4X#I  End of phase III[104X
    [4X#I  G: Cleaning finished, 0 polynomials reduced[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 0 msecs.[104X
  [4X[32X[104X
  
  [33X[0;0YPrinted it looks like:[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(GB);[104X
    [4X x^2 + x + 1 [104X
  [4X[32X[104X
  
  
  [1XA.7 [33X[0;0YFrom the Tapas book[133X[101X
  
  [33X[0;0YThis  example  is  a standard commutative GrÃ¶bner basis computation from the
  book  Some  Tapas  of  Computer  Algebra  [CCS99],  page  339. There are six
  variables, named [22Xa[122X, ... , [22Xf[122X by default. We work over the rationals and study
  the  ideal  generated  by  the twelve polynomials occurring on the middle of
  page  339  of  the  Tapas  book in a project by De Boer and Pellikaan on the
  ternary  cyclic  code  of length 11. Below these are named [10Xp1[110X, ..., [10Xp12[110X. The
  result  should  be the union of [22X{a,b}[122X and the set of 6 homogeneous binomials
  (that  is, polynomials with two terms) of degree 2 forcing commuting between
  [22Xc[122X, [22Xd[122X, [22Xe[122X, and [22Xf[122X.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 2
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 1 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,2);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[104X
  [4X[32X[104X
  
  [33X[0;0YNow  define some functions which will help in the construction of relations.
  The  function  [10Xpowermon(g, exp)[110X will return the monomial [22Xg^exp[122X. The function
  [10Xcomm(a,  b)[110X  will  return  a  relation forcing commutativity between its two
  arguments [10Xa[110X and [10Xb[110X.[133X
  
  [4X[32X[104X
    [4Xgap> powermon := function(base, exp)[104X
    [4X>  local ans,i;[104X
    [4X>  ans := [];[104X
    [4X>  for i in [1..exp] do ans :=  Concatenation(ans,[base]); od;[104X
    [4X>  return ans;[104X
    [4X> end;;[104X
    [4X[104X
    [4Xgap> comm := function(a,b)[104X
    [4X>   return [[[a,b],[b,a]],[1,-1]];[104X
    [4X> end;;[104X
  [4X[32X[104X
  
  [33X[0;0YNow the relations are entered.[133X
  
  [4X[32X[104X
    [4Xgap> p1 := [[[5,1]],[1]];;[104X
    [4Xgap> p2 := [[powermon(1,3),[6,1]],[1,1]];;[104X
    [4Xgap> p3 := [[powermon(1,9),Concatenation([3],powermon(1,3))],[1,1]];;[104X
    [4Xgap> p4 := [[powermon(1,81),Concatenation([3],powermon(1,9)),[104X
    [4X> 	Concatenation([4],powermon(1,3))],[1,1,1]];;[104X
    [4Xgap> p5 := [[Concatenation([3],powermon(1,81)),Concatenation([4],powermon(1,9)),[104X
    [4X> 	Concatenation([5],powermon(1,3))],[1,1,1]];;[104X
    [4Xgap> p6 := [[powermon(1,27),Concatenation([4],powermon(1,81)),Concatenation([5],[104X
    [4X> 	powermon(1,9)),Concatenation([6],powermon(1,3))],[1,1,1,1]];;[104X
    [4Xgap> p7 := [[powermon(2,1),Concatenation([3],powermon(1,27)),Concatenation([5],[104X
    [4X> 	powermon(1,81)),Concatenation([6],powermon(1,9))],[1,1,1,1]];;[104X
    [4Xgap> p8 := [[Concatenation([3],powermon(2,1)),Concatenation([4],powermon(1,27)),[104X
    [4X> 	Concatenation([6],powermon(1,81))],[1,1,1]];;[104X
    [4Xgap> p9 := [[Concatenation([],powermon(1,1)),Concatenation([4],powermon(2,1)),[104X
    [4X> 	Concatenation([5],powermon(1,27))],[1,1,1]];;[104X
    [4Xgap> p10 := [[Concatenation([3],powermon(1,1)),Concatenation([5],powermon(2,1)),[104X
    [4X> 	Concatenation([6],powermon(1,27))],[1,1,1]];;[104X
    [4Xgap> p11 := [[Concatenation([4],powermon(1,1)),Concatenation([6],powermon(2,1))],[104X
    [4X> 	[1,1]];;[104X
    [4Xgap> p12 := [[Concatenation([],powermon(2,3)),Concatenation([],powermon(2,1))],[104X
    [4X> 	[1,-1]];;[104X
    [4Xgap> KI := [p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12];;[104X
    [4Xgap> for i in [1..5] do[104X
    [4X>     for j in [i+1..6] do[104X
    [4X>         Add(KI,comm(i,j));[104X
    [4X>     od;[104X
    [4X> od;[104X
  [4X[32X[104X
  
  [33X[0;0YThe relations can be shown with [2XPrintNPList[102X ([14X3.2-3[114X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(KI);[104X
    [4X ea [104X
    [4X a^3 + fa [104X
    [4X a^9 + ca^3 [104X
    [4X a^81 + ca^9 + da^3 [104X
    [4X ca^81 + da^9 + ea^3 [104X
    [4X a^27 + da^81 + ea^9 + fa^3 [104X
    [4X b + ca^27 + ea^81 + fa^9 [104X
    [4X cb + da^27 + fa^81 [104X
    [4X a + db + ea^27 [104X
    [4X ca + eb + fa^27 [104X
    [4X da + fb [104X
    [4X b^3 - b [104X
    [4X ab - ba [104X
    [4X ac - ca [104X
    [4X ad - da [104X
    [4X ae - ea [104X
    [4X af - fa [104X
    [4X bc - cb [104X
    [4X bd - db [104X
    [4X be - eb [104X
    [4X bf - fb [104X
    [4X cd - dc [104X
    [4X ce - ec [104X
    [4X cf - fc [104X
    [4X de - ed [104X
    [4X df - fd [104X
    [4X ef - fe [104X
    [4Xgap> Length(KI);[104X
    [4X27[104X
  [4X[32X[104X
  
  [33X[0;0YIt  is sometimes easier to enter the relations as elements of a free algebra
  and then use the function [2XGP2NP[102X ([14X3.1-1[114X) or the function [2XGP2NPList[102X ([14X3.1-2[114X) to
  convert  them. This will be demonstrated below. More about converting can be
  read in Section [14X3.1[114X.[133X
  
  [4X[32X[104X
    [4Xgap> F:=Rationals;;[104X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(F,"a","b","c","d","e","f");;[104X
    [4Xgap> a:=A.a;; b:=A.b;; c:=A.c;; d:=A.d;; e:=A.e;; f:=A.f;;[104X
    [4Xgap> KI_gp:=[e*a,                         #p1[104X
    [4X>         a^3 + f*a,                      #p2[104X
    [4X>         a^9 + c*a^3,                    #p3[104X
    [4X>         a^81 + c*a^9 + d*a^3,           #p4[104X
    [4X>         c*a^81 + d*a^9 + e*a^3,         #p5[104X
    [4X>         a^27 + d*a^81 + e*a^9 + f*a^3,  #p6[104X
    [4X>         b + c*a^27 + e*a^81 + f*a^9,    #p7[104X
    [4X>         c*b + d*a^27 + f*a^81,          #p8[104X
    [4X>         a + d*b + e*a^27,               #p9[104X
    [4X>         c*a + e*b + f*a^27,             #p10[104X
    [4X>         d*a + f*b,                      #p11[104X
    [4X>         b^3 - b];;                      #p12[104X
  [4X[32X[104X
  
  [33X[0;0YThese  relations  can  be  converted  to  NP  form  (see [14X2.1[114X) with [2XGP2NPList[102X
  ([14X3.1-2[114X).  For  use  in  a  GrÃ¶bner basis computation we have to order the NP
  polynomials in [10XKI[110X. This can be done with [2XCleanNP[102X ([14X3.3-7[114X).[133X
  
  [4X[32X[104X
    [4Xgap> KI_np:=GP2NPList(KI_gp);;[104X
    [4Xgap> Apply(KI,x->CleanNP(x));;[104X
    [4Xgap> KI_np=KI{[1..12]};[104X
    [4Xtrue[104X
  [4X[32X[104X
  
  [33X[0;0YThe  GrÃ¶bner  basis  can now be calculated with [2XSGrobner[102X ([14X3.4-2[114X) and printed
  with [2XPrintNPList[102X ([14X3.2-3[114X).[133X
  
  [4X[32X[104X
    [4Xgap> GB := SGrobner(KI);;[104X
    [4X#I  number of entered polynomials is 27[104X
    [4X#I  number of polynomials after reduction is 8[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  List of todo lengths is [ 0 ][104X
    [4X#I  End of phase III[104X
    [4X#I  G: Cleaning finished, 0 polynomials reduced[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 748 msecs.[104X
    [4Xgap> PrintNPList(GB);[104X
    [4X a [104X
    [4X b [104X
    [4X dc - cd [104X
    [4X ec - ce [104X
    [4X ed - de [104X
    [4X fc - cf [104X
    [4X fd - df [104X
    [4X fe - ef [104X
  [4X[32X[104X
  
  
  [1XA.8 [33X[0;0YThe Birman-Murakami-Wenzl algebra of type A[22X_3[122X[101X[1X[133X[101X
  
  [33X[0;0YWe  study  the Birman-Murakami-Wenzl algebra of type A[22X_3[122X as an algebra given
  by generators and relations. A reference for the relations used is [CGW05].[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 1
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 1 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[104X
  [4X[32X[104X
  
  [33X[0;0YThe  variables  are [22Xg_1[122X, [22Xg_2[122X, [22Xg_3[122X, [22Xe_1[122X, [22Xe_2[122X, [22Xe_3[122X, in this order. In order to
  have  the results printed out with these symbols, we invoke [2XGBNP.ConfigPrint[102X
  ([14X3.2-2[114X)[133X
  
  [4X[32X[104X
    [4Xgap> GBNP.ConfigPrint("g1","g2","g3","e1","e2","e3");[104X
  [4X[32X[104X
  
  [33X[0;0YNow  enter  the  relations.  This  will  be  done  in NP form (see [14X2.1[114X). The
  inderminates  [22Xm[122X  and  [22Xl[122X in the coefficient ring of the Birman-Murakami-Wenzl
  algebra  are  specialized to 7 and 11 in order to make the computations more
  efficient.[133X
  
  [4X[32X[104X
    [4Xgap> m:= 7;;[104X
    [4Xgap> l:= 11;;[104X
    [4X[104X
    [4Xgap> #relations Theorem 1.1[104X
    [4Xgap> k1 := [[[4],[1,1],[1],[]],[1,-l/m,-l,l/m]];;[104X
    [4Xgap> k2 := [[[5],[2,2],[2],[]],[1,-l/m,-l,l/m]];;[104X
    [4Xgap> k3 := [[[6],[3,3],[3],[]],[1,-l/m,-l,l/m]];;[104X
    [4X[104X
    [4Xgap> #relations B1[104X
    [4Xgap> #empty set here[104X
    [4X[104X
    [4Xgap> #relations B2:[104X
    [4Xgap> k4 := [[[1,2,1],[2,1,2]],[1,-1]];;[104X
    [4Xgap> k5 := [[[2,3,2],[3,2,3]],[1,-1]];;[104X
    [4Xgap> k6 := [[[1,3],[3,1]],[1,-1]];;[104X
    [4X[104X
    [4Xgap> #relations R1[104X
    [4Xgap> kr1 := [[[1,4],[4]],[1,-1/l]];;[104X
    [4Xgap> kr2 := [[[2,5],[5]],[1,-1/l]];;[104X
    [4Xgap> kr3 := [[[3,6],[6]],[1,-1/l]];;[104X
    [4X[104X
    [4Xgap> #relations R2:[104X
    [4Xgap> kr4 := [[[4,2,4],[4]],[1,-l]];;[104X
    [4Xgap> kr5 := [[[5,1,5],[5]],[1,-l]];;[104X
    [4Xgap> kr6 := [[[5,3,5],[5]],[1,-l]];;[104X
    [4Xgap> kr7 := [[[6,2,6],[6]],[1,-l]];;[104X
    [4X[104X
    [4Xgap> #relations R2'[104X
    [4Xgap> km1 := [[[4,5,4],[4]],[1,-1]];;[104X
    [4Xgap> km2 := [[[5,4,5],[5]],[1,-1]];;[104X
    [4Xgap> km3 := [[[5,6,5],[5]],[1,-1]];;[104X
    [4Xgap> km4 := [[[6,5,6],[6]],[1,-1]];;[104X
    [4X[104X
    [4Xgap> KI := [k1,k2,k3,k4,k5,k6,kr1,kr2,kr3,kr4,kr5,kr6,kr7,km1,km2,km3,km4];;[104X
  [4X[32X[104X
  
  [33X[0;0YNow print the relations with [2XPrintNPList[102X ([14X3.2-3[114X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(KI);[104X
    [4X e1 - 11/7g1^2 - 11g1 + 11/7 [104X
    [4X e2 - 11/7g2^2 - 11g2 + 11/7 [104X
    [4X e3 - 11/7g3^2 - 11g3 + 11/7 [104X
    [4X g1g2g1 - g2g1g2 [104X
    [4X g2g3g2 - g3g2g3 [104X
    [4X g1g3 - g3g1 [104X
    [4X g1e1 - 1/11e1 [104X
    [4X g2e2 - 1/11e2 [104X
    [4X g3e3 - 1/11e3 [104X
    [4X e1g2e1 - 11e1 [104X
    [4X e2g1e2 - 11e2 [104X
    [4X e2g3e2 - 11e2 [104X
    [4X e3g2e3 - 11e3 [104X
    [4X e1e2e1 - e1 [104X
    [4X e2e1e2 - e2 [104X
    [4X e2e3e2 - e2 [104X
    [4X e3e2e3 - e3 [104X
    [4Xgap> Length(KI);[104X
    [4X17[104X
  [4X[32X[104X
  
  [33X[0;0YNow calculate the GrÃ¶bner basis with [2XSGrobner[102X ([14X3.4-2[114X):[133X
  
  [4X[32X[104X
    [4Xgap> GB := SGrobner(KI);;[104X
    [4X#I  number of entered polynomials is 17[104X
    [4X#I  number of polynomials after reduction is 17[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  End of phase III[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 76 msecs.[104X
    [4Xgap> PrintNPList(GB);[104X
    [4X g1^2 - 7/11e1 + 7g1 - 1 [104X
    [4X g1e1 - 1/11e1 [104X
    [4X g2^2 - 7/11e2 + 7g2 - 1 [104X
    [4X g2e2 - 1/11e2 [104X
    [4X g3g1 - g1g3 [104X
    [4X g3^2 - 7/11e3 + 7g3 - 1 [104X
    [4X g3e3 - 1/11e3 [104X
    [4X e1g1 - 1/11e1 [104X
    [4X e1g3 - g3e1 [104X
    [4X e1^2 + 43/77e1 [104X
    [4X e2g2 - 1/11e2 [104X
    [4X e2^2 + 43/77e2 [104X
    [4X e3g1 - g1e3 [104X
    [4X e3g3 - 1/11e3 [104X
    [4X e3e1 - e1e3 [104X
    [4X e3^2 + 43/77e3 [104X
    [4X g1g2e1 - e2e1 [104X
    [4X g1g3e1 - 1/11g3e1 [104X
    [4X g1e2e1 + 7e2e1 - g2e1 - 7e1 [104X
    [4X g2g1g2 - g1g2g1 [104X
    [4X g2g1e2 - e1e2 [104X
    [4X g2g3e2 - e3e2 [104X
    [4X g2e1g2 - g1e2g1 - 7e2g1 + 7e1g2 + 7g2e1 - 7g1e2 - 49e2 + 49e1 [104X
    [4X g2e1e2 + 7e1e2 - g1e2 - 7e2 [104X
    [4X g2e3e2 + 7e3e2 - g3e2 - 7e2 [104X
    [4X g3g2g3 - g2g3g2 [104X
    [4X g3g2e3 - e2e3 [104X
    [4X g3e1e3 - 1/11e1e3 [104X
    [4X g3e2g3 - g2e3g2 - 7e3g2 + 7e2g3 + 7g3e2 - 7g2e3 - 49e3 + 49e2 [104X
    [4X g3e2e3 + 7e2e3 - g2e3 - 7e3 [104X
    [4X e1g2g1 - e1e2 [104X
    [4X e1g2e1 - 11e1 [104X
    [4X e1e2g1 + 7e1e2 - e1g2 - 7e1 [104X
    [4X e1e2e1 - e1 [104X
    [4X e2g1g2 - e2e1 [104X
    [4X e2g1e2 - 11e2 [104X
    [4X e2g3g2 - e2e3 [104X
    [4X e2g3e2 - 11e2 [104X
    [4X e2e1g2 + 7e2e1 - e2g1 - 7e2 [104X
    [4X e2e1e2 - e2 [104X
    [4X e2e3g2 + 7e2e3 - e2g3 - 7e2 [104X
    [4X e2e3e2 - e2 [104X
    [4X e3g2g3 - e3e2 [104X
    [4X e3g2e3 - 11e3 [104X
    [4X e3e2g3 + 7e3e2 - e3g2 - 7e3 [104X
    [4X e3e2e3 - e3 [104X
    [4X g1g2g3e1 - e2g3e1 [104X
    [4X g1g3g2e1 - g3e2e1 [104X
    [4X g1g3e2e1 + 7g3e2e1 - g3g2e1 - 7g3e1 [104X
    [4X g1e2g3e1 + 7e2g3e1 - g2g3e1 - 7g3e1 [104X
    [4X g1e3g2e1 - e3e2e1 [104X
    [4X g1e3e2e1 + 7e3e2e1 - e3g2e1 - 7e1e3 [104X
    [4X g3g2g1g3 - g2g3g2g1 [104X
    [4X g3g2g1e3 - e2g1e3 [104X
    [4X g3g2e1e3 - e2e1e3 [104X
    [4X g3e1g2e3 - e1e2e3 [104X
    [4X g3e1e2e3 + 7e1e2e3 - e1g2e3 - 7e1e3 [104X
    [4X g3e2g1g3 - g2e3g2g1 - 7e3g2g1 + 7e2g1g3 + 7g3e2g1 - 7g2g1e3 + 49e2g1 - 49g1e3\[104X
    [4X [104X
    [4X g3e2g1e3 + 7e2g1e3 - g2g1e3 - 7g1e3 [104X
    [4X g3e2e1e3 + 7e2e1e3 - g2e1e3 - 7e1e3 [104X
    [4X e1g2g3g2 - g3e1g2g3 [104X
    [4X e1g2g3e1 - 11g3e1 [104X
    [4X e1g2e3g2 - g3e1e2g3 + 7e1e3g2 - 7e1e2g3 + 7e1g2e3 - 7g3e1e2 + 49e1e3 - 49e1e2\[104X
    [4X [104X
    [4X e1e2g3e1 - g3e1 [104X
    [4X e1e3g2g1 - e1e3e2 [104X
    [4X e1e3g2e1 - 11e1e3 [104X
    [4X e1e3e2g1 + 7e1e3e2 - e1e3g2 - 7e1e3 [104X
    [4X e1e3e2e1 - e1e3 [104X
    [4X e2g3e1e2 - e2g1e3e2 [104X
    [4X e2e1e3e2 + 7e2g1e3e2 - e2g1g3e2 - 77e2 [104X
    [4X e3g2g1g3 - e3e2g1 [104X
    [4X e3g2g1e3 - 11g1e3 [104X
    [4X e3g2e1e3 - 11e1e3 [104X
    [4X e3e2g1g3 + 7e3e2g1 - e3g2g1 - 7g1e3 [104X
    [4X e3e2g1e3 - g1e3 [104X
    [4X e3e2e1e3 - e1e3 [104X
    [4X g1g2g1g3e2 - g2g1e3e2 [104X
    [4X g1g2g1e3e2 + 7g2g1e3e2 - g2g1g3e2 - 7e1e2 [104X
    [4X g1g2g3g2e1 - g2e3g2e1 - 7e3g2e1 + 7e2g3e1 + 7g3e2e1 - 7g2e1e3 + 49e2e1 - 49e1\[104X
    [4Xe3 [104X
    [4X g1g2e3g2e1 + 7g2e3g2e1 - g2g3g2e1 + 7e3e2e1 + 49e3g2e1 + 7e2e1e3 - 7g3g2e1 + \[104X
    [4X49g2e1e3 - 7g2g3e1 + 343e1e3 - 49g3e1 - 49g2e1 - 350e1 [104X
    [4X g1e2g1g3e2 + 7e2g1g3e2 - g2e1e3e2 - 7g2g3e1e2 - 7e1e3e2 - 49g3e1e2 + 77g1e2 +\[104X
    [4X 539e2 [104X
    [4X g1e2g1e3e2 + 7e2g1e3e2 - g2g3e1e2 - 7g3e1e2 [104X
    [4X g2g3e1g2g3 - g1e2g1g3g2 - 7e2g1g3g2 + 7g3e1g2g3 + 7g2g3e1g2 + 49g3e1g2 - 7g1e\[104X
    [4X2e3 - 49e2e3 [104X
    [4X g2g3e1e2g3 - g1e2g1e3g2 - 7e2g1e3g2 + 7g3e1e2g3 + 7g2g3e1e2 - 7g1e2g1e3 - 49e\[104X
    [4X2g1e3 + 49g3e1e2 [104X
    [4X e2g1g3g2g1 - e2g1e3g2 [104X
    [4X e2g1g3e2g1 - e2e1e3g2 - 7e2g3e1g2 + 7e2g1g3e2 - 7e2e1e3 - 49e2g3e1 + 77e2g1 +\[104X
    [4X 539e2 [104X
    [4X e2g1e3g2g1 + 7e2g1e3g2 - e2g1g3g2 - 7e2e1 [104X
    [4X e2g1e3e2g1 - e2g3e1g2 + 7e2g1e3e2 - 7e2g3e1 [104X
    [4X e2g3e1g2g3 + 7e2g3e1g2 - e2g1g3g2 - 7e2e3 [104X
  [4X[32X[104X
  
  [33X[0;0YNow  calculate the dimension of the quotient algebra with [2XDimQA[102X ([14X3.5-2[114X) (the
  second argument is the number of symbols):[133X
  
  [4X[32X[104X
    [4Xgap> DimQA(GB,6);[104X
    [4X105[104X
  [4X[32X[104X
  
  [33X[0;0YThe conclusion is that the BMW algebra of type A3 has dimension 105.[133X
  
  
  [1XA.9 [33X[0;0YThe Birman-Murakami-Wenzl algebra of type A[22X_2[122X[101X[1X[133X[101X
  
  [33X[0;0YThe trace variant (see sections [14X2.5[114X and [14X3.7[114X) will be used for a presentation
  of the Birman-Murakami-Wenzl algebra of type A[22X_2[122X by generators and relations
  in order to find a proof that the algebra has dimension 15.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 1
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 1 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[104X
  [4X[32X[104X
  
  [33X[0;0YThe  variables  are  [22Xg_1[122X, [22Xg_2[122X, [22Xe_1[122X, [22Xe_2[122X, in this order. In order to have the
  results printed out with these symbols, we invoke [2XGBNP.ConfigPrint[102X ([14X3.2-2[114X)[133X
  
  [4X[32X[104X
    [4Xgap> GBNP.ConfigPrint("g1","g2","e1","e2");[104X
  [4X[32X[104X
  
  [33X[0;0YUnlike Example [14XA.8[114X, we work with a field of rational functions.[133X
  
  [4X[32X[104X
    [4Xgap> ll := Indeterminate(Rationals,"l");[104X
    [4Xl[104X
    [4Xgap> mm := Indeterminate(Rationals,"m");[104X
    [4Xm[104X
    [4Xgap> F := Field(ll,mm);[104X
    [4X<algebra-with-one over Field( [ 1 ] )>[104X
    [4Xgap> gens := GeneratorsOfField(F);[104X
    [4X[ l, m ][104X
    [4Xgap> l := gens[1];;[104X
    [4Xgap> m := gens[2];[104X
    [4Xm[104X
    [4Xgap> F1 := One(F);;[104X
    [4Xgap> Print("identity element of F: ",F1,"\n");[104X
    [4Xidentity element of F: 1[104X
  [4X[32X[104X
  
  [33X[0;0YNow enter the relations. This will be done in NP form.[133X
  
  [4X[32X[104X
    [4Xgap> #relations Theorem 1.1[104X
    [4Xgap> k1 := [[[3],[1,1],[1],[]],[F1,-l/m,-l,l/m]];;[104X
    [4Xgap> k2 := [[[4],[2,2],[2],[]],[F1,-l/m,-l,l/m]];;[104X
    [4X[104X
    [4Xgap> #relations B1[104X
    [4Xgap> #empty set here[104X
    [4X[104X
    [4Xgap> #relations B2:[104X
    [4Xgap> k3 := [[[1,2,1],[2,1,2]],[F1,-F1]];;[104X
    [4X[104X
    [4Xgap> #relations R1[104X
    [4Xgap> k4 := [[[1,3],[3]],[F1,-1/l]];;[104X
    [4Xgap> k5 := [[[2,4],[4]],[F1,-1/l]];;[104X
    [4X[104X
    [4Xgap> #relations R2:[104X
    [4Xgap> k6 := [[[3,2,3],[3]],[F1,-l]];;[104X
    [4Xgap> k7 := [[[4,1,4],[4]],[F1,-l]];;[104X
    [4Xgap> k8 := [[[3,4,3],[3]],[F1,-F1]];;[104X
    [4Xgap> k9 := [[[4,3,4],[4]],[F1,-F1]];;[104X
    [4X[104X
    [4Xgap> KI := [k1,k2,k3,k4,k5,k6,k7,k8,k9];;[104X
  [4X[32X[104X
  
  [33X[0;0YThe input can be displayed with [2XPrintNPList[102X ([14X3.2-3[114X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(KI);[104X
    [4X e1 + -l/mg1^2 + -lg1 + l/m [104X
    [4X e2 + -l/mg2^2 + -lg2 + l/m [104X
    [4X g1g2g1 + -1g2g1g2 [104X
    [4X g1e1 + -l^-1e1 [104X
    [4X g2e2 + -l^-1e2 [104X
    [4X e1g2e1 + -le1 [104X
    [4X e2g1e2 + -le2 [104X
    [4X e1e2e1 + -1e1 [104X
    [4X e2e1e2 + -1e2 [104X
  [4X[32X[104X
  
  [33X[0;0YNow  calculate  the GrÃ¶bner basis with trace information, using the function
  [2XSGrobnerTrace[102X ([14X3.7-5[114X):[133X
  
  [4X[32X[104X
    [4Xgap> GB := SGrobnerTrace(KI);;[104X
    [4X#I  number of entered polynomials is 9[104X
    [4X#I  number of polynomials after reduction is 9[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  List of todo lengths is [ 8, 7, 6, 5, 4, 6, 4, 4, 4, 3, 3, 2, 1, 0 ][104X
    [4X#I  End of phase III[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 484 msecs.[104X
  [4X[32X[104X
  
  [33X[0;0YThe  full  trace  can be printed with [2XPrintTraceList[102X ([14X3.7-2[114X), while printing
  only  the  relations  (and  no  trace)  can  be  invoked by [2XPrintNPListTrace[102X
  ([14X3.7-4[114X).   Since   the   total   trace   is   very   long  we  do  not  call
  [10XPrintTraceList(GB)[110X  here  but  only show two polynomial expressions from the
  GrÃ¶bner basis with [2XPrintTracePol[102X ([14X3.7-3[114X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPListTrace(GB);[104X
    [4X g1^2 + m/-le1 + mg1 + -1 [104X
    [4X g1e1 + -l^-1e1 [104X
    [4X g2^2 + m/-le2 + mg2 + -1 [104X
    [4X g2e2 + -l^-1e2 [104X
    [4X e1g1 + 1/-le1 [104X
    [4X e1^2 + (l^2-l*m-1)/(l*m)e1 [104X
    [4X e2g2 + 1/-le2 [104X
    [4X e2^2 + (l^2-l*m-1)/(l*m)e2 [104X
    [4X g1g2e1 + -1e2e1 [104X
    [4X g1e2e1 + me2e1 + -1g2e1 + -me1 [104X
    [4X g2g1g2 + 1/-1g1g2g1 [104X
    [4X g2g1e2 + -1e1e2 [104X
    [4X g2e1g2 + -1g1e2g1 + -me2g1 + me1g2 + mg2e1 + -mg1e2 + -m^2e2 + m^2e1 [104X
    [4X g2e1e2 + me1e2 + -1g1e2 + -me2 [104X
    [4X e1g2g1 + -1e1e2 [104X
    [4X e1g2e1 + -le1 [104X
    [4X e1e2g1 + me1e2 + -1e1g2 + -me1 [104X
    [4X e1e2e1 + -1e1 [104X
    [4X e2g1g2 + -1e2e1 [104X
    [4X e2g1e2 + -le2 [104X
    [4X e2e1g2 + me2e1 + -1e2g1 + -me2 [104X
    [4X e2e1e2 + -1e2 [104X
    [4Xgap> PrintTracePol(GB[1]);[104X
    [4X m/-lG(1) [104X
    [4Xgap> PrintTracePol(GB[10]);[104X
    [4X -l*m/(-l*m-1)G(1)g1e2e1 + -l*m/(l*m+1)g1G(1)e2e1 + l^2*m/(-l*m-1)G([104X
    [4X1)g2g1e1 + l*m^2/(-l*m-1)G(1)g2g1e2e1 + -l/(-l*m-1)g2G([104X
    [4X1)g1e2e1 + -l/(l*m+1)g2g1G(1)e2e1 + l^2/(-l*m-1)g2G([104X
    [4X1)g2g1e1 + l*m/(-l*m-1)g2G(1)g2g1e2e1 + -l*m/(-l*m-1)e1g2G([104X
    [4X1)g2g1e1 + -l/(-l*m-1)g2e1g2G(1)g2g1e1 + -m/-lG([104X
    [4X2)g1e2e1 + -l^2*m/(-l*m-1)g2g1G(2)e1 + -l^2/(-l*m-1)g2^2g1G([104X
    [4X2)e1 + m^2/(-l*m-1)e1G(2)g1e2e1 + m/(-l*m-1)g2e1G([104X
    [4X2)g1e2e1 + -l*m/(l*m+1)e1g2^2g1G(2)e1 + -l/(l*m+1)g2e1g2^2g1G([104X
    [4X2)e1 + l^3*m/(-l*m-1)G(3)e1 + l^3/(-l*m-1)g1G(3)e1 + l^3/(-l*m-1)G([104X
    [4X3)g2e1 + l^3/(-l*m-1)g2G(3)e1 + l^2*m^2/(-l*m-1)G(3)e2e1 + l^2*m/(-l*m-1)g1G([104X
    [4X3)e2e1 + l^3/(-l*m^2-m)g2g1G(3)e1 + l^3/(-l*m^2-m)g2G([104X
    [4X3)g2e1 + l^2*m/(-l*m-1)G(3)g2e2e1 + l^2*m/(-l*m-1)g2G([104X
    [4X3)e2e1 + -l^2*m/(-l*m-1)e1g2G(3)e1 + l^2/(-l*m-1)g2g1G([104X
    [4X3)e2e1 + l^2/(-l*m-1)g2G(3)g2e2e1 + -l^2/(-l*m-1)g2e1g2G([104X
    [4X3)e1 + -l^2/(-l*m-1)e1g2g1G(3)e1 + -l^2/(-l*m-1)e1g2G([104X
    [4X3)g2e1 + -l^2/(-l*m^2-m)g2e1g2g1G(3)e1 + -l^2/(-l*m^2-m)g2e1g2G([104X
    [4X3)g2e1 + -l*m/(-l*m-1)G(4)e2e1 + -l/(-l*m-1)g2G(4)e2e1 + -l*mg2g1G([104X
    [4X5)e1 + l^2*m/(-l*m-1)g2g1g2G(5)e1 + -lg2^2g1G(5)e1 + l^2/(-l*m-1)g2^2g1g2G([104X
    [4X5)e1 + l*m/(-l*m-1)G(6)g2g1e1 + l/(-l*m-1)g2G(6)g2g1e1 + m/-lG([104X
    [4X7)e1 + -m^2/(-l*m-1)e1G(7)e1 + -m/(-l*m-1)g2e1G(7)e1 + mG(8) + g2G(8) [104X
  [4X[32X[104X
  
  [33X[0;0YIn  order  to  test  whether  the expression for [10XGB[10][110X is as claimed we use
  [2XEvalTrace[102X  ([14X3.7-1[114X),  For  each  traced  polynomial  [10Xx[110X  in  [10XGB[110X, we equate the
  evaluated  expression  [10Xx.trace[110X, in which each occurrence of [10XG(i)[110X is replaced
  by [10XKI[i][110X by use of [2XEvalTrace[102X ([14X3.7-1[114X), with [10Xx.pol[110X.[133X
  
  [4X[32X[104X
    [4Xgap> ForAll(GB,x->EvalTrace(x,KI)=x.pol);[104X
    [4Xfalse[104X
  [4X[32X[104X
  
  [33X[0;0YAs  a  result  the  dimension of the quotient algebra can be calculated with
  [2XDimQA[102X ([14X3.5-2[114X) and the quotient algebra itself with [2XBaseQA[102X ([14X3.5-1[114X).[133X
  
  [4X[32X[104X
    [4Xgap> GB_pols:=List(GB,x->x.pol);;[104X
    [4Xgap> PrintNPList(GB_pols);[104X
    [4X g1^2 + m/-le1 + mg1 + -1 [104X
    [4X g1e1 + -l^-1e1 [104X
    [4X g2^2 + m/-le2 + mg2 + -1 [104X
    [4X g2e2 + -l^-1e2 [104X
    [4X e1g1 + 1/-le1 [104X
    [4X e1^2 + (l^2-l*m-1)/(l*m)e1 [104X
    [4X e2g2 + 1/-le2 [104X
    [4X e2^2 + (l^2-l*m-1)/(l*m)e2 [104X
    [4X g1g2e1 + -1e2e1 [104X
    [4X g1e2e1 + me2e1 + -1g2e1 + -me1 [104X
    [4X g2g1g2 + 1/-1g1g2g1 [104X
    [4X g2g1e2 + -1e1e2 [104X
    [4X g2e1g2 + -1g1e2g1 + -me2g1 + me1g2 + mg2e1 + -mg1e2 + -m^2e2 + m^2e1 [104X
    [4X g2e1e2 + me1e2 + -1g1e2 + -me2 [104X
    [4X e1g2g1 + -1e1e2 [104X
    [4X e1g2e1 + -le1 [104X
    [4X e1e2g1 + me1e2 + -1e1g2 + -me1 [104X
    [4X e1e2e1 + -1e1 [104X
    [4X e2g1g2 + -1e2e1 [104X
    [4X e2g1e2 + -le2 [104X
    [4X e2e1g2 + me2e1 + -1e2g1 + -me2 [104X
    [4X e2e1e2 + -1e2 [104X
    [4Xgap> DimQA(GB_pols,2);[104X
    [4X6[104X
    [4Xgap> B:=BaseQA(GB_pols,2,0);;[104X
    [4Xgap> PrintNPList(B);[104X
    [4X 1 [104X
    [4X g1 [104X
    [4X g2 [104X
    [4X g1g2 [104X
    [4X g2g1 [104X
    [4X g1g2g1 [104X
  [4X[32X[104X
  
  
  [1XA.10 [33X[0;0YA commutative example by Mora[133X[101X
  
  [33X[0;0YHere  we  present  a commutative example from page 339 of [21XAn introduction to
  commutative  and  non-commutative  GrÃ¶bner  Bases[121X,  by  Teo Mora [Mor94]. It
  involves  the  seven  variables  [22Xa,b,c,d,e,f,g[122X.  In order to force commuting
  between  each  pair from [22X{a,b,c,d,e,f,g}[122X, we let part of the input equations
  be  the  homogeneous  binomials  of  the  form  [22Xxy  -  yx[122X. GBNP is built for
  non-commutative  polynomial  arithmetic,  and  should handle the commutative
  case by means of this forced commutation. But it should not be considered as
  a serious alternative to the well-known GrÃ¶bner bases packages when it comes
  to efficiency.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 1
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 1 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[104X
  [4X[32X[104X
  
  [33X[0;0YThe  relations  will  be entered as GAP polynomials and converted to NP form
  (see [14X2.1[114X) with [2XGP2NPList[102X ([14X3.1-2[114X).[133X
  
  [4X[32X[104X
    [4Xgap> F:=GF(7);; ef:=One(F);;[104X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(F, "a", "b", "c", "d", "e", "f", "g");[104X
    [4X<algebra-with-one over GF(7), with 7 generators>[104X
    [4Xgap> gens:=GeneratorsOfAlgebra(A);[104X
    [4X[ (Z(7)^0)*<identity ...>, (Z(7)^0)*a, (Z(7)^0)*b, (Z(7)^0)*c, (Z(7)^0)*d, [104X
    [4X  (Z(7)^0)*e, (Z(7)^0)*f, (Z(7)^0)*g ][104X
    [4Xgap> a:=gens[2];; b:=gens[3];; c:=gens[4];; d:=gens[5];; e:=gens[6];; f:=gens[7];;[104X
    [4Xgap> g:=gens[8];; ea:=gens[1];;[104X
    [4X[104X
    [4Xgap> rels := [ a^3 + f*a, [104X
    [4X> 	a^9 + c*a^3 + g*a,[104X
    [4X> 	a^81 + c*a^9 + d*a^3,[104X
    [4X> 	c*a^81 + d*a^9 + e*a^3,[104X
    [4X> 	a^27 + d*a^81 + e*a^9 + f*a^3,[104X
    [4X> 	b + c*a^27 + e*a^81 + f*a^9 + g*a^3,[104X
    [4X> 	c*b + d*a^27 + f*a^81 + g*a^9,[104X
    [4X> 	a + d*b + e*a^27 + g*a^81,[104X
    [4X> 	c*a + e*b + f*a^27,[104X
    [4X> 	d*a + f*b + g*a^27,[104X
    [4X> 	e*a + g*b,[104X
    [4X> 	b^3 - b ];;[104X
  [4X[32X[104X
  
  [33X[0;0YSome relations added to enforce commutativity.[133X
  
  [4X[32X[104X
    [4Xgap> for i in [1..6] do[104X
    [4X>     for j in [i+1..7] do[104X
    [4X>         Add(rels,gens[i+1]*gens[j+1]-gens[j+1]*gens[i+1]);[104X
    [4X>     od;[104X
    [4X> od;[104X
  [4X[32X[104X
  
  [33X[0;0YNow  the  relations  are  converted  to  NP form (see [14X2.1[114X) with the function
  [2XGP2NPList[102X ([14X3.1-2[114X).[133X
  
  [4X[32X[104X
    [4Xgap> KI:=GP2NPList(rels);;[104X
  [4X[32X[104X
  
  [33X[0;0YThe  GrÃ¶bner  basis can be calculated with [2XSGrobner[102X ([14X3.4-2[114X) and printed with
  [2XPrintNPList[102X ([14X3.2-3[114X).[133X
  
  [4X[32X[104X
    [4Xgap> GB := SGrobner(KI);;[104X
    [4X#I  number of entered polynomials is 33[104X
    [4X#I  number of polynomials after reduction is 33[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  End of phase III[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 24820 msecs.[104X
    [4Xgap> PrintNPList(GB);[104X
    [4X a [104X
    [4X b [104X
    [4X dc + Z(7)^3cd [104X
    [4X ec + Z(7)^3ce [104X
    [4X ed + Z(7)^3de [104X
    [4X fc + Z(7)^3cf [104X
    [4X fd + Z(7)^3df [104X
    [4X fe + Z(7)^3ef [104X
    [4X gc + Z(7)^3cg [104X
    [4X gd + Z(7)^3dg [104X
    [4X ge + Z(7)^3eg [104X
    [4X gf + Z(7)^3fg [104X
  [4X[32X[104X
  
  [33X[0;0YTo  determine  whether  the quotient algebra is finite dimensional we invoke
  [2XFinCheckQA[102X  ([14X3.6-2[114X),  using  as arguments the leading monomials of [10XGB[110X and 7,
  the  number  of variables involved. The leading monomials of [10XGB[110X are obtained
  by [2XLMonsNP[102X ([14X3.3-10[114X).[133X
  
  [4X[32X[104X
    [4Xgap> F := LMonsNP(GB);;[104X
    [4Xgap> FinCheckQA(F,7);[104X
    [4Xfalse[104X
  [4X[32X[104X
  
  [33X[0;0YThus,  the quotient algebra turns out to be infinite dimensional. This is no
  surprise  as  the  GrÃ¶bner  basis  shows it is actually the free commutative
  algebra  generated  by [22Xc,d,e,f,g[122X. In particular, it has polynomial growth of
  degree  5.  This  is  confirmed by application of [2XDetermineGrowthQA[102X ([14X3.6-1[114X),
  with  the  first  two  arguments  as for [10XFinCheckQA[110X above and third argument
  [10Xfalse[110X,  indicating  that an interval for the degree of the polynomial degree
  will suffice.[133X
  
  [4X[32X[104X
    [4Xgap> DetermineGrowthQA(F,7,false);[104X
    [4X5[104X
  [4X[32X[104X
  
  [33X[0;0YIt  turns  out  that  this quick version already gives an exact answer. More
  time consuming would be the algorithm run with third argument equal to [10Xtrue[110X.[133X
  
  [4X[32X[104X
    [4Xgap> DetermineGrowthQA(F,7,true);[104X
    [4X5[104X
  [4X[32X[104X
  
  
  [1XA.11 [33X[0;0YTracing an example by Mora[133X[101X
  
  [33X[0;0YThis  example of a non-commutative GrÃ¶bner basis computation is from page 18
  of  [21XAn introduction to commutative and non-commutative GrÃ¶bner Bases[121X, by Teo
  Mora [Mor94]. The traced version of the algorithm will be used. The input is
  [22X{xyx-y,yxy-y}[122X. The answer should be [22X{yy-xy,yx-xy,xxy-y}[122X.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 2
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 1 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,2);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[104X
  [4X[32X[104X
  
  [33X[0;0YLet  the  variables  be  printed  as  [22Xx[122X and [22Xy[122X instead of [22Xa[122X and [22Xb[122X by means of
  [2XGBNP.ConfigPrint[102X ([14X3.2-2[114X)[133X
  
  [4X[32X[104X
    [4Xgap> GBNP.ConfigPrint("x","y");[104X
  [4X[32X[104X
  
  [33X[0;0YNext  we  input  the  relations in NP format (see Section [14X2.1[114X). They will be
  assigned to [10XKI[110X.[133X
  
  [4X[32X[104X
    [4Xgap> xyx := [[[1,2,1],[2]],[1,-1]];;[104X
    [4Xgap> yxy := [[[2,1,2],[2]],[1,-1]];;[104X
    [4Xgap> KI:=[xyx,yxy];;[104X
  [4X[32X[104X
  
  [33X[0;0YThe relations can be shown with [2XPrintNPList[102X ([14X3.2-3[114X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(KI);[104X
    [4X xyx - y [104X
    [4X yxy - y [104X
  [4X[32X[104X
  
  [33X[0;0YThe  GrÃ¶bner  basis  with  trace  can  now  be calculated with [2XSGrobnerTrace[102X
  ([14X3.7-5[114X):[133X
  
  [4X[32X[104X
    [4Xgap> GB := SGrobnerTrace(KI);[104X
    [4X#I  number of entered polynomials is 2[104X
    [4X#I  number of polynomials after reduction is 2[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  j =2[104X
    [4X#I  Current number of elements in todo is 1[104X
    [4X#I  j =3[104X
    [4X#I  Current number of elements in todo is 0[104X
    [4X#I  List of todo lengths is [ 2, 1, 0 ][104X
    [4X#I  End of phase III[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 4 msecs.[104X
    [4X[ rec( pol := [ [ [ 2, 1 ], [ 1, 2 ] ], [ 1, -1 ] ], [104X
    [4X      trace := [ [ [  ], 1, [ 2 ], -1 ], [ [ 2 ], 1, [  ], 1 ], [104X
    [4X          [ [ 1 ], 2, [  ], 1 ], [ [  ], 2, [ 1 ], -1 ] ] ), [104X
    [4X  rec( pol := [ [ [ 2, 2 ], [ 1, 2 ] ], [ 1, -1 ] ], [104X
    [4X      trace := [ [ [ 2 ], 1, [  ], -1 ], [ [  ], 1, [ 2 ], -1 ], [104X
    [4X          [ [ 2 ], 1, [  ], 1 ], [ [  ], 2, [ 1 ], 1 ], [ [ 1 ], 2, [  ], 1 ],[104X
    [4X          [ [  ], 2, [ 1 ], -1 ] ] ), [104X
    [4X  rec( pol := [ [ [ 1, 1, 2 ], [ 2 ] ], [ 1, -1 ] ], [104X
    [4X      trace := [ [ [  ], 1, [  ], 1 ], [ [ 1 ], 1, [ 2 ], 1 ], [104X
    [4X          [ [ 1, 2 ], 1, [  ], -1 ], [ [ 1, 1 ], 2, [  ], -1 ], [104X
    [4X          [ [ 1 ], 2, [ 1 ], 1 ] ] ) ][104X
  [4X[32X[104X
  
  [33X[0;0YThe GrÃ¶bner basis can be printed with [2XPrintNPListTrace[102X ([14X3.7-4[114X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPListTrace(GB);[104X
    [4X yx - xy [104X
    [4X y^2 - xy [104X
    [4X x^2y - y [104X
  [4X[32X[104X
  
  [33X[0;0YThe trace of the GrÃ¶bner basis can be printed with [2XPrintTraceList[102X ([14X3.7-2[114X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintTraceList(GB);[104X
    [4X- G(1)y + yG(1) - G(2)x + xG(2) [104X
    [4X[104X
    [4X- G(1)y + xG(2) [104X
    [4X[104X
    [4X G(1) + xG(1)y - xyG(1) + xG(2)x - x^2G(2) [104X
  [4X[32X[104X
  
  
  [1XA.12 [33X[0;0YFiniteness of the Weyl group of type E[22X_6[122X[101X[1X[133X[101X
  
  [33X[0;0YThis example extends [14XA.5[114X, which computes the order of the Weyl group of type
  E[22X_6[122X.[133X
  
  [33X[0;0YHere, before the dimension is calculated, it is checked whether the quotient
  algebra   is  finite  dimensional  or  infinite  dimensional.  The  function
  [2XFinCheckQA[102X   ([14X3.6-2[114X)   is   used  for  this  computation.  For  the  use  of
  [2XPreprocessAnalysisQA[102X ([14X3.6-4[114X) to speed up the check, see Example [14XA.13[114X.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 1
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 2 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,2);[104X
  [4X[32X[104X
  
  [33X[0;0YThen  input  the  relations  in  NP  format  (see Section [14X2.1[114X). They will be
  assigned to [10XKI[110X. These relations are the same as those in Example 3.[133X
  
  [4X[32X[104X
    [4Xgap> k1 := [[[1,3,1],[3,1,3]],[1,-1]];;[104X
    [4Xgap> k2 := [[[4,3,4],[3,4,3]],[1,-1]];;[104X
    [4Xgap> k3 := [[[4,2,4],[2,4,2]],[1,-1]];;[104X
    [4Xgap> k4 := [[[4,5,4],[5,4,5]],[1,-1]];;[104X
    [4Xgap> k5 := [[[6,5,6],[5,6,5]],[1,-1]];;[104X
    [4Xgap> k6 := [[[1,2],[2,1]],[1,-1]];;[104X
    [4Xgap> k7 := [[[1,4],[4,1]],[1,-1]];;[104X
    [4Xgap> k8 := [[[1,5],[5,1]],[1,-1]];;[104X
    [4Xgap> k9 := [[[1,6],[6,1]],[1,-1]];;[104X
    [4Xgap> k10 := [[[2,3],[3,2]],[1,-1]];;[104X
    [4Xgap> k11 := [[[2,5],[5,2]],[1,-1]];;[104X
    [4Xgap> k12 := [[[2,6],[6,2]],[1,-1]];;[104X
    [4Xgap> k13 := [[[3,5],[5,3]],[1,-1]];;[104X
    [4Xgap> k14 := [[[3,6],[6,3]],[1,-1]];;[104X
    [4Xgap> k15 := [[[4,6],[6,4]],[1,-1]];;[104X
    [4Xgap> k16 := [[[1,1],[]],[1,-1]];;[104X
    [4Xgap> k17 := [[[2,2],[]],[1,-1]];;[104X
    [4Xgap> k18 := [[[3,3],[]],[1,-1]];;[104X
    [4Xgap> k19 := [[[4,4],[]],[1,-1]];;[104X
    [4Xgap> k20 := [[[5,5],[]],[1,-1]];;[104X
    [4Xgap> k21 := [[[6,6],[]],[1,-1]];;[104X
    [4Xgap> KI := [k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,[104X
    [4X>        k11,k12,k13,k14,k15,k16,k17,k18,k19,k20,k21[104X
    [4X>       ];;[104X
  [4X[32X[104X
  
  [33X[0;0YThe GrÃ¶bner basis can now be calculated with [2XSGrobner[102X ([14X3.4-2[114X):[133X
  
  [4X[32X[104X
    [4Xgap> GB := SGrobner(KI);;[104X
    [4X#I  number of entered polynomials is 21[104X
    [4X#I  number of polynomials after reduction is 21[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  End of phase III[104X
    [4X#I  Time needed to clean G :0[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 96 msecs.[104X
  [4X[32X[104X
  
  [33X[0;0YWe will check whether the quotient algebra is finite dimensional or infinite
  dimensional.  The  function  [2XFinCheckQA[102X ([14X3.6-2[114X) exists for this purpose. Its
  first  argument  is the list of leading monomials of a GrÃ¶bner basis and its
  second  argument  the  number  of  symbols.  The  leading  monomials  can be
  calculated with [2XLMonsNP[102X ([14X3.3-10[114X).[133X
  
  [4X[32X[104X
    [4Xgap> L:=LMonsNP(GB);;[104X
    [4Xgap> FinCheckQA(L,6);[104X
    [4Xtrue[104X
    [4Xgap> time;[104X
    [4X60[104X
  [4X[32X[104X
  
  [33X[0;0YIf a quotient algebra is finite dimensional, the dimension can be calculated
  with [2XDimQA[102X ([14X3.5-2[114X), the arguments are the GrÃ¶bner basis [10XGB[110X and the number of
  symbols [10X6[110X. Since [2XInfoGBNPTime[102X ([14X4.3-1[114X) is set to 2, we get timing information
  from [2XDimQA[102X ([14X3.5-2[114X):[133X
  
  [4X[32X[104X
    [4Xgap> dim := DimQA(GB,6);[104X
    [4X#I  The computation took 144 msecs.[104X
    [4X51840[104X
  [4X[32X[104X
  
  
  [1XA.13 [33X[0;0YPreprocessing for Weyl group computations[133X[101X
  
  [33X[0;0YThis  example  extends  Example  [14XA.5[114X  with  the  following action: after the
  GrÃ¶bner  basis computation, we first check if the quotient algebra is finite
  dimensional  or  infinite dimensional before we possibly try to compute that
  dimension. Preprocessing of the set of leading terms of the GrÃ¶bner basis is
  used  to  speed up the check. The functions [2XPreprocessAnalysisQA[102X ([14X3.6-4[114X) and
  [2XFinCheckQA[102X ([14X3.6-2[114X) are used for the computations. Even without preprocessing
  this  already  goes  fast.  Still,  preprocessing can speed up more involved
  cases.  For  instance,  after  adapting this example to run for E7, we found
  that preprocessing speeds up the computation from 400 secs to about 40 secs.
  (Be aware that GrÃ¶bner basis computation will take a while for E7.)[133X
  
  [33X[0;0YMore  information  about  the preprocessing can be found in the preprint [21XThe
  dimensionality   of   quotient   algebras[121X  [Kro03]  which  is  part  of  the
  documentation.[133X
  
  [33X[0;0YNote:  there  is  no  information  on  the  amount of preprocessing which is
  optimal,  but in general for big examples, even full preprocessing is better
  than using no preprocessing at all.[133X
  
  [33X[0;0YNote: Example [14XA.12[114X also determines if the quotient algebra appearing here is
  finite or infinite dimensional but does not use preprocessing.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 0
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 2 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,0);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,2);[104X
  [4X[32X[104X
  
  [33X[0;0YThen  input  the  relations  in  NP  format  (see Section [14X2.1[114X). They will be
  assigned to [10XKI[110X.[133X
  
  [4X[32X[104X
    [4Xgap> k1 := [[[1,3,1],[3,1,3]],[1,-1]];;[104X
    [4Xgap> k2 := [[[4,3,4],[3,4,3]],[1,-1]];;[104X
    [4Xgap> k3 := [[[4,2,4],[2,4,2]],[1,-1]];;[104X
    [4Xgap> k4 := [[[4,5,4],[5,4,5]],[1,-1]];;[104X
    [4Xgap> k5 := [[[6,5,6],[5,6,5]],[1,-1]];;[104X
    [4Xgap> k6 := [[[1,2],[2,1]],[1,-1]];;[104X
    [4Xgap> k7 := [[[1,4],[4,1]],[1,-1]];;[104X
    [4Xgap> k8 := [[[1,5],[5,1]],[1,-1]];;[104X
    [4Xgap> k9 := [[[1,6],[6,1]],[1,-1]];;[104X
    [4Xgap> k10 := [[[2,3],[3,2]],[1,-1]];;[104X
    [4Xgap> k11 := [[[2,5],[5,2]],[1,-1]];;[104X
    [4Xgap> k12 := [[[2,6],[6,2]],[1,-1]];;[104X
    [4Xgap> k13 := [[[3,5],[5,3]],[1,-1]];;[104X
    [4Xgap> k14 := [[[3,6],[6,3]],[1,-1]];;[104X
    [4Xgap> k15 := [[[4,6],[6,4]],[1,-1]];;[104X
    [4Xgap> k16 := [[[1,1],[]],[1,-1]];;[104X
    [4Xgap> k17 := [[[2,2],[]],[1,-1]];;[104X
    [4Xgap> k18 := [[[3,3],[]],[1,-1]];;[104X
    [4Xgap> k19 := [[[4,4],[]],[1,-1]];;[104X
    [4Xgap> k20 := [[[5,5],[]],[1,-1]];;[104X
    [4Xgap> k21 := [[[6,6],[]],[1,-1]];;[104X
    [4Xgap> KI := [k1,k2,k3,k4,k5,k6,k7,k8,k9,k10,[104X
    [4X>        k11,k12,k13,k14,k15,k16,k17,k18,k19,k20,k21[104X
    [4X>       ];;[104X
  [4X[32X[104X
  
  [33X[0;0YThe GrÃ¶bner basis can now be calculated with [2XSGrobner[102X ([14X3.4-2[114X):[133X
  
  [4X[32X[104X
    [4Xgap> GB := SGrobner(KI);;[104X
    [4X#I  Time needed to clean G :0[104X
    [4X#I  The computation took 104 msecs.[104X
  [4X[32X[104X
  
  [33X[0;0YCheck  the  dimensionality of the quotient algebra. We will check whether it
  is   finite   dimensional   or  infinite  dimensional.  In  case  of  finite
  dimensionality we can compute this dimension.[133X
  
  [33X[0;0YThe   function   [2XFinCheckQA[102X   ([14X3.6-2[114X),   which   is  used  to  check  finite
  dimensionality  has  as  first  argument  the list of leading monomials of a
  GrÃ¶bner  basis  and  as second argument the number of symbols. The monomials
  can  be  calculated  with  [2XLMonsNP[102X  ([14X3.3-10[114X). They then will be preprocessed
  using  4 recursions. If you want full preprocessing, use 0 instead of 4 as a
  parameter for the number of recursions.[133X
  
  [4X[32X[104X
    [4Xgap> L:=LMonsNP(GB);;[104X
    [4Xgap> L:=PreprocessAnalysisQA(L,6,4);;[104X
    [4Xgap> time;[104X
    [4X4[104X
    [4Xgap> fd:=FinCheckQA(L,6);[104X
    [4Xtrue[104X
    [4Xgap> time;[104X
    [4X4[104X
  [4X[32X[104X
  
  [33X[0;0YIf a quotient algebra is finite dimensional, the dimension can be calculated
  with [2XDimQA[102X ([14X3.5-2[114X), the arguments are the GrÃ¶bner basis [10XGB[110X and the number of
  symbols [10X6[110X. Since [2XInfoGBNPTime[102X ([14X4.3-1[114X) is set to 2, we get timing information
  from [2XDimQA[102X ([14X3.5-2[114X):[133X
  
  [4X[32X[104X
    [4Xgap> dim := DimQA(GB,6);[104X
    [4X#I  The computation took 176 msecs.[104X
    [4X51840[104X
  [4X[32X[104X
  
  
  [1XA.14 [33X[0;0YA quotient algebra with exponential growth[133X[101X
  
  [33X[0;0YThis  example  demonstrates  an  instance  in  which the quotient algebra is
  infinite   dimensional  and  has  exponential  growth.  We  start  out  with
  [10XKI[110X[22X:=[y^4-y^2,x^2y-xy][122X   and  obtain  a  GrÃ¶bner  basis  with  leading  terms
  [22X[xxy,yyy][122X.  The quotient algebra will thus have exponential growth since the
  cycles  [22X(xyyx)^n[122X and [22X(xy)^m[122X intersect in the common subwords [22Xxy[122X (and in [22Xyx[122X).
  This is explained in [Kro03]. The function [2XDetermineGrowthQA[102X ([14X3.6-1[114X) is used
  for the computation.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 2
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 1 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,2);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[104X
  [4X[32X[104X
  
  [33X[0;0YLet  the  variables  be  printed  as  [22Xx[122X and [22Xy[122X instead of [22Xa[122X and [22Xb[122X by means of
  [2XGBNP.ConfigPrint[102X ([14X3.2-2[114X)[133X
  
  [4X[32X[104X
    [4Xgap> GBNP.ConfigPrint("x","y");[104X
  [4X[32X[104X
  
  [33X[0;0YThen  input  the  relations  in  NP  format  (see Section [14X2.1[114X). They will be
  assigned to [10XKI[110X.[133X
  
  [4X[32X[104X
    [4Xgap> k1 := [[[2,2,2,2],[2,2]],[1,-1]];;[104X
    [4Xgap> k2 := [[[1,1,2],[1,2]],[1,-1]];;[104X
    [4Xgap> KI := [k1,k2];;[104X
    [4Xgap> PrintNPList(KI);[104X
    [4X y^4 - y^2 [104X
    [4X x^2y - xy [104X
  [4X[32X[104X
  
  [33X[0;0YWe  calculate the GrÃ¶bner basis with the function [2XSGrobner[102X ([14X3.4-2[114X) and print
  it with [2XPrintNPList[102X ([14X3.2-3[114X).[133X
  
  [4X[32X[104X
    [4Xgap> GB := SGrobner(KI);;[104X
    [4X#I  number of entered polynomials is 2[104X
    [4X#I  number of polynomials after reduction is 2[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  List of todo lengths is [ 0 ][104X
    [4X#I  End of phase III[104X
    [4X#I  G: Cleaning finished, 0 polynomials reduced[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 0 msecs.[104X
    [4Xgap> PrintNPList(GB);[104X
    [4X x^2y - xy [104X
    [4X y^4 - y^2 [104X
  [4X[32X[104X
  
  [33X[0;0YNext  we  check the dimensionality of the quotient algebra with the function
  [2XFinCheckQA[102X   ([14X3.6-2[114X)   or  the  function  [2XDetermineGrowthQA[102X  ([14X3.6-1[114X).  These
  functions  expect  as  first argument a list [3XF[103X of leading terms of a GrÃ¶bner
  basis,  which  can  be  calculated with the function [2XLMonsNP[102X ([14X3.3-10[114X) and as
  second  argument  the  number  of  symbols  (here  equal to 2). The function
  [2XDetermineGrowthQA[102X  ([14X3.6-1[114X)  will  not only report whether a GrÃ¶bner basis is
  finite, but will also provide information about its growth.[133X
  
  [4X[32X[104X
    [4Xgap> L:=LMonsNP(GB);[104X
    [4X[ [ 1, 1, 2 ], [ 2, 2, 2, 2 ] ][104X
    [4Xgap> fd:=FinCheckQA(L,2);[104X
    [4Xfalse[104X
    [4Xgap> fd:=DetermineGrowthQA(L,2,false);[104X
    [4X"exponential growth"[104X
  [4X[32X[104X
  
  [33X[0;0YAlthough the quotient algebra is infinite dimensional, multiplication of two
  elements can be carried out by [2XMulQA[102X ([14X3.5-5[114X). We print three positive powers
  of [22Xx+y[122X.[133X
  
  [4X[32X[104X
    [4Xgap> w := [[[1],[2]],[1,1]];;[104X
    [4Xgap> hlp := [[[]],[1]];;[104X
    [4Xgap> for i in [3..5] do [104X
    [4X>   hlp := MulQA(hlp, w, GB);[104X
    [4X>   Print("\n (x+y)^",i," = \n"); [104X
    [4X>   PrintNP(hlp);[104X
    [4X> od;[104X
    [4X[104X
    [4X (x+y)^3 = [104X
    [4X y + x [104X
    [4X[104X
    [4X (x+y)^4 = [104X
    [4X y^2 + yx + xy + x^2 [104X
    [4X[104X
    [4X (x+y)^5 = [104X
    [4X y^3 + y^2x + yxy + yx^2 + xy^2 + xyx + x^3 + xy [104X
  [4X[32X[104X
  
  
  [1XA.15 [33X[0;0YA commutative quotient algebra of polynomial growth[133X[101X
  
  [33X[0;0YThis  example extends [14XA.7[114X, a commutative example from Some Tapas of Computer
  Algebra [CCS99], page 339.[133X
  
  [33X[0;0YThe result of the GrÃ¶bner basis computation should be the union of [22X{a,b}[122X and
  the  set of 6 homogeneous binomials (that is, polynomials with two terms) of
  degree  2  forcing  commuting  between  [22Xc[122X,  [22Xd[122X,  [22Xe[122X,  and  [22Xf[122X, as before. After
  computation  of the GrÃ¶bner basis, the quotient algebra is studied and found
  to  be  infinite  dimensional of polynomial growth of degree 4. The function
  [2XDetermineGrowthQA[102X  ([14X3.6-1[114X)  is  used  for this computation. Then part of its
  Hilbert series is computed. The function [2XHilbertSeriesQA[102X ([14X3.6-3[114X) is used for
  the computations.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 2
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 1 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,2);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[104X
  [4X[32X[104X
  
  [33X[0;0YNow  define some functions which will help in the construction of relations.
  The  function  [10Xpowermon(i, exp)[110X will return the monomial [22Xi^exp[122X. The function
  [10Xcomm(aa,  bb)[110X  will  return a relation forcing commutativity between its two
  arguments [10Xaa[110X and [10Xbb[110X.[133X
  
  [4X[32X[104X
    [4Xgap> powermon := function(base, exp)[104X
    [4X>  local ans,i;[104X
    [4X>  ans := [];[104X
    [4X>  for i in [1..exp] do ans :=  Concatenation(ans,[base]); od;[104X
    [4X>  return ans;[104X
    [4X> end;;[104X
    [4X[104X
    [4Xgap> comm := function(aa,bb)[104X
    [4X>   return [[[aa,bb],[bb,aa]],[1,-1]];[104X
    [4X> end;;[104X
  [4X[32X[104X
  
  [33X[0;0YNow the relations are entered:[133X
  
  [4X[32X[104X
    [4Xgap> p1 := [[[5,1]],[1]];;[104X
    [4Xgap> p2 := [[powermon(1,3),[6,1]],[1,1]];;[104X
    [4Xgap> p3 := [[powermon(1,9),Concatenation([3],powermon(1,3))],[1,1]];;[104X
    [4Xgap> p4 := [[powermon(1,81),Concatenation([3],powermon(1,9)),Concatenation([4],[104X
    [4X> 	powermon(1,3))],[1,1,1]];;[104X
    [4Xgap> p5 := [[Concatenation([3],powermon(1,81)),Concatenation([4],powermon(1,9)),[104X
    [4X> 	Concatenation([5],powermon(1,3))],[1,1,1]];;[104X
    [4Xgap> p6 := [[powermon(1,27),Concatenation([4],powermon(1,81)),Concatenation([5],[104X
    [4X> 	powermon(1,9)),Concatenation([6],powermon(1,3))],[1,1,1,1]];;[104X
    [4Xgap> p7 := [[powermon(2,1),Concatenation([3],powermon(1,27)),Concatenation([5],[104X
    [4X> 	powermon(1,81)),Concatenation([6],powermon(1,9))],[1,1,1,1]];;[104X
    [4Xgap> p8 := [[Concatenation([3],powermon(2,1)),Concatenation([4],powermon(1,27)),[104X
    [4X> 	Concatenation([6],powermon(1,81))],[1,1,1]];;[104X
    [4Xgap> p9 := [[Concatenation([],powermon(1,1)),Concatenation([4],powermon(2,1)),[104X
    [4X> 	Concatenation([5],powermon(1,27))],[1,1,1]];;[104X
    [4Xgap> p10 := [[Concatenation([3],powermon(1,1)),Concatenation([5],powermon(2,1)),[104X
    [4X> 	Concatenation([6],powermon(1,27))],[1,1,1]];;[104X
    [4Xgap> p11 := [[Concatenation([4],powermon(1,1)),Concatenation([6],powermon(2,1))],[104X
    [4X> 	[1,1]];;[104X
    [4Xgap> p12 := [[Concatenation([],powermon(2,3)),Concatenation([],powermon(2,1))],[104X
    [4X> 	[1,-1]];;[104X
    [4Xgap> KI := [p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12];;[104X
    [4Xgap> for i in [1..5] do[104X
    [4X>     for j in [i+1..6] do[104X
    [4X>         Add(KI,comm(i,j));[104X
    [4X>     od;[104X
    [4X> od;[104X
  [4X[32X[104X
  
  [33X[0;0YThe relations can be shown with [2XPrintNPList[102X ([14X3.2-3[114X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(KI);[104X
    [4X ea [104X
    [4X a^3 + fa [104X
    [4X a^9 + ca^3 [104X
    [4X a^81 + ca^9 + da^3 [104X
    [4X ca^81 + da^9 + ea^3 [104X
    [4X a^27 + da^81 + ea^9 + fa^3 [104X
    [4X b + ca^27 + ea^81 + fa^9 [104X
    [4X cb + da^27 + fa^81 [104X
    [4X a + db + ea^27 [104X
    [4X ca + eb + fa^27 [104X
    [4X da + fb [104X
    [4X b^3 - b [104X
    [4X ab - ba [104X
    [4X ac - ca [104X
    [4X ad - da [104X
    [4X ae - ea [104X
    [4X af - fa [104X
    [4X bc - cb [104X
    [4X bd - db [104X
    [4X be - eb [104X
    [4X bf - fb [104X
    [4X cd - dc [104X
    [4X ce - ec [104X
    [4X cf - fc [104X
    [4X de - ed [104X
    [4X df - fd [104X
    [4X ef - fe [104X
  [4X[32X[104X
  
  [33X[0;0YIt  is  usually  easier  to  use  the function [2XGP2NP[102X ([14X3.1-1[114X) or the function
  [2XGP2NPList[102X  ([14X3.1-2[114X)  to  enter relations. Entering the first twelve relations
  and then converting them with [2XGP2NPList[102X ([14X3.1-2[114X) is demonstrated in example 6
  ([14XA.7[114X). More about converting can be read in Section [14X3.1[114X.[133X
  
  [33X[0;0YThe  GrÃ¶bner  basis  can now be calculated with [2XSGrobner[102X ([14X3.4-2[114X) and printed
  with [2XPrintNPList[102X ([14X3.2-3[114X).[133X
  
  [4X[32X[104X
    [4Xgap> GB := SGrobner(KI);[104X
    [4X#I  number of entered polynomials is 27[104X
    [4X#I  number of polynomials after reduction is 8[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  List of todo lengths is [ 0 ][104X
    [4X#I  End of phase III[104X
    [4X#I  G: Cleaning finished, 0 polynomials reduced[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 728 msecs.[104X
    [4X[ [ [ [ 1 ] ], [ 1 ] ], [ [ [ 2 ] ], [ 1 ] ], [104X
    [4X  [ [ [ 4, 3 ], [ 3, 4 ] ], [ 1, -1 ] ], [ [ [ 5, 3 ], [ 3, 5 ] ], [ 1, -1 ] ][104X
    [4X    , [ [ [ 5, 4 ], [ 4, 5 ] ], [ 1, -1 ] ], [104X
    [4X  [ [ [ 6, 3 ], [ 3, 6 ] ], [ 1, -1 ] ], [ [ [ 6, 4 ], [ 4, 6 ] ], [ 1, -1 ] ][104X
    [4X    , [ [ [ 6, 5 ], [ 5, 6 ] ], [ 1, -1 ] ] ][104X
    [4Xgap> PrintNPList(GB);[104X
    [4X a [104X
    [4X b [104X
    [4X dc - cd [104X
    [4X ec - ce [104X
    [4X ed - de [104X
    [4X fc - cf [104X
    [4X fd - df [104X
    [4X fe - ef [104X
  [4X[32X[104X
  
  [33X[0;0YThe  growth  of  the  quotient algebra can be studied with [2XDetermineGrowthQA[102X
  ([14X3.6-1[114X).  The  first argument is the list of leading monomials, which can be
  calculated  with  [2XLMonsNP[102X  ([14X3.3-10[114X).  The second argument is the size of the
  alphabet.[133X
  
  [4X[32X[104X
    [4Xgap> L:=LMonsNP(GB);;[104X
    [4Xgap> DetermineGrowthQA(L,6,false);[104X
    [4X4[104X
    [4Xgap> time;[104X
    [4X0[104X
  [4X[32X[104X
  
  [33X[0;0YNow  compute  the  first 10 terms of the Hilbert Series with [2XHilbertSeriesQA[102X
  ([14X3.6-3[114X) (note that trailing zeroes are removed):[133X
  
  [4X[32X[104X
    [4Xgap> HilbertSeriesQA(L,6,10);[104X
    [4X[ 1, 4, 10, 20, 35, 56, 84, 120, 165, 220, 286 ][104X
  [4X[32X[104X
  
  
  [1XA.16 [33X[0;0YAn algebra over a finite field[133X[101X
  
  [33X[0;0YA  small example over a field other than the rationals, using the conversion
  functions from [14X3.1[114X. The input relations define the symmetric group of degree
  3, denoted [22XS_3[122X.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 2
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 1 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,2);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[104X
  [4X[32X[104X
  
  [33X[0;0YLet [10XF[110X be the field GF(2). The relations can be entered as elements of a free
  associative algebra with one [10XA[110X (see [14XReference: FreeAssociativeAlgebraWithOne
  (for ring, rank (and name))[114X).[133X
  
  [4X[32X[104X
    [4Xgap> F:=GF(2);;[104X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(F,"a","b");[104X
    [4X<algebra-with-one over GF(2), with 2 generators>[104X
    [4Xgap> g:=GeneratorsOfAlgebraWithOne(A);[104X
    [4X[ (Z(2)^0)*a, (Z(2)^0)*b ][104X
  [4X[32X[104X
  
  [33X[0;0YEnter  the  relations  [22X{a^2-1,b^2-1,(ab)^3-1}[122X,  convert them to NP-form, see
  Section [14X2.1[114X, with [2XGP2NPList[102X ([14X3.1-2[114X) and print them with [2XPrintNPList[102X ([14X3.2-3[114X):[133X
  
  [4X[32X[104X
    [4Xgap> KI_GP := [ g[1]^2-g[1]^0, g[2]^2-g[1]^0, (g[1]*g[2])^3-g[1]^0];[104X
    [4X[ (Z(2)^0)*<identity ...>+(Z(2)^0)*a^2, (Z(2)^0)*<identity ...>+(Z(2)^0)*b^2, [104X
    [4X  (Z(2)^0)*<identity ...>+(Z(2)^0)*(a*b)^3 ][104X
    [4Xgap> KI:=GP2NPList(KI_GP);;[104X
    [4Xgap> PrintNPList(KI);[104X
    [4X a^2 + Z(2)^0 [104X
    [4X b^2 + Z(2)^0 [104X
    [4X ababab + Z(2)^0 [104X
  [4X[32X[104X
  
  [33X[0;0YNow  calculate  the  GrÃ¶bner  basis  with [2XSGrobner[102X ([14X3.4-2[114X) and print it with
  [2XPrintNPList[102X ([14X3.2-3[114X):[133X
  
  [4X[32X[104X
    [4Xgap> GB:=SGrobner(KI);;[104X
    [4X#I  number of entered polynomials is 3[104X
    [4X#I  number of polynomials after reduction is 3[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  length of G =3[104X
    [4X#I  length of todo is 2[104X
    [4X#I  length of G =3[104X
    [4X#I  length of todo is 1[104X
    [4X#I  length of G =3[104X
    [4X#I  length of todo is 0[104X
    [4X#I  List of todo lengths is [ 2, 2, 1, 0 ][104X
    [4X#I  End of phase III[104X
    [4X#I  G: Cleaning finished, 0 polynomials reduced[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 0 msecs.[104X
    [4Xgap> PrintNPList(GB);[104X
    [4X a^2 + Z(2)^0 [104X
    [4X b^2 + Z(2)^0 [104X
    [4X bab + aba [104X
  [4X[32X[104X
  
  [33X[0;0YNow  calculate  the  dimension of the quotient algebra with [2XDimQA[102X ([14X3.5-2[114X) (2
  symbols)  and  a  base with [2XBaseQA[102X ([14X3.5-1[114X) (2 symbols, 0 for whole base) and
  print the base. This will give a list of elements of the group.[133X
  
  [4X[32X[104X
    [4Xgap> DimQA(GB,2);[104X
    [4X6[104X
    [4Xgap> B:=BaseQA(GB,2,0);;[104X
    [4Xgap> PrintNPList(B);[104X
    [4X Z(2)^0 [104X
    [4X a [104X
    [4X b [104X
    [4X ab [104X
    [4X ba [104X
    [4X aba [104X
  [4X[32X[104X
  
  [33X[0;0YWe  can  print  the  GrÃ¶bner  basis  and  the basis of the quotient algebra,
  converted back to GAP polynomials with [2XNP2GPList[102X ([14X3.1-4[114X). The functions used
  to  convert  the  polynomials  also  require the algebra as an argument. The
  result is useful for further computations in [22XA[122X.[133X
  
  [4X[32X[104X
    [4Xgap> NP2GPList(GB,A);[104X
    [4X[ (Z(2)^0)*a^2+(Z(2)^0)*<identity ...>, (Z(2)^0)*b^2+(Z(2)^0)*<identity ...>, [104X
    [4X  (Z(2)^0)*b*a*b+(Z(2)^0)*a*b*a ][104X
    [4Xgap> NP2GPList(B,A);[104X
    [4X[ (Z(2)^0)*<identity ...>, (Z(2)^0)*a, (Z(2)^0)*b, (Z(2)^0)*a*b, [104X
    [4X  (Z(2)^0)*b*a, (Z(2)^0)*a*b*a ][104X
  [4X[32X[104X
  
  [33X[0;0YThe  matrix of right multiplication with the image of the first variable can
  be computed by [2XMatrixQA[102X ([14X3.5-3[114X).[133X
  
  [4X[32X[104X
    [4Xgap> Display(MatrixQA(1,B,GB));[104X
    [4X . 1 . . . .[104X
    [4X 1 . . . . .[104X
    [4X . . . . 1 .[104X
    [4X . . . . . 1[104X
    [4X . . 1 . . .[104X
    [4X . . . 1 . .[104X
  [4X[32X[104X
  
  
  [1XA.17 [33X[0;0YThe dihedral group of order 8[133X[101X
  
  [33X[0;0YIn this example (Example 1 from Linton [Lin93]) the two-sided relations give
  the  group algebra of the group with presentation [22XâŸ¨ a,b âˆ£ a^4=b^2=(ab)^2=1âŸ©[122X,
  the  dihedral  group  of  order 8. It is possible to construct a permutation
  module  of  degree 4, over a field [10Xk[110X. In this example [10Xk[110X will be the field of
  rational numbers.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 1
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 1 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[104X
  [4X[32X[104X
  
  [33X[0;0YNow  enter  the  relations  as GAP polynomials. It is possible to enter them
  with  and  without  module  generators.  First  it is shown how to enter the
  relations  without  using a module. It is possible to enter them with a free
  associative algebra with one over the field (the rational numbers) (see also
  [14XReference:  FreeAssociativeAlgebraWithOne  (for ring, rank (and name))[114X). For
  convenience  we  use the variables [10Xa[110X and [10Xb[110X for the generators of the algebra
  and [10Xe[110X for the one of the algebra.[133X
  
  [4X[32X[104X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(Rationals, "a", "b");[104X
    [4X<algebra-with-one over Rationals, with 2 generators>[104X
    [4Xgap> a:=A.a;;b:=A.b;;e:=One(A);;[104X
  [4X[32X[104X
  
  [33X[0;0YNow the relations are entered:[133X
  
  [4X[32X[104X
    [4Xgap> twosidrels:=[a^4-e,b^2-e,(a*b)^2-e];;[104X
    [4Xgap> prefixrels:=[b-e];;[104X
  [4X[32X[104X
  
  [33X[0;0YFirst  the  relations  are  converted into NP format, see Section [14X2.1[114X, after
  which  the  function [2XSGrobnerModule[102X ([14X3.9-1[114X) is called to calculate a GrÃ¶bner
  basis record.[133X
  
  [4X[32X[104X
    [4Xgap> GBR:=SGrobnerModule(GP2NPList(prefixrels),GP2NPList(twosidrels));;[104X
    [4X#I  number of entered polynomials is 3[104X
    [4X#I  number of polynomials after reduction is 3[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  End of phase III[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 0 msecs.[104X
    [4X#I  number of entered polynomials is 7[104X
    [4X#I  number of polynomials after reduction is 7[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  End of phase III[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 4 msecs.[104X
  [4X[32X[104X
  
  [33X[0;0YThe  record  GBR  has  two  members:  the two-sided relations [10XGBR.ts[110X and the
  prefix  relations  [10XGBR.p[110X.  It  is possible to print these using the function
  [2XPrintNPList[102X ([14X3.2-3[114X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(GBR.ts);[104X
    [4X b^2 - 1 [104X
    [4X aba - b [104X
    [4X ba^2 - a^2b [104X
    [4X bab - a^3 [104X
    [4X a^4 - 1 [104X
    [4X a^3b - ba [104X
    [4Xgap> PrintNPList(GBR.p);[104X
    [4X[ b - 1 ][104X
    [4X[ a^3 - ab ][104X
    [4X[ a^2b - a^2 ][104X
  [4X[32X[104X
  
  [33X[0;0YIt  is  now  possible to calculate the standard basis of the quotient module
  with the function [2XBaseQM[102X ([14X3.9-2[114X). This function has as arguments the GrÃ¶bner
  basis record [10XGBR[110X, the number of generators of the algebra (2), the number of
  generators  of  the  module  (1), and a variable [10Xmaxno[110X for returning partial
  bases (0 means full basis).[133X
  
  [4X[32X[104X
    [4Xgap> B:=BaseQM(GBR,2,1,0);;[104X
    [4Xgap> PrintNPList(B);[104X
    [4X[ 1 ][104X
    [4X[ a ][104X
    [4X[ a^2 ][104X
    [4X[ ab ][104X
  [4X[32X[104X
  
  [33X[0;0YIt  is  also  possible  to  use  a  module with one generator to enter these
  relations:[133X
  
  [4X[32X[104X
    [4Xgap> D:=A^1;;[104X
    [4Xgap> gd:=GeneratorsOfLeftModule(D);;[104X
    [4Xgap> prefixrelsdom:=[gd[1]*(b-e)];;[104X
  [4X[32X[104X
  
  [33X[0;0YIt  is  possible  to  use  the  two-sided  GrÃ¶bner  basis  which was already
  calculated.[133X
  
  [4X[32X[104X
    [4Xgap> GBR:=SGrobnerModule(GP2NPList(prefixrelsdom),GBR.ts);;[104X
    [4X#I  number of entered polynomials is 6[104X
    [4X#I  number of polynomials after reduction is 6[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  End of phase III[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 4 msecs.[104X
    [4X#I  number of entered polynomials is 7[104X
    [4X#I  number of polynomials after reduction is 7[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  End of phase III[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 0 msecs.[104X
    [4Xgap> PrintNPList(GBR.p);;[104X
    [4X[ b - 1 ][104X
    [4X[ a^3 - ab ][104X
    [4X[ a^2b - a^2 ][104X
    [4Xgap> B:=BaseQM(GBR,2,1,0);;[104X
    [4Xgap> PrintNPList(B);[104X
    [4X[ 1 ][104X
    [4X[ a ][104X
    [4X[ a^2 ][104X
    [4X[ ab ][104X
  [4X[32X[104X
  
  [33X[0;0YTo   compute  the  image  of  right  multiplication  of  the  basis  element
  [10XB[Length(B)][110X  of  the module with the quotient algebra element corresponding
  to  [22Xab[122X  we  use  the  function  [2XMulQM[102X  ([14X3.9-4[114X)  with arguments [10XB[Length(B)][110X,
  [10XGB2NP(a*b)[110X,  and  [10XGBR[110X  We  subsequently  use  [2XPrintNP[102X ([14X3.2-1[114X) to display the
  result as a 1-dimensional vector with an entry from [22XA[122X.[133X
  
  [4X[32X[104X
    [4Xgap> v := MulQM(B[Length(B)],GP2NP(a*b),GBR);[104X
    [4X[ [ [ -1 ] ], [ 1 ] ][104X
    [4Xgap> PrintNP(v);[104X
    [4X[ 1 ][104X
  [4X[32X[104X
  
  
  [1XA.18 [33X[0;0YThe dihedral group of order 8 on another module[133X[101X
  
  [33X[0;0YIn this example (Example 2 from Linton [Lin93]) the two-sided relations give
  the  group  algebra of the group with presentation [22XâŸ¨ a,bâˆ£ a^4=b^2=(ab)^2=1âŸ©[122X,
  the dihedral group of order 8. This module relation fixes the all-one vector
  of Example [14XA.17[114X: [22X1 + a(1+a+b)[122X.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 0
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 0 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,0);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,0);[104X
  [4X[32X[104X
  
  [33X[0;0YWe  will  enter  the  relations  as GAP polynomials. It is possible to enter
  these  with  and  without  a  module.  How  to do this is shown in [14XA.17[114X. The
  relations  here  are  entered  without  a  module,  since the module is only
  one-dimensional.  It  is  possible  to  enter  them using a free associative
  algebra  with one over the field (the rational numbers) (see also [14XReference:
  FreeAssociativeAlgebraWithOne  (for ring, rank (and name))[114X). For convenience
  we use the variables [10Xa[110X and [10Xb[110X for the generators of the algebra and [10Xe[110X for the
  one of the algebra.[133X
  
  [4X[32X[104X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(Rationals, "a", "b");[104X
    [4X<algebra-with-one over Rationals, with 2 generators>[104X
    [4Xgap> g:=GeneratorsOfAlgebra(A);;[104X
    [4Xgap> a:=g[2];;b:=g[3];;e:=g[1];;[104X
  [4X[32X[104X
  
  [33X[0;0YNow the relations are entered:[133X
  
  [4X[32X[104X
    [4Xgap> twosidrels:=[a^4-e,b^2-e,(a*b)^2-e];;[104X
    [4Xgap> prefrels:=[ b-e, e + a * (e + a + b) ];;[104X
  [4X[32X[104X
  
  [33X[0;0YFirst  the  relations are converted into NP format (see [14X2.1[114X) after which the
  function  [2XSGrobnerModule[102X  ([14X3.9-1[114X)  is  called  to  calculate a GrÃ¶bner basis
  record.[133X
  
  [4X[32X[104X
    [4Xgap> GBR:=SGrobnerModule(GP2NPList(prefrels),GP2NPList(twosidrels));;[104X
  [4X[32X[104X
  
  [33X[0;0YThe  record  GBR  has  two  members:  the two-sided relations [10XGBR.ts[110X and the
  prefix  relations  [10XGBR.p[110X.  It  is possible to print these using the function
  [2XPrintNPList[102X ([14X3.2-3[114X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(GBR.ts);[104X
    [4X b^2 - 1 [104X
    [4X aba - b [104X
    [4X ba^2 - a^2b [104X
    [4X bab - a^3 [104X
    [4X a^4 - 1 [104X
    [4X a^3b - ba [104X
    [4Xgap> PrintNPList(GBR.p);[104X
    [4X[ b - 1 ][104X
    [4X[ ab + a^2 + a + 1 ][104X
    [4X[ a^3 + a^2 + a + 1 ][104X
    [4X[ a^2b - a^2 ][104X
  [4X[32X[104X
  
  [33X[0;0YIt  is  now  possible to calculate the standard basis of the quotient module
  with the function [2XBaseQM[102X ([14X3.9-2[114X). This function has as arguments the GrÃ¶bner
  basis  record  [10XGBR[110X,  the number of generators of the algebra (here it is 2),
  the  number of generators of the mdoule (here it is 1), and a variable [10Xmaxno[110X
  for returning partial bases (0 means full basis).[133X
  
  [4X[32X[104X
    [4Xgap> B:=BaseQM(GBR,2,1,0);;[104X
    [4Xgap> PrintNPList(B);[104X
    [4X[ 1 ][104X
    [4X[ a ][104X
    [4X[ a^2 ][104X
  [4X[32X[104X
  
  
  [1XA.19 [33X[0;0YThe dihedral group on a non-cyclic module[133X[101X
  
  [33X[0;0YIn  this  example  (Example  3 from Linton [Lin93]), the two-sided relations
  give   the   group   algebra   of   the   group  with  presentation  [22XâŸ¨  a,bâˆ£
  a^4=b^2=(ab)^2=1âŸ©[122X,   the  dihedral  group  of  order  8.  The  module  under
  construction  is  a  non-cyclic module, obtained by taking two copies of the
  representation of Example [14XA.17[114X and fusing their one-dimensional submodules.[133X
  
  [33X[0;0YLoad  the  package  and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 1 and
  the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 1 (for more information about the
  info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[104X
  [4X[32X[104X
  
  [33X[0;0YCreate the free associative algebra to enter the relations in:[133X
  
  [4X[32X[104X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(Rationals, "a", "b");[104X
    [4X<algebra-with-one over Rationals, with 2 generators>[104X
    [4Xgap> g:=GeneratorsOfAlgebra(A);;[104X
    [4Xgap> a:=g[2];;b:=g[3];;e:=g[1];;[104X
  [4X[32X[104X
  
  [33X[0;0YNow the relations are entered:[133X
  
  [4X[32X[104X
    [4Xgap> twosidrels:=[a^4-e,b^2-e,(a*b)^2-e];;[104X
    [4Xgap> D:=A^2;;[104X
    [4Xgap> y:=GeneratorsOfLeftModule(D);;[104X
    [4Xgap> modrels:=[y[1]*b-y[1], y[2]*b-y[2], y[1]+y[1]*a*(e+a+b) -y[2]-y[2]*a*(e+a+b)];;[104X
  [4X[32X[104X
  
  [33X[0;0YFirst the relations are converted into NP format (see [14X2.1[114X) with the function
  [2XGP2NPList[102X  ([14X3.1-2[114X).  They are printed in raw form and subsequently in a more
  legible format.[133X
  
  [4X[32X[104X
    [4Xgap> modrelsNP:=GP2NPList(modrels);[104X
    [4X[ [ [ [ -1, 2 ], [ -1 ] ], [ 1, -1 ] ], [ [ [ -2, 2 ], [ -2 ] ], [ 1, -1 ] ], [104X
    [4X  [ [ [ -1, 1, 2 ], [ -1, 1, 1 ], [ -2, 1, 2 ], [ -2, 1, 1 ], [ -1, 1 ], [104X
    [4X          [ -2, 1 ], [ -1 ], [ -2 ] ], [ 1, 1, -1, -1, 1, -1, 1, -1 ] ] ][104X
    [4Xgap> PrintNPList(modrelsNP);[104X
    [4X[ b - 1 , 0][104X
    [4X[ 0, b - 1 ][104X
    [4X[ ab + a^2 + a + 1 , - ab - a^2 - a - 1 ][104X
  [4X[32X[104X
  
  [33X[0;0YNext  the  function  [2XSGrobnerModule[102X ([14X3.9-1[114X) is called to calculate a GrÃ¶bner
  basis record (see [14X2.8[114X).[133X
  
  [4X[32X[104X
    [4Xgap> GBR:=SGrobnerModule(modrelsNP,GP2NPList(twosidrels));;[104X
    [4X#I  number of entered polynomials is 3[104X
    [4X#I  number of polynomials after reduction is 3[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  End of phase III[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 0 msecs.[104X
    [4X#I  number of entered polynomials is 9[104X
    [4X#I  number of polynomials after reduction is 9[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  End of phase III[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 0 msecs.[104X
  [4X[32X[104X
  
  [33X[0;0YThe  record  [10XGBR[110X  has  two  members:  the two-sided relations [10XGBR.ts[110X and the
  prefix  relations  [10XGBR.p[110X.  It  is possible to print these using the function
  [2XPrintNPList[102X ([14X3.2-3[114X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(GBR.ts);[104X
    [4X b^2 - 1 [104X
    [4X aba - b [104X
    [4X ba^2 - a^2b [104X
    [4X bab - a^3 [104X
    [4X a^4 - 1 [104X
    [4X a^3b - ba [104X
    [4Xgap> PrintNPList(GBR.p);[104X
    [4X[ 0, b - 1 ][104X
    [4X[ b - 1 , 0][104X
    [4X[ ab + a^2 + a + 1 , - ab - a^2 - a - 1 ][104X
    [4X[ 0, a^3 - ab ][104X
    [4X[ 0, a^2b - a^2 ][104X
    [4X[ a^3 + a^2 + a + 1 , - ab - a^2 - a - 1 ][104X
    [4X[ a^2b - a^2 , 0][104X
  [4X[32X[104X
  
  [33X[0;0YIt  is  now  possible to calculate the standard basis of the quotient module
  with the function [2XBaseQM[102X ([14X3.9-2[114X). This function has as arguments the GrÃ¶bner
  basis  record [10XGBR[110X, the number of generators of the algebra (in this case 2),
  the  number  of  generators  of  the module (in this case 2), and a variable
  [10Xmaxno[110X for returning partial bases (0 means full basis).[133X
  
  [4X[32X[104X
    [4Xgap> B:=BaseQM(GBR,2,2,0);;[104X
    [4Xgap> PrintNPList(B);[104X
    [4X[ 0, 1 ][104X
    [4X[ 1 , 0][104X
    [4X[ 0, a ][104X
    [4X[ a , 0][104X
    [4X[ 0, a^2 ][104X
    [4X[ 0, ab ][104X
    [4X[ a^2 , 0][104X
  [4X[32X[104X
  
  [33X[0;0YIt  is  also possible to convert each member of the list [10XB[110X of polynomials in
  NP  form to GAP polynomials to do further calculations within the algebra or
  module. This can be done with the function [2XNP2GPList[102X ([14X3.1-4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> NP2GPList(B,D);[104X
    [4X[ [ <zero> of ..., (1)*<identity ...> ], [ (1)*<identity ...>, <zero> of ... ][104X
    [4X    , [ <zero> of ..., (1)*a ], [ (1)*a, <zero> of ... ], [104X
    [4X  [ <zero> of ..., (1)*a^2 ], [ <zero> of ..., (1)*a*b ], [104X
    [4X  [ (1)*a^2, <zero> of ... ] ][104X
  [4X[32X[104X
  
  [33X[0;0YIndividual  GAP polynomials can be obtained from polynomials in NP form with
  the  function [2XNP2GP[102X ([14X3.1-3[114X). This also holds for elements of the free module
  [10XD[110X in NP form.[133X
  
  [4X[32X[104X
    [4Xgap> Display(NP2GP(B[Length(B)],D));[104X
    [4X[ (1)*a^2, <zero> of ... ][104X
  [4X[32X[104X
  
  [33X[0;0YNext  we  write  down the matrices for the right action of the generators on
  the module by means of [2XMatrixQA[102X ([14X3.5-3[114X).[133X
  
  [4X[32X[104X
    [4Xgap> Display(MatrixQA(1,B,GBR));[104X
    [4X[ [   0,   0,   1,   0,   0,   0,   0 ],[104X
    [4X  [   0,   0,   0,   1,   0,   0,   0 ],[104X
    [4X  [   0,   0,   0,   0,   1,   0,   0 ],[104X
    [4X  [   0,   0,   0,   0,   0,   0,   1 ],[104X
    [4X  [   0,   0,   0,   0,   0,   1,   0 ],[104X
    [4X  [   1,   0,   0,   0,   0,   0,   0 ],[104X
    [4X  [   1,  -1,   1,  -1,   1,   1,  -1 ] ][104X
    [4Xgap> Display(MatrixQA(2,B,GBR)); [104X
    [4X[ [   1,   0,   0,   0,   0,   0,   0 ],[104X
    [4X  [   0,   1,   0,   0,   0,   0,   0 ],[104X
    [4X  [   0,   0,   0,   0,   0,   1,   0 ],[104X
    [4X  [   1,  -1,   1,  -1,   1,   1,  -1 ],[104X
    [4X  [   0,   0,   0,   0,   1,   0,   0 ],[104X
    [4X  [   0,   0,   1,   0,   0,   0,   0 ],[104X
    [4X  [   0,   0,   0,   0,   0,   0,   1 ] ][104X
  [4X[32X[104X
  
  [33X[0;0YIn  order to compute the image of the vector [22X2y[1]+3y[2][122X of the two standard
  generators  of  the  module  under  the  action  of  the element [22Xaab[122X, we use
  [2XStrongNormalFormNPM[102X  ([14X3.9-5[114X).  Its first argument will be the vector and its
  second  the GrÃ¶bner basis. The transformation [2XGP2NP[102X ([14X3.1-1[114X) to the NP format
  needs to be applied to the vector before it can be used as an argument.[133X
  
  [4X[32X[104X
    [4Xgap> v:=StrongNormalFormNPM(GP2NP((y[1]*2+y[2]*3)*a*a*b), GBR);;[104X
    [4Xgap> PrintNP(v);[104X
    [4X[ 2a^2 , 3a^2 ][104X
  [4X[32X[104X
  
  
  [1XA.20 [33X[0;0YThe icosahedral group[133X[101X
  
  [33X[0;0YIn  this example the two-sided relations give the group algebra of the group
  with   presentation   [22XâŸ¨  a,b,c  âˆ£  a^2=b^2=c^2=(ab)^3=(bc)^5=(ac)^2=1âŸ©[122X,  the
  icosahedral  group  of order 120. This is the Coxeter group of type H[22X_3[122X. The
  module under construction is a 3-dimensional reflection representation,[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 1
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 1 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[104X
  [4X[32X[104X
  
  [33X[0;0YCreate the field containing the golden ratio [10Xtau[110X.[133X
  
  [4X[32X[104X
    [4Xgap> x := Indeterminate(Rationals,"x");[104X
    [4Xx[104X
    [4Xgap> p := x^2+ x-1;[104X
    [4Xx^2+x-1[104X
    [4Xgap> K := AlgebraicExtension(Rationals,p);[104X
    [4X<algebraic extension over the Rationals of degree 2>[104X
    [4Xgap> tau:=RootOfDefiningPolynomial(K);[104X
    [4Xa[104X
  [4X[32X[104X
  
  [33X[0;0YCreate the free algebra with three generators over this field:[133X
  
  [4X[32X[104X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(K, "a", "b", "c");[104X
    [4X<algebra-with-one over <algebraic extension over the Rationals of degree [104X
    [4X2>, with 3 generators>[104X
    [4Xgap> e:=One(A);; a:=A.a;; b:=A.b;; c:=A.c;;[104X
  [4X[32X[104X
  
  [33X[0;0YThe  ideal  for a quotient of the icosahedral group algebra over this field,
  in which [10Xb[110X[22X*[122X[10Xc[110X has a quadratic minimal polynomial involving [10Xtau[110X:[133X
  
  [4X[32X[104X
    [4Xgap> #(b*c)^2-tau*b*c+e[104X
    [4Xgap> Irels:=[a^2-e,b^2-e,c^2-e,a*b*a-b*a*b,((b*c)^2-tau*b*c+e)*(b*c-e),a*c-c*a];[104X
    [4X[ (!-1)*<identity ...>+(!1)*a^2, (!-1)*<identity ...>+(!1)*b^2, [104X
    [4X  (!-1)*<identity ...>+(!1)*c^2, (!1)*a*b*a+(!-1)*b*a*b, [104X
    [4X  (!-1)*<identity ...>+(a+1)*b*c+(-a-1)*(b*c)^2+(!1)*(b*c)^3, [104X
    [4X  (!1)*a*c+(!-1)*c*a ][104X
  [4X[32X[104X
  
  [33X[0;0YWe  now  give  module  relations. The first two describe group elements of a
  vector  stabilizer,  the  third  forces  the  central  element [22X(abc)^5[122X to be
  nontrivial.[133X
  
  [4X[32X[104X
    [4Xgap> Mrels:=[b*c-e,b-e,(a*b*c)^5+e];;[104X
  [4X[32X[104X
  
  [33X[0;0YFirst the relations are converted into NP format (see [14X2.1[114X) with the function
  [2XGP2NPList[102X  ([14X3.1-2[114X).  Next  the  function [2XSGrobnerModule[102X ([14X3.9-1[114X) is called to
  calculate a GrÃ¶bner basis record (see [14X2.8[114X).[133X
  
  [4X[32X[104X
    [4Xgap> GBR:=SGrobnerModule(GP2NPList(Mrels),GP2NPList(Irels));;[104X
    [4X#I  number of entered polynomials is 6[104X
    [4X#I  number of polynomials after reduction is 6[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  End of phase III[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 16 msecs.[104X
    [4X#I  number of entered polynomials is 12[104X
    [4X#I  number of polynomials after reduction is 12[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  End of phase III[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 36 msecs.[104X
    [4Xgap> PrintNPList(GBR.ts);;[104X
    [4X a^2 + !-1 [104X
    [4X b^2 + !-1 [104X
    [4X ca + !-1ac [104X
    [4X c^2 + !-1 [104X
    [4X bab + !-1aba [104X
    [4X cbc + !-1bcb + -a-1c + a+1b [104X
    [4X bcba + !-1acba + !-1abcb + abac + cb + !-1bc + -a-2ba + a+2ab [104X
    [4X cbac + !-1acba + !-1abcb + abac + cb + !-1bc + !-1ba + -a-1ac + a+2ab [104X
    [4X bacba + abacb + !-1cba + !-1bcb + !-1abc + -a-2aba + c + a+2a [104X
    [4Xgap> PrintNPList(GBR.p);;[104X
    [4X[ b + !-1 ][104X
    [4X[ c + !-1 ][104X
    [4X[ ac + !-1a ][104X
    [4X[ aba + !-1ab ][104X
    [4X[ abc + ab + -aa + -a ][104X
  [4X[32X[104X
  
  [33X[0;0YIt  is  now possible to calculate the basis of the quotient algebra with the
  function  [2XBaseQM[102X  ([14X3.9-2[114X).  This function has as arguments the GrÃ¶bner basis
  record  [10XGBR[110X,  the  number of generators of the algebra (in this case 3), the
  number  of generators of the free module in which the vectors are chosen (in
  this  case  1), and a variable [10Xmaxno[110X for returning partial quotient algebras
  (0 means full basis).[133X
  
  [4X[32X[104X
    [4Xgap> B:=BaseQM(GBR,3,1,0);;[104X
    [4Xgap> PrintNPList(B);[104X
    [4X[ !1 ][104X
    [4X[ a ][104X
    [4X[ ab ][104X
  [4X[32X[104X
  
  [33X[0;0YCalculate  the  dimension  of  the  quotient algebra with the function [2XDimQM[102X
  ([14X3.9-3[114X).  This  function  has as arguments the GrÃ¶bner basis record [10XGBR[110X, the
  number  of  generators  of  the  algebra  (in this case 3) and the number of
  generators of the module (in this case 1).[133X
  
  [4X[32X[104X
    [4Xgap> DimQM(GBR,3,1);[104X
    [4X3[104X
  [4X[32X[104X
  
  [33X[0;0YNext  we  write  down the matrices for the right action of the generators on
  the module by means of [2XMatrixQA[102X ([14X3.5-3[114X).[133X
  
  [4X[32X[104X
    [4Xgap> aa := MatrixQA(1,B,GBR);;[104X
    [4Xgap> Display(aa);[104X
    [4X[ [  !0,  !1,  !0 ],[104X
    [4X  [  !1,  !0,  !0 ],[104X
    [4X  [  !0,  !0,  !1 ] ][104X
    [4Xgap> bb := MatrixQA(2,B,GBR);;[104X
    [4Xgap> Display(bb);[104X
    [4X[ [  !1,  !0,  !0 ],[104X
    [4X  [  !0,  !0,  !1 ],[104X
    [4X  [  !0,  !1,  !0 ] ][104X
    [4Xgap> cc := MatrixQA(3,B,GBR);;[104X
    [4Xgap> Display(cc);[104X
    [4X[ [   !1,   !0,   !0 ],[104X
    [4X  [   !0,   !1,   !0 ],[104X
    [4X  [    a,    a,  !-1 ] ][104X
  [4X[32X[104X
  
  [33X[0;0YFinally  we  check  the  defining relations for the icosahedral group on the
  three  new matrix generators. This can be done by verifying if the result is
  equal to the identity matrix or with the function [2XIsOne[102X ([14XReference: IsOne[114X).[133X
  
  [4X[32X[104X
    [4Xgap> ee := IdentityMat(3,K);;[104X
    [4Xgap> Display(ee);[104X
    [4X[ [  !1,  !0,  !0 ],[104X
    [4X  [  !0,  !1,  !0 ],[104X
    [4X  [  !0,  !0,  !1 ] ][104X
    [4Xgap> aa^2 = ee;[104X
    [4Xtrue[104X
    [4Xgap> IsOne(aa^2);[104X
    [4Xtrue[104X
    [4Xgap> IsOne(bb^2);[104X
    [4Xtrue[104X
    [4Xgap> IsOne(cc^2);[104X
    [4Xtrue[104X
    [4Xgap> IsOne((aa*bb)^3);[104X
    [4Xtrue[104X
    [4Xgap> IsOne((aa*cc)^2);[104X
    [4Xtrue[104X
    [4Xgap> IsOne((bb*cc)^5);[104X
    [4Xtrue[104X
  [4X[32X[104X
  
  
  [1XA.21 [33X[0;0YThe symmetric inverse monoid for a set of size four[133X[101X
  
  [33X[0;0YThe  algebra  we  will  consider  is from Example 4 from Linton [Lin93]. Its
  monomials  form  the  symmetric  inverse  monoid, that is, the monoid of all
  partial  bijections on a given set, for a set of size four. The presentation
  is   [22XâŸ¨   s_1,s_2,s_3,eâˆ£   s_i^2=(s_1s_2)^3=(s_2s_3)^3=(s_1s_3)^2=1,   e^2=e,
  s_1e=es_1,s_2e=es_2,es_3e=(es_3)^2=(s_3e)^2âŸ©[122X.  The  dimension  of the monoid
  algebra is 209. The monoid has a natural representation of degree 4 by means
  of  partial  permutation  matrices,  which  can be obtained by taking prefix
  relations [22X{e,s_1-1, s_2-1, s_3e-s_3}[122X.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 1
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 1 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[104X
  [4X[32X[104X
  
  [33X[0;0YNow enter the relations as GAP polynomials. The module is one dimensional so
  it  is  possible to enter it with and without a module. In Example 18 ([14XA.17[114X)
  both  ways  are  shown. Here the relations will be entered without a module,
  with  a  free  associative  algebra  with  one  over the field (the rational
  numbers)  (see also [14XReference: FreeAssociativeAlgebraWithOne (for ring, rank
  (and name))[114X). For convenience we use the variables [10Xs1[110X, [10Xs2[110X, [10Xs3[110X, and [10Xe[110X for the
  generators of the algebra, and [10Xo[110X for the identity element of the algebra.[133X
  
  [4X[32X[104X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(Rationals, "s1", "s2", "s3", "e");[104X
    [4X<algebra-with-one over Rationals, with 4 generators>[104X
    [4Xgap> g:=GeneratorsOfAlgebra(A);;[104X
    [4Xgap> s1:=g[2];;s2:=g[3];;s3:=g[4];;e:=g[5];;o:=g[1];;[104X
  [4X[32X[104X
  
  [33X[0;0YIt  is possible to print symbols like they are printed in the algebra [10XA[110X with
  the function [2XGBNP.ConfigPrint[102X ([14X3.2-2[114X):[133X
  
  [4X[32X[104X
    [4Xgap> GBNP.ConfigPrint(A);[104X
  [4X[32X[104X
  
  [33X[0;0YNow the relations are entered:[133X
  
  [4X[32X[104X
    [4Xgap> twosidrels:=[s1^2-o,s2^2-o,s3^2-o,(s1*s2)^3-o,(s2*s3)^3-o,(s1*s3)^2-o,[104X
    [4X> 	e^2-e,s1*e-e*s1,s2*e-e*s2,e*s3*e-(e*s3)^2,e*s3*e-(s3*e)^2];[104X
    [4X[ (-1)*<identity ...>+(1)*s1^2, (-1)*<identity ...>+(1)*s2^2, [104X
    [4X  (-1)*<identity ...>+(1)*s3^2, (-1)*<identity ...>+(1)*(s1*s2)^3, [104X
    [4X  (-1)*<identity ...>+(1)*(s2*s3)^3, (-1)*<identity ...>+(1)*(s1*s3)^2, [104X
    [4X  (-1)*e+(1)*e^2, (1)*s1*e+(-1)*e*s1, (1)*s2*e+(-1)*e*s2, [104X
    [4X  (1)*e*s3*e+(-1)*(e*s3)^2, (1)*e*s3*e+(-1)*(s3*e)^2 ][104X
    [4Xgap> prefixrels:=[e,s1-o,s2-o,s3*e-s3];[104X
    [4X[ (1)*e, (-1)*<identity ...>+(1)*s1, (-1)*<identity ...>+(1)*s2, [104X
    [4X  (-1)*s3+(1)*s3*e ][104X
  [4X[32X[104X
  
  [33X[0;0YFirst  the  relations  are  converted  into NP format (see [14X2.1[114X) and next the
  function  [2XSGrobnerModule[102X  ([14X3.9-1[114X)  is  called  to  calculate a GrÃ¶bner basis
  record.[133X
  
  [4X[32X[104X
    [4Xgap> GBR:=SGrobnerModule(GP2NPList(prefixrels),GP2NPList(twosidrels));;[104X
    [4X#I  number of entered polynomials is 11[104X
    [4X#I  number of polynomials after reduction is 11[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  End of phase III[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 24 msecs.[104X
    [4X#I  number of entered polynomials is 42[104X
    [4X#I  number of polynomials after reduction is 42[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  End of phase III[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 20 msecs.[104X
  [4X[32X[104X
  
  [33X[0;0YThe  record  GBR  has  two  members:  the two-sided relations [10XGBR.ts[110X and the
  prefix  relations  [10XGBR.p[110X.  We  print  these  using  the function [2XPrintNPList[102X
  ([14X3.2-3[114X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(GBR.ts);[104X
    [4X s1^2 - 1 [104X
    [4X s2^2 - 1 [104X
    [4X s3s1 - s1s3 [104X
    [4X s3^2 - 1 [104X
    [4X es1 - s1e [104X
    [4X es2 - s2e [104X
    [4X e^2 - e [104X
    [4X s2s1s2 - s1s2s1 [104X
    [4X s3s2s3 - s2s3s2 [104X
    [4X s3s2s1s3 - s2s3s2s1 [104X
    [4X s3es3e - es3e [104X
    [4X es3es3 - es3e [104X
    [4X s3es3s2e - es3s2e [104X
    [4X s2s3s2es3e - s3s2es3e [104X
    [4X s3es3s2s1e - es3s2s1e [104X
    [4X es3s2es3s2 - es3s2es3 [104X
    [4X s2s3s2s1es3e - s3s2s1es3e [104X
    [4X s2s3s2es3s2e - s3s2es3s2e [104X
    [4X s2es3s2es3e - es3s2es3e [104X
    [4X s1s2s1s3s2es3e - s2s1s3s2es3e [104X
    [4X s2s3s2s1es3s2e - s3s2s1es3s2e [104X
    [4X s2s3s2es3s2s1e - s3s2es3s2s1e [104X
    [4X s2es3s2s1es3e - es3s2s1es3e [104X
    [4X es3s2s1es3s2s1 - es3s2s1es3s2 [104X
    [4X s1s2s1s3s2s1es3e - s2s1s3s2s1es3e [104X
    [4X s1s2s1s3s2es3s2e - s2s1s3s2es3s2e [104X
    [4X s1s2s1es3s2es3e - s2s1es3s2es3e [104X
    [4X s2s3s2s1es3s2s1e - s3s2s1es3s2s1e [104X
    [4X s2es3s2s1es3s2e - es3s2s1es3s2e [104X
    [4X s1s2s1s3s2s1es3s2e - s2s1s3s2s1es3s2e [104X
    [4X s1s2s1s3s2es3s2s1e - s2s1s3s2es3s2s1e [104X
    [4X s1s2s1es3s2s1es3e - s2s1es3s2s1es3e [104X
    [4X s1s3s2s1es3s2es3e - s3s2s1es3s2es3e [104X
    [4X s1s2s1s3s2s1es3s2s1e - s2s1s3s2s1es3s2s1e [104X
    [4X s1s2s1es3s2s1es3s2e - s2s1es3s2s1es3s2e [104X
    [4X s1s3s2s1es3s2s1es3e - s3s2s1es3s2s1es3e [104X
    [4X s1es3s2s1es3s2es3e - es3s2s1es3s2es3e [104X
    [4X s1s3s2s1es3s2s1es3s2e - s3s2s1es3s2s1es3s2e [104X
    [4Xgap> PrintNPList(GBR.p);[104X
    [4X[ s1 - 1 ][104X
    [4X[ s2 - 1 ][104X
    [4X[ e ][104X
    [4X[ s3e - s3 ][104X
    [4X[ s3s2e - s3s2 ][104X
    [4X[ s3s2s1e - s3s2s1 ][104X
  [4X[32X[104X
  
  [33X[0;0YIt  is  now  possible to calculate the standard basis of the quotient module
  with the function [2XBaseQM[102X ([14X3.9-2[114X). This function has as arguments the GrÃ¶bner
  basis  record [10XGBR[110X, the number of generators of the algebra (here this is 4),
  the  number  of  generators  of  the module (here this is 1), and a variable
  [10Xmaxno[110X for returning partial bases (0 means full basis).[133X
  
  [4X[32X[104X
    [4Xgap> B:=BaseQM(GBR,4,1,0);;[104X
    [4Xgap> PrintNPList(B);[104X
    [4X[ 1 ][104X
    [4X[ s3 ][104X
    [4X[ s3s2 ][104X
    [4X[ s3s2s1 ][104X
  [4X[32X[104X
  
  [33X[0;0YNext  we  write  down the matrices for the right action of the generators on
  the  module. First by means of the list command [2XMatricesQA[102X ([14X3.5-4[114X), next one
  by one by means of [2XMatrixQA[102X ([14X3.5-3[114X) within a loop.[133X
  
  [4X[32X[104X
    [4Xgap> MatricesQA(4,B,GBR);[104X
    [4X[ [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 0, 1 ], [ 0, 0, 1, 0 ] ], [104X
    [4X  [ [ 1, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 0, 1 ] ], [104X
    [4X  [ [ 0, 1, 0, 0 ], [ 1, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ], [104X
    [4X  [ [ 0, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ] ][104X
    [4Xgap> for i in [1..4] do [104X
    [4X>   Display(MatrixQA(i,B,GBR)); Print("\n");[104X
    [4X> od;[104X
    [4X[ [  1,  0,  0,  0 ],[104X
    [4X  [  0,  1,  0,  0 ],[104X
    [4X  [  0,  0,  0,  1 ],[104X
    [4X  [  0,  0,  1,  0 ] ][104X
    [4X[104X
    [4X[ [  1,  0,  0,  0 ],[104X
    [4X  [  0,  0,  1,  0 ],[104X
    [4X  [  0,  1,  0,  0 ],[104X
    [4X  [  0,  0,  0,  1 ] ][104X
    [4X[104X
    [4X[ [  0,  1,  0,  0 ],[104X
    [4X  [  1,  0,  0,  0 ],[104X
    [4X  [  0,  0,  1,  0 ],[104X
    [4X  [  0,  0,  0,  1 ] ][104X
    [4X[104X
    [4X[ [  0,  0,  0,  0 ],[104X
    [4X  [  0,  1,  0,  0 ],[104X
    [4X  [  0,  0,  1,  0 ],[104X
    [4X  [  0,  0,  0,  1 ] ][104X
    [4X[104X
  [4X[32X[104X
  
  
  [1XA.22 [33X[0;0YA module of the Hecke algebra of type A[22X_3[122X[101X[1X over GF(3)[133X[101X
  
  [33X[0;0YThis  example is an extension of Example 5 from Linton, [Lin93]. It concerns
  the  Hecke  Algebra of type A[22X_3[122X. By reducing mod 3 but without evaluating at
  [22Xq=1[122X  it  is  possible  to  obtain  the following representation of the Hecke
  algebra     of     type     A[22X_3[122X     over     GF(3):     [22XâŸ¨     x,    y,    zâˆ£
  x^2+(1-q)*x-q,y^2+(1-q)*y-q,z^2+(1-q)*z-q,y*x*y-x*y*x,          z*y*z-y*z*y,
  z*x-x*zâŸ©[122X.  It  has a natural representation of the same dimension as the Lie
  algebra  of type A[22X_3[122X, namely 4. This representation can be obtained with the
  module relations [22X{x+1,y+1}[122X.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 1
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 1 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[104X
  [4X[32X[104X
  
  [33X[0;0YNow enter the relations as GAP polynomials. The module is one dimensional so
  it  is  possible  to  enter  it  with and without a module. Both are used in
  Example  [14XA.17[114X.  Here  the  relations will be entered without using a module.
  First  a free associative algebra with one is created over the field (GF(3))
  (see  also  [14XReference:  FreeAssociativeAlgebraWithOne  (for  ring, rank (and
  name))[114X).  For convenience we use the variables [10Xa[110X and [10Xb[110X for the generators of
  the algebra and [10Xe[110X for the one of the algebra.[133X
  
  [4X[32X[104X
    [4Xgap> q:=Indeterminate(GF(3),"q");[104X
    [4Xq[104X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(Field(q), "x", "y", "z");;[104X
    [4Xgap> g:=GeneratorsOfAlgebra(A);;[104X
    [4Xgap> x:=g[2];;y:=g[3];;z:=g[4];;e:=g[1];;q:=q*e;;[104X
  [4X[32X[104X
  
  [33X[0;0YIn  order to print the variables like they are printed in the algebra [10XA[110X with
  the function [2XGBNP.ConfigPrint[102X ([14X3.2-2[114X):[133X
  
  [4X[32X[104X
    [4Xgap> GBNP.ConfigPrint(A);[104X
  [4X[32X[104X
  
  [33X[0;0YNow the relations are entered:[133X
  
  [4X[32X[104X
    [4Xgap> twosidrels:=[x^2+(e-q)*x-q,y^2+(e-q)*y-q,z^2+(e-q)*z-q,[104X
    [4X>   y*x*y-x*y*x,z*y*z-y*z*y,z*x-x*z];[104X
    [4X[ (-q)*<identity ...>+(-q+Z(3)^0)*x+(Z(3)^0)*x^2, [104X
    [4X  (-q)*<identity ...>+(-q+Z(3)^0)*y+(Z(3)^0)*y^2, [104X
    [4X  (-q)*<identity ...>+(-q+Z(3)^0)*z+(Z(3)^0)*z^2, [104X
    [4X  (-Z(3)^0)*x*y*x+(Z(3)^0)*y*x*y, (-Z(3)^0)*y*z*y+(Z(3)^0)*z*y*z, [104X
    [4X  (-Z(3)^0)*x*z+(Z(3)^0)*z*x ][104X
    [4Xgap> prefixrels:=[x+e,y+e];[104X
    [4X[ (Z(3)^0)*<identity ...>+(Z(3)^0)*x, (Z(3)^0)*<identity ...>+(Z(3)^0)*y ][104X
  [4X[32X[104X
  
  [33X[0;0YFirst  the  relations are converted into NP format (see [14X2.1[114X) after which the
  function  [2XSGrobnerModule[102X  ([14X3.9-1[114X)  is  called  to  calculate a GrÃ¶bner basis
  record.[133X
  
  [4X[32X[104X
    [4Xgap> GBR:=SGrobnerModule(GP2NPList(prefixrels),GP2NPList(twosidrels));;[104X
    [4X#I  number of entered polynomials is 6[104X
    [4X#I  number of polynomials after reduction is 6[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  End of phase III[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 4 msecs.[104X
    [4X#I  number of entered polynomials is 9[104X
    [4X#I  number of polynomials after reduction is 9[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  End of phase III[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 8 msecs.[104X
  [4X[32X[104X
  
  [33X[0;0YThe record GBR has three members: the two-sided relations [10XGBR.ts[110X, the prefix
  relations  [10XGBR.p[110X, and the number [10XGBR.pg[110X of generators of the free module. It
  is possible to print the first two using the function [2XPrintNPList[102X ([14X3.2-3[114X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPList(GBR.ts);[104X
    [4X x^2 + -q+Z(3)^0x + -q [104X
    [4X y^2 + -q+Z(3)^0y + -q [104X
    [4X zx + -Z(3)^0xz [104X
    [4X z^2 + -q+Z(3)^0z + -q [104X
    [4X yxy + -Z(3)^0xyx [104X
    [4X zyz + -Z(3)^0yzy [104X
    [4X zyxz + -Z(3)^0yzyx [104X
    [4Xgap> PrintNPList(GBR.p);[104X
    [4X[ x + Z(3)^0 ][104X
    [4X[ y + Z(3)^0 ][104X
  [4X[32X[104X
  
  [33X[0;0YIt  is  now  possible to calculate the standard basis of the quotient module
  with the function [2XBaseQM[102X ([14X3.9-2[114X). This function has as arguments the GrÃ¶bner
  basis  record [10XGBR[110X, the number of generators of the algebra (here this is 3),
  the  number  of  generators  of  the module (here this is 1), and a variable
  [10Xmaxno[110X for returning partial bases (0 means full basis).[133X
  
  [4X[32X[104X
    [4Xgap> B:=BaseQM(GBR,3,1,0);;[104X
    [4Xgap> PrintNPList(B);[104X
    [4X[ Z(3)^0 ][104X
    [4X[ z ][104X
    [4X[ zy ][104X
    [4X[ zyx ][104X
  [4X[32X[104X
  
  [33X[0;0YNext  we  write  down the matrices for the right action of the generators on
  the module, by means of the command [2XMatricesQA[102X ([14X3.5-4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> MM := MatricesQA(3,B,GBR);;[104X
    [4Xgap> for i in [1..Length(MM)] do [104X
    [4X> Display(MM[i]); Print("\n"); [104X
    [4X> od;[104X
    [4X[ [   -Z(3)^0,    0*Z(3),    0*Z(3),    0*Z(3) ],[104X
    [4X  [    0*Z(3),   -Z(3)^0,    0*Z(3),    0*Z(3) ],[104X
    [4X  [    0*Z(3),    0*Z(3),    0*Z(3),    Z(3)^0 ],[104X
    [4X  [    0*Z(3),    0*Z(3),         q,  q-Z(3)^0 ] ][104X
    [4X[104X
    [4X[ [   -Z(3)^0,    0*Z(3),    0*Z(3),    0*Z(3) ],[104X
    [4X  [    0*Z(3),    0*Z(3),    Z(3)^0,    0*Z(3) ],[104X
    [4X  [    0*Z(3),         q,  q-Z(3)^0,    0*Z(3) ],[104X
    [4X  [    0*Z(3),    0*Z(3),    0*Z(3),   -Z(3)^0 ] ][104X
    [4X[104X
    [4X[ [    0*Z(3),    Z(3)^0,    0*Z(3),    0*Z(3) ],[104X
    [4X  [         q,  q-Z(3)^0,    0*Z(3),    0*Z(3) ],[104X
    [4X  [    0*Z(3),    0*Z(3),   -Z(3)^0,    0*Z(3) ],[104X
    [4X  [    0*Z(3),    0*Z(3),    0*Z(3),   -Z(3)^0 ] ][104X
    [4X[104X
  [4X[32X[104X
  
  
  [1XA.23 [33X[0;0YGeneralized Temperley-Lieb algebras[133X[101X
  
  [33X[0;0YThis example shows how the dimension of a Generalized Temperley-Lieb Algebra
  of  type  A,  D,  or  E  can  be  calculated.  For  [22XA_n-1[122X  this is the usual
  Temperley-Lieb  Algebra on [22Xn[122X strands with dimension [22Xdim TL(A_n-1)={2n choose
  n}/(n+1)[122X. For more information see [Gra95].[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 0
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 1 (for more information about
  timing; see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,0);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[104X
  [4X[32X[104X
  
  [33X[0;0YThe  relations  are  generated  automatically from the Coxeter diagram. This
  example can be easily adapted by specifying the number of points and the set
  of  edges  describing  another  Coxeter  diagram.  First enter the number of
  points, [10Xnumpoints[110X.[133X
  
  [4X[32X[104X
    [4Xgap> numpoints:=8;[104X
    [4X8[104X
  [4X[32X[104X
  
  [33X[0;0YNow  define  some edges describing the diagrams of [22XE_n[122X, (these can be easily
  extended).  In  this example the dimension of the Generalized Temperley-Lieb
  algebra of type [22XE_8[122X will be calculated. For [22XA_1... 10[122X the command[133X
  
  [33X[0;0Y[10Xedges:=[[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10]];[110X[133X
  
  [33X[0;0Ycan be used. For [22XD_1... 10[122X the command[133X
  
  [33X[0;0Y[10Xedges:=[[1,3],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10]];[110X can[133X
  
  [33X[0;0Ybe used.[133X
  
  [4X[32X[104X
    [4Xgap> edges:=[[1,3],[2,4],[3,4],[4,5],[5,6],[6,7],[7,8]]; # for E6..8[104X
    [4X[ [ 1, 3 ], [ 2, 4 ], [ 3, 4 ], [ 4, 5 ], [ 5, 6 ], [ 6, 7 ], [ 7, 8 ] ][104X
  [4X[32X[104X
  
  [33X[0;0YNow enter the relations as GAP polynomials. First a free associative algebra
  with  identity  element  is  created over the Rationals (see also [14XReference:
  FreeAssociativeAlgebraWithOne  (for ring, rank (and name))[114X). For convenience
  the generators are stored in [10Xgens[110X.[133X
  
  [4X[32X[104X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(Rationals,numpoints,"e");;[104X
    [4Xgap> e := GeneratorsOfAlgebraWithOne(A);[104X
    [4X[ (1)*e.1, (1)*e.2, (1)*e.3, (1)*e.4, (1)*e.5, (1)*e.6, (1)*e.7, (1)*e.8 ][104X
  [4X[32X[104X
  
  [33X[0;0YIt  is possible to print symbols like they are printed in the algebra [10XA[110X with
  the function [2XGBNP.ConfigPrint[102X ([14X3.2-2[114X):[133X
  
  [4X[32X[104X
    [4Xgap> GBNP.ConfigPrint(A);[104X
  [4X[32X[104X
  
  [33X[0;0YNow the relations are generated automatically. For this we need to make sure
  the edges are sorted and converted to a set.[133X
  
  [4X[32X[104X
    [4Xgap> edges:=Set(edges, x->SortedList(x));[104X
    [4X[ [ 1, 3 ], [ 2, 4 ], [ 3, 4 ], [ 4, 5 ], [ 5, 6 ], [ 6, 7 ], [ 7, 8 ] ][104X
  [4X[32X[104X
  
  [33X[0;0YNow the relations can be generated. The relations are [22Xe_i*e_i=e_i[122X, for all [22Xi[122X
  and  [22Xe_i*e_j*e_i=e_i[122X  for  all [22Xi[122X,[22Xj[122X that are connected in the Coxeter diagram
  and  [22Xe_i*e_j=e_j*e_i[122X  for  all  [22Xi[122X,  [22Xj[122X  that are not connected in the Coxeter
  diagram.[133X
  
  [4X[32X[104X
    [4Xgap> rels:=[];;[104X
    [4Xgap> for i in [1..numpoints] do[104X
    [4X>   for j in [1..numpoints] do[104X
    [4X>     if (i=j) then[104X
    [4X>       # if i=j then add e.i*e.i=e.i[104X
    [4X>       Add(rels, e[i]*e[i]-e[i]);[104X
    [4X>     elif ([i,j] in edges) or ([j,i] in edges) then[104X
    [4X>       # if {i,j} is an edge then add e.i*e.j*e.i=e.i [104X
    [4X>       Add(rels, e[i]*e[j]*e[i]- e[i]);[104X
    [4X>     else[104X
    [4X>       # if {i,j} is not an edge then add e.i*e.j=e.j*e.i [104X
    [4X>       # (note: this causes double rules, but that's ok)[104X
    [4X>       Add(rels, e[i]*e[j]- e[j]*e[i]);[104X
    [4X>     fi;[104X
    [4X>   od;[104X
    [4X> od;[104X
  [4X[32X[104X
  
  [33X[0;0YThen  the  relations  are converted into NP format (see [14X2.1[114X) after which the
  function [2XSGrobner[102X ([14X3.4-2[114X) is called to calculate a GrÃ¶bner basis.[133X
  
  [4X[32X[104X
    [4Xgap> relsNP:=GP2NPList(rels);;[104X
    [4Xgap> GB:=SGrobner(relsNP);;[104X
    [4X#I  The computation took 184 msecs.[104X
  [4X[32X[104X
  
  [33X[0;0YIt  is  now possible to calculate the dimension of the quotient algebra with
  the function [2XDimQA[102X ([14X3.5-2[114X). This function has as arguments the GrÃ¶bner basis
  [10XGB[110X  and the number of generators of the algebra (here this is [10Xnumpoints[110X). To
  get the full basis the function [2XBaseQA[102X ([14X3.5-1[114X) can be used.[133X
  
  [4X[32X[104X
    [4Xgap> DimQA(GB,numpoints);[104X
    [4X10846[104X
  [4X[32X[104X
  
  
  [1XA.24 [33X[0;0YThe universal enveloping algebra of a Lie algebra[133X[101X
  
  [33X[0;0YConsider  the Lie algebra with generators [22Xe[122X, [22Xf[122X and [22Xh[122X, and relations [22X[e,f]=h[122X,
  [22X[e,h]=-2e[122X,  [22X[f,h]=2f[122X.  This  is  the  well-known Lie algebra of type A[22X_1[122X. We
  construct the corresponding universal enveloping algebra of this Lie algebra
  and show how one can prove that [22Xf^2[122X belongs to the ideal generated by [22Xe^2[122X in
  that associative algebra. The example is from Knopper's report [Kno04].[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 0
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 0 (for more information about
  the info level, see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP");[104X
    [4Xâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[104X
    [4XLoading  GBNP 1.0.3 (Non-commutative GrÃ¶bner bases)[104X
    [4Xby A.M. Cohen (http://www.win.tue.nl/~amc) and[104X
    [4X   J.W. Knopper (J.W.Knopper@tue.nl).[104X
    [4XHomepage: http://mathdox.org/products/gbnp/[104X
    [4Xâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[104X
    [4Xtrue[104X
    [4X[104X
    [4Xgap> SetInfoLevel(InfoGBNP,0);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,0);[104X
  [4X[32X[104X
  
  [33X[0;0YThen define the algebra and enter the relations as polynomials in GAP.[133X
  
  [4X[32X[104X
    [4Xgap> A:=FreeAssociativeAlgebraWithOne(Rationals, "e", "f", "h");[104X
    [4X<algebra-with-one over Rationals, with 3 generators>[104X
    [4Xgap> e:=A.e;; f:=A.f;; h:=A.h;; o:=One(A);;[104X
    [4Xgap> uerels:=[f*e-e*f+h,h*e-e*h-2*e,h*f-f*h+2*f];[104X
    [4X[ (1)*h+(-1)*e*f+(1)*f*e, (-2)*e+(-1)*e*h+(1)*h*e, (2)*f+(-1)*f*h+(1)*h*f ][104X
  [4X[32X[104X
  
  [33X[0;0YThe  relations  can  be  converted  to NP format (see [14X2.1[114X) with the function
  [2XGP2NPList[102X  ([14X3.1-2[114X)  and  can  be  subsequently  displayed  with  [2XPrintNPList[102X
  ([14X3.2-3[114X).[133X
  
  [4X[32X[104X
    [4Xgap> uerelsNP:=GP2NPList(uerels);;[104X
    [4Xgap> PrintNPList(uerelsNP);[104X
    [4X ba - ab + c [104X
    [4X ca - ac - 2a [104X
    [4X cb - bc + 2b [104X
  [4X[32X[104X
  
  [33X[0;0YNow  configure  printing  in  such  a way that this algebra is used with the
  function [2XGBNP.ConfigPrint[102X ([14X3.2-2[114X).[133X
  
  [4X[32X[104X
    [4Xgap> GBNP.ConfigPrint(A);[104X
  [4X[32X[104X
  
  [33X[0;0YThe  set  is actually a GrÃ¶bner basis, as can be verified by calculating the
  GrÃ¶bner basis with [2XSGrobner[102X ([14X3.4-2[114X).[133X
  
  [4X[32X[104X
    [4Xgap> GB:=SGrobner(uerelsNP);;[104X
    [4Xgap> PrintNPList(GB);[104X
    [4X fe - ef + h [104X
    [4X he - eh - 2e [104X
    [4X hf - fh + 2f [104X
  [4X[32X[104X
  
  [33X[0;0YDetermine  whether  the  quotient  algebra is finite dimensional by means of
  [2XFinCheckQA[102X  ([14X3.6-2[114X),  with  arguments the leading monomials of [10XGB[110X and 3, the
  number  of  variables  involved.  The  leading  monomials of [10XGB[110X are found by
  invoking [2XLMonsNP[102X ([14X3.3-10[114X).[133X
  
  [4X[32X[104X
    [4Xgap> F:=LMonsNP(GB);[104X
    [4X[ [ 2, 1 ], [ 3, 1 ], [ 3, 2 ] ][104X
    [4Xgap> FinCheckQA(F,3);[104X
    [4Xfalse[104X
  [4X[32X[104X
  
  [33X[0;0YAdding the relation [22Xe^2=0[122X results in a finite quotient algebra.[133X
  
  [4X[32X[104X
    [4Xgap> extendedrels:=[f*e-e*f+h,h*e-e*h-2*e,h*f-f*h+2*f,e^2];[104X
    [4X[ (1)*h+(-1)*e*f+(1)*f*e, (-2)*e+(-1)*e*h+(1)*h*e, (2)*f+(-1)*f*h+(1)*h*f, [104X
    [4X  (1)*e^2 ][104X
    [4Xgap> extendedrelsNP:=GP2NPList(extendedrels);;[104X
  [4X[32X[104X
  
  [33X[0;0YWith  the  function  [2XSGrobnerTrace[102X  ([14X3.7-5[114X)  it  is  possible to calculate a
  GrÃ¶bner basis with trace information.[133X
  
  [4X[32X[104X
    [4Xgap> GB:=SGrobnerTrace(extendedrelsNP);;[104X
  [4X[32X[104X
  
  [33X[0;0YThe GrÃ¶bner basis can now be displayed with [2XPrintNPListTrace[102X ([14X3.7-4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPListTrace(GB);[104X
    [4X e^2 [104X
    [4X eh + e [104X
    [4X fe - ef + h [104X
    [4X f^2 [104X
    [4X fh - f [104X
    [4X he - e [104X
    [4X hf + f [104X
    [4X h^2 - 2ef + h [104X
  [4X[32X[104X
  
  [33X[0;0YNote  the  fourth  relation: [22Xf^2=0[122X. To view a trace one can use the function
  [2XPrintTracePol[102X ([14X3.7-3[114X).[133X
  
  [4X[32X[104X
    [4Xgap> PrintTracePol(GB[4]);[104X
    [4X- 1/12G(1)f^2 + 1/12f^2G(1) + 1/12f^2G(1)h - 1/6fG(1)hf + 1/12G(1)hf^2 + 1/[104X
    [4X24G(1)ef^3 + 1/24eG(1)f^3 - 1/8fG(1)ef^2 - 1/8feG(1)f^2 + 1/8f^2G(1)ef + 1/[104X
    [4X8f^2eG(1)f - 1/24f^3G(1)e - 1/24f^3eG(1) - 1/24G(2)f^3 + 1/8fG(2)f^2 - 1/[104X
    [4X8f^2G(2)f + 1/24f^3G(2) + 1/4G(3)f + 1/4fG(3) + 1/12fG(3)h + 1/12fhG(3) - 1/[104X
    [4X12G(3)hf - 1/12hG(3)f - 1/12eG(3)f^2 + 1/6feG(3)f - 1/12f^2eG(3) + 1/24G([104X
    [4X4)f^4 - 1/6fG(4)f^3 + 1/4f^2G(4)f^2 - 1/6f^3G(4)f + 1/24f^4G(4) [104X
  [4X[32X[104X
  
  [33X[0;0YThis proves that [22Xf^2=0[122X is a consequence of [22Xe^2=0[122X in the universal enveloping
  algebra of the simple Lie algebra of type A[22X_1[122X.[133X
  
  [33X[0;0YThe  function  [2XStrongNormalFormTraceDiff[102X  ([14X3.7-6[114X)  can  be used to trace the
  difference  between  an  element  and its strong normal form in the terms of
  [10Xextendedrels[110X.  Apparently,  in the first example the strong normal form of [10Xr[110X
  is [10Xr - s.pol=0[110X.[133X
  
  [4X[32X[104X
    [4Xgap> r := [[[2,2,2,2,1,1,1,1]],[1]];;[104X
    [4Xgap> s := StrongNormalFormTraceDiff(r, GB);;[104X
    [4X[104X
    [4Xgap> PrintNP(s.pol);[104X
    [4X f^4e^4 [104X
    [4Xgap> PrintTracePol(s);[104X
    [4X f^4G(4)e^2 [104X
    [4Xgap> PrintNP(AddNP(r,s.pol,1,-1));[104X
    [4X 0[104X
  [4X[32X[104X
  
  [33X[0;0YOne more example where the strong normal form is not zero.[133X
  
  [4X[32X[104X
    [4Xgap> r := [[[3,3,3]],[1]];;[104X
    [4Xgap> s := StrongNormalFormTraceDiff(r, GB);;[104X
    [4X[104X
    [4Xgap> PrintNP(s.pol);[104X
    [4X h^3 - h [104X
    [4Xgap> PrintTracePol(s);[104X
    [4X- G(1) - 1/2G(1)ef - 1/6eG(1)f + 1/3efG(1) + 1/2fG(1)e + 1/2feG(1) + G([104X
    [4X1)h^2 + 1/2G(1)efh + 1/2eG(1)fh + 1/3efG(1)h - 1/3eG(1)hf - 1/2fG(1)eh - 1/[104X
    [4X2feG(1)h - 1/6eG(1)ef^2 - 1/6e^2G(1)f^2 + 1/3efG(1)ef + 1/3efeG(1)f - 1/[104X
    [4X6ef^2G(1)e - 1/6ef^2eG(1) + 1/2G(2)f - 1/2fG(2) - 1/2G(2)fh + 1/2fG(2)h + 1/[104X
    [4X6eG(2)f^2 - 1/3efG(2)f + 1/6ef^2G(2) - 2/3eG(3)h + 1/3ehG(3) + 1/3e^2G(3)f - [104X
    [4X1/3efeG(3) - 1/2G(4)f^2 + fG(4)f - 1/2f^2G(4) + 1/2G(4)f^2h - fG(4)fh + 1/[104X
    [4X2f^2G(4)h - 1/6eG(4)f^3 + 1/2efG(4)f^2 - 1/2ef^2G(4)f + 1/6ef^3G(4) [104X
    [4Xgap> PrintNP(AddNP(r,s.pol,1,-1));[104X
    [4X h [104X
  [4X[32X[104X
  
  
  [1XA.25 [33X[0;0YSerre's exercise[133X[101X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,1);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,1);[104X
  [4X[32X[104X
  
  [33X[0;0YIn  Serre's book [Ser03] the following exercise can be found: Prove that the
  group  [22XâŸ¨  {a,b,c}âˆ£  {  bab^-1a^-2,  cbc^-1b^-2,  aca^-1c^-2}âŸ©[122X is the trivial
  group.  Here  we  solve  the  exercise  by  running the trace variant of the
  GrÃ¶bner  basis  function  with  input  the set of equations [22Xba - a^2 b, cb -
  b^2c,  ac  -  c^2a[122X together with relations forcing that [22Xa,b,c[122X are invertible
  with inverse [22XA,B,C[122X.[133X
  
  [4X[32X[104X
    [4Xgap> KI := [ [[[2,1],[1,1,2]],[1,-1]],[104X
    [4X>         [[[3,2],[2,2,3]],[1,-1]],[104X
    [4X>         [[[1,3],[3,3,1]],[1,-1]],[104X
    [4X>         [[[1,4], []],[1,-1]],[104X
    [4X>         [[[4,1], []],[1,-1]],[104X
    [4X>         [[[2,5], []],[1,-1]],[104X
    [4X>         [[[5,2], []],[1,-1]],[104X
    [4X>         [[[3,6], []],[1,-1]],[104X
    [4X>         [[[6,3], []],[1,-1]],[104X
    [4X>       ];;[104X
    [4Xgap> PrintNPList(KI);[104X
    [4X ba - a^2b [104X
    [4X cb - b^2c [104X
    [4X ac - c^2a [104X
    [4X ad - 1 [104X
    [4X da - 1 [104X
    [4X be - 1 [104X
    [4X eb - 1 [104X
    [4X cf - 1 [104X
    [4X fc - 1 [104X
  [4X[32X[104X
  
  [33X[0;0YWe  use  [2XSGrobnerTrace[102X  ([14X3.7-5[114X),  the  trace  variant  of  the GrÃ¶bner basis
  computation,[133X
  
  [4X[32X[104X
    [4Xgap> GB := SGrobnerTrace(KI);;[104X
    [4X#I  number of entered polynomials is 9[104X
    [4X#I  number of polynomials after reduction is 9[104X
    [4X#I  End of phase I[104X
    [4X#I  End of phase II[104X
    [4X#I  List of todo lengths is [ 9, 10, 11, 12, 14, 16, 18, 20, 21, 22, 24, 26, 28, 31, 34, 33, 35, 37, 40, [104X
    [4X  43, 46, 49, 52, 56, 59, 62, 61, 60, 64, 64, 65, 65, 68, 71, 76, 76, 80, 88, [104X
    [4X  93, 94, 99, 110, 115, 117, 131, 139, 146, 150, 158, 171, 186, 198, 206, [104X
    [4X  220, 229, 246, 260, 263, 102, 40, 19, 9, 3, 0 ][104X
    [4X#I  End of phase III[104X
    [4X#I  End of phase IV[104X
    [4X#I  The computation took 19308 msecs.[104X
  [4X[32X[104X
  
  [33X[0;0YThe  dimension  of the quotient algebra is 1, showing that the group algebra
  is 1-dimensional. This implies that the group with the above presentation is
  trivial.[133X
  
  [4X[32X[104X
    [4Xgap> GBpols := List([1..Length(GB)], x -> GB[x].pol);;[104X
    [4Xgap> PrintNPList(GBpols);[104X
    [4X a - 1 [104X
    [4X b - 1 [104X
    [4X c - 1 [104X
    [4X d - 1 [104X
    [4X e - 1 [104X
    [4X f - 1 [104X
    [4Xgap> DimQA(GBpols,6);[104X
    [4X1[104X
  [4X[32X[104X
  
  [33X[0;0YSince the output is large and might spoil the exercise, we confine ourselves
  to  the  printing first polynomial [10XGB[1][110X and the length of its trace. As the
  trace polynomial expresses [10XGB[1][110X, which is equal to [22Xa-1[122X, as a combination of
  the  binomials  in  [10XKI[110X,  it gives a proof that [22Xa[122X can be rewritten within the
  group  to  the  trivial element. It is easy to derive from this that [22Xb[122X and [22Xc[122X
  are also trivial in the group. This justifies the restriction to [10XGB[1][110X.[133X
  
  [4X[32X[104X
    [4Xgap> PrintNP(GB[1].pol);[104X
    [4X a - 1 [104X
    [4Xgap> Length(GB[1].trace);[104X
    [4X1119[104X
  [4X[32X[104X
  
  
  [1XA.26 [33X[0;0YBaur and Draisma's transformations[133X[101X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,0);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,0);[104X
  [4X[32X[104X
  
  [33X[0;0YThe  paper  [BD04]  by  Baur  and Draisma uses the computation of a quotient
  algebra  of  dimension 37, which we repeat here. The set of equations, after
  specialisation of the scalars to 1, is as follows.[133X
  
  [4X[32X[104X
    [4Xgap> KI := [ [[[2,2]],[1]],[104X
    [4X>         [[[1,1]],[1]],[104X
    [4X>         [[[3,3]],[1]],[104X
    [4X>         [[[1,2,1],[1]],[1,-1]],[104X
    [4X>         [[[2,1,2],[2]],[1,-1]],[104X
    [4X>         [[[3,2,3],[3]],[1,-1]],[104X
    [4X>         [[[2,3,2],[2]],[1,-1]],[104X
    [4X>         [[[1,3,1],[1]],[1,-1]],[104X
    [4X>         [[[3,1,3],[3]],[1,-1]],[104X
    [4X>         [[[1,2,3,1,2,3,1],[1,3,2,1,3,2,1],[1]],[1,1,-1]],[104X
    [4X>         [[[3,1,2,3,1,2,3],[3,2,1,3,2,1,3],[3]],[1,1,-1]],[104X
    [4X>         [[[2,3,1,2,3,1,2],[2,1,3,2,1,3,2],[2]],[1,1,-1]],[104X
    [4X>       ];;[104X
    [4Xgap> PrintNPList(KI);[104X
    [4X b^2 [104X
    [4X a^2 [104X
    [4X c^2 [104X
    [4X aba - a [104X
    [4X bab - b [104X
    [4X cbc - c [104X
    [4X bcb - b [104X
    [4X aca - a [104X
    [4X cac - c [104X
    [4X abcabca + acbacba - a [104X
    [4X cabcabc + cbacbac - c [104X
    [4X bcabcab + bacbacb - b [104X
  [4X[32X[104X
  
  [33X[0;0YWe  carry  out  a  traced  GrÃ¶bner basis computation by use of [2XSGrobnerTrace[102X
  ([14X3.7-5[114X), and form the usual GrÃ¶bner basis by extracting the polynomials from
  the traced polynomials using the field indicator [10X.pol[110X.[133X
  
  [4X[32X[104X
    [4Xgap> GBT := SGrobnerTrace(KI);;[104X
    [4Xgap> GB := List([1..Length(GBT)], i -> GBT[i].pol);;[104X
  [4X[32X[104X
  
  [33X[0;0YThe dimension of the quotient algebra is computable with [2XDimQA[102X ([14X3.5-2[114X).[133X
  
  [4X[32X[104X
    [4Xgap> DimQA(GB,3);[104X
    [4X37[104X
  [4X[32X[104X
  
  [33X[0;0YIn order to express the last GB element, viz.[133X
  
  [4X[32X[104X
    [4Xgap> PrintNP(GB[Length(GB)]);[104X
    [4X cabcabca + cbacba - ca [104X
  [4X[32X[104X
  
  [33X[0;0Yas a combination of elements of [10XKI[110X, we use [2XPrintTracePol[102X ([14X3.7-3[114X):[133X
  
  [4X[32X[104X
    [4Xgap> PrintTracePol(GBT[Length(GBT)]);  [104X
    [4X- G(9)bacba + cG(10) [104X
  [4X[32X[104X
  
  [33X[0;0YWe  compute  matrices for left multiplication by generators using [2XMatricesQA[102X
  ([14X3.5-4[114X)  and  determine  the  minimal  polynomial  of  the  sum of the three
  matrices.[133X
  
  [4X[32X[104X
    [4Xgap> B := BaseQA(GB,3,0);;[104X
    [4Xgap> M := MatricesQA(3,B,GB);;[104X
    [4Xgap> f := MinimalPolynomial(Rationals,M[1]+M[2]+M[3]);[104X
    [4Xx_1^7-6*x_1^5+9*x_1^3-3*x_1[104X
    [4Xgap> Factors(f);[104X
    [4X[ x_1, x_1^6-6*x_1^4+9*x_1^2-3 ][104X
  [4X[32X[104X
  
  [33X[0;0YIt  turns  out  that  there  are  three non-zero numbers [22Xu,v,w[122X such that the
  eigenvalues of the sum are [22X0,u,v,w,-u,-v,-w[122X. This is the information used in
  [BD04].[133X
  
  
  [1XA.27 [33X[0;0YThe cola gene puzzle[133X[101X
  
  [33X[0;0YA  prize  question  appearing in the January 2005 issue of the Dutch journal
  "Natuur  en  Techniek"  asked  for  a  DNA change of cows so that they could
  produce  Cola  instead  of milk. A team of genetic manipulators has tools to
  perform  the  following five DNA string operations. (Here the strings before
  and after the equality sign can be interchanged at will.)[133X
  
  [33X[0;0Yoperation 1: TCAT = T;[133X
  
  [33X[0;0Yoperation 2: GAG = AG;[133X
  
  [33X[0;0Yoperation 3: CTC = TC;[133X
  
  [33X[0;0Yoperation 4: AGTA = A;[133X
  
  [33X[0;0Yoperation 5: TAT = CT.[133X
  
  [33X[0;0YThe  first  question  is  to  show  how  they  can  transform  the milk gene
  TAGCTAGCTAGCT to the cola gene CTGACTGACT.[133X
  
  [33X[0;0YA  second  question  is  to  show  that  mad cow disease related retro virus
  CTGCTACTGACT can be avoided at all times. Can this be guaranteed?[133X
  
  [33X[0;0YWe  answer  these  questions  using the trace functions of the GrÃ¶bner basis
  package GBNP in Section [14X3.7[114X.[133X
  
  [33X[0;0YFirst  load the package and set the standard infolevel [2XInfoGBNP[102X ([14X4.2-1[114X) to 0
  and the time infolevel [2XInfoGBNPTime[102X ([14X4.3-1[114X) to 0 to minimize the printing of
  data  regarding  the computation (for more information about the info level,
  see Chapter [14X4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> LoadPackage("GBNP","0",false);;[104X
    [4Xgap> SetInfoLevel(InfoGBNP,0);[104X
    [4Xgap> SetInfoLevel(InfoGBNPTime,0);[104X
  [4X[32X[104X
  
  [33X[0;0YWe  introduce  the  free  algebra [10XALG[110X on the generators corresponding to the
  four  letters  in  the  DNA  code and express the milk gene and cola gene as
  monomials in this algebra.[133X
  
  [4X[32X[104X
    [4Xgap> ALG:=FreeAssociativeAlgebraWithOne(Rationals, "A", "C", "G", "T");;[104X
    [4Xgap> g:=GeneratorsOfAlgebra(ALG);;[104X
    [4Xgap> A:=g[2];;[104X
    [4Xgap> C:=g[3];;[104X
    [4Xgap> G:=g[4];;[104X
    [4Xgap> T:=g[5];;[104X
    [4X[104X
    [4Xgap> milk := T*A*G*C*T*A*G*C*T*A*G*C*T;;[104X
    [4Xgap> cola := C*T*G*A*C*T*G*A*C*T;;[104X
  [4X[32X[104X
  
  [33X[0;0YWe  next  enter  the  set  [22XK[122X  of  binomials  [22Xx-y[122X  corresponding  to the five
  operations  [22Xx = y[122X listed above. We enter the binomials as members of [10XALG[110X and
  let [10XKNP[110X be the corresponding set of NP polynomials.[133X
  
  [4X[32X[104X
    [4Xgap> rule1 := T*C*A*T - T;;[104X
    [4Xgap> rule2 :=  G*A*G -  A*G;;[104X
    [4Xgap> rule3 :=  C*T*C - T*C;;[104X
    [4Xgap> rule4 := A*G*T*A - A;;[104X
    [4Xgap> rule5 := T*A*T -  C*T;;[104X
    [4Xgap> K := [rule1,rule2,rule3,rule4,rule5];;[104X
    [4Xgap> KNP := List(K,x-> GP2NP(x));;[104X
  [4X[32X[104X
  
  [33X[0;0YWe  stipulate  how  the  variables  will  be  printed  and  print  [10XKNP[110X.  See
  [2XPrintNPList[102X ([14X3.2-3[114X).[133X
  
  [4X[32X[104X
    [4Xgap> GBNP.ConfigPrint("A","C","G","T");[104X
    [4Xgap> PrintNPList(KNP);[104X
    [4X TCAT - T [104X
    [4X GAG - AG [104X
    [4X CTC - TC [104X
    [4X AGTA - A [104X
    [4X TAT - CT [104X
  [4X[32X[104X
  
  [33X[0;0YNow calculate the usual GrÃ¶bner basis with [2XSGrobner[102X ([14X3.4-2[114X).[133X
  
  [4X[32X[104X
    [4Xgap> GB := SGrobner(KNP);;[104X
  [4X[32X[104X
  
  [33X[0;0YCompare milk and cola after taking their strong normal forms with respect to
  [10XGB[110X  using  [2XStrongNormalFormNP[102X  ([14X3.5-6[114X).  We  oberve  that they have the same
  normal  form  and so there is a way to transform the milk gene into the cola
  gene.[133X
  
  [4X[32X[104X
    [4Xgap> milkNP := GP2NP(milk);;[104X
    [4Xgap> colaNP := GP2NP(cola);;[104X
    [4Xgap> milkRed := NP2GP(StrongNormalFormNP(milkNP,GB),ALG);[104X
    [4X(1)*T[104X
    [4Xgap> colaRed := NP2GP(StrongNormalFormNP(colaNP,GB),ALG);[104X
    [4X(1)*T[104X
  [4X[32X[104X
  
  [33X[0;0YBut this information does not yet show us how to perform the transformation.
  To this end we calculate the GrÃ¶bner basis with trace information, using the
  function [2XSGrobnerTrace[102X ([14X3.7-5[114X).[133X
  
  [4X[32X[104X
    [4Xgap> GTrace := SGrobnerTrace(KNP);;[104X
  [4X[32X[104X
  
  [33X[0;0YThe full trace can be printed with [2XPrintTraceList[102X ([14X3.7-2[114X), but we only print
  the relations (and no trace) by invoking [2XPrintNPListTrace[102X ([14X3.7-4[114X).[133X
  
  [4X[32X[104X
    [4Xgap> PrintNPListTrace(GTrace);[104X
    [4X CT - T [104X
    [4X GA - A [104X
    [4X AGT - AT [104X
    [4X ATA - A [104X
    [4X TAT - T [104X
    [4X TCA - TA [104X
  [4X[32X[104X
  
  [33X[0;0YIn  order  to  display  a  proof  that [22Xmilk-cola[122X belongs to the ideal we use
  [2XStrongNormalFormTraceDiff[102X ([14X3.7-6[114X), The result is a record, [10Xp[110X say, containing
  [10Xmilk-cola[110X  in  the  field [10Xp.pol[110X (the normal form will be subtracted from the
  argument  [10Xmilk-cola[110X to obtain [10Xp.pol[110X, but the normal form is zero because the
  argument belongs to the ideal generated by [10XK[110X). The other field of the record
  [10Xp[110X  is  [10Xp.trace[110X,  the  traced  polynomial,  which is best displayed by use of
  [2XPrintTracePol[102X ([14X3.7-3[114X).[133X
  
  [4X[32X[104X
    [4Xgap> p := StrongNormalFormTraceDiff(CleanNP(GP2NP(milk-cola)),GTrace);;[104X
    [4Xgap> NP2GP(p.pol,ALG);[104X
    [4X(1)*(T*A*G*C)^3*T+(-1)*(C*T*G*A)^2*C*T[104X
    [4Xgap> PrintTracePol(p);[104X
    [4X- TGATGAG(1) + TAGG(1)ATAT - TATATAGG(1) - TGAG(1)GACT + TGATGACG(1) - G([104X
    [4X1)GACTGACT - TAGCG(1)ATAT - TATAGG(1)AGT + TATATAGCG(1) + TGACG(1)GACT + CG([104X
    [4X1)GACTGACT - TAGG(1)AGTAGT + TAGTAGTAGG(1) + TATAGCG(1)AGT + TAGCG([104X
    [4X1)AGTAGT + TAGTAGG(1)AGCT - TAGTAGTAGCG(1) + TAGG(1)AGCTAGCT - TAGTAGCG([104X
    [4X1)AGCT - TAGCG(1)AGCTAGCT - TATG(2)TAT - TG(2)TATGAT - TGATGAG(3)AT + TAGG([104X
    [4X3)ATATAT - TATATAGG(3)AT - TGAG(3)ATGACT - G(3)ATGACTGACT - TATAGG([104X
    [4X3)ATAGT - TAGG(3)ATAGTAGT + TAGTAGTAGG(3)AT + TAGTAGG(3)ATAGCT + TAGG([104X
    [4X3)ATAGCTAGCT - TATG(4)T + TG(4)TAT + TATGG(4)T - TG(4)TGAT + TATATG(4)T + TGG([104X
    [4X4)TGAT - TG(4)TATAT + TATG(4)TAGT + TG(4)TAGTAGT + TAGG(5)ATAT - TATATAGG([104X
    [4X5) - TATAGG(5)AGT - TAGG(5)AGTAGT [104X
  [4X[32X[104X
  
  [33X[0;0YIn  order  to  give a precise answer to the first question we need to work a
  little  on  [10Xp.trace[110X.  To  do  so, we introduce the following function, which
  creates  the  NP polynomial corresponding to the [10Xi[110X-th term in the expression
  [10Xp.trace[110X  of  [10Xp.pol[110X  as a linear combination of members of [10XKNP[110X. It is used to
  obtain the list [10XEvalList[110X of polynomials for all [10Xi[110X.[133X
  
  [4X[32X[104X
    [4Xgap> EvalTracePol := function(i,p,KNP)[104X
    [4X>   local x,pi;[104X
    [4X>   pi := p.trace[i];[104X
    [4X>   x := BimulNP(pi[1],KNP[pi[2]],pi[3]);[104X
    [4X>   return  [x[1],pi[4]*x[2]];[104X
    [4X> end;;[104X
    [4X[104X
    [4Xgap> lev :=  Length(p.trace);;[104X
    [4Xgap> EvalList := List([1..lev], y -> CleanNP(EvalTracePol(y,p,KNP)));;[104X
  [4X[32X[104X
  
  [33X[0;0YIn order to find the rewrite from the milk gene to the cola gene as required
  for an answer to the first question, we match leading terms recursively.[133X
  
  [4X[32X[104X
    [4Xgap> UnusedIndices := Set([1..lev]);;[104X
    [4Xgap> RunningTerm :=  milkNP[1][1];;[104X
    [4Xgap> stepno := 0;;[104X
    [4Xgap> NP2GP(milkNP,ALG);[104X
    [4X(1)*(T*A*G*C)^3*T[104X
    [4Xgap> while Length(UnusedIndices) > 0 do[104X
    [4X>   i := 0;[104X
    [4X>   notfnd := true;[104X
    [4X>   while i < lev and notfnd do [104X
    [4X>     i := i+1;[104X
    [4X>     if EvalList[i][1][1] = RunningTerm and i in UnusedIndices then [104X
    [4X>        notfnd := false;[104X
    [4X>        RemoveSet(UnusedIndices, i);[104X
    [4X>        RunningTerm :=  EvalList[i][1][2];[104X
    [4X>        stepno := stepno+1;[104X
    [4X>     elif EvalList[i][1][2] = RunningTerm and i in UnusedIndices then [104X
    [4X>        notfnd := false;[104X
    [4X>        RemoveSet(UnusedIndices, i);[104X
    [4X>        RunningTerm :=  EvalList[i][1][1];[104X
    [4X>        stepno := stepno+1;[104X
    [4X>     fi; [104X
    [4X>   od;[104X
    [4X>   if i = lev and notfnd = true then Print("error not fnd in"); fi;[104X
    [4X>   Print(" -(",stepno,")- ");[104X
    [4X>   PrintNP([[p.trace[i][1]],[1]]);[104X
    [4X>   Print("         K[",p.trace[i][2],"]\n        ");[104X
    [4X>   PrintNP([[p.trace[i][3]],[1]]);[104X
    [4X>   Print(" --> ");[104X
    [4X>   PrintNP([[EvalList[i][1][2]],[1]]);[104X
    [4X> od;;[104X
    [4X -(1)-  TAGC [104X
    [4X         K[1][104X
    [4X         AGCTAGCT [104X
    [4X -->  TAGCTAGCTAGCT [104X
    [4X -(2)-  TAG [104X
    [4X         K[3][104X
    [4X         ATAGCTAGCT [104X
    [4X -->  TAGTCATAGCTAGCT [104X
    [4X -(3)-  TAG [104X
    [4X         K[1][104X
    [4X         AGCTAGCT [104X
    [4X -->  TAGTAGCTAGCT [104X
    [4X -(4)-  TAGTAGC [104X
    [4X         K[1][104X
    [4X         AGCT [104X
    [4X -->  TAGTAGCTAGCT [104X
    [4X -(5)-  TAGTAG [104X
    [4X         K[3][104X
    [4X         ATAGCT [104X
    [4X -->  TAGTAGTCATAGCT [104X
    [4X -(6)-  TAGTAG [104X
    [4X         K[1][104X
    [4X         AGCT [104X
    [4X -->  TAGTAGTAGCT [104X
    [4X -(7)-  TAGTAGTAGC [104X
    [4X         K[1][104X
    [4X         1 [104X
    [4X -->  TAGTAGTAGCT [104X
    [4X -(8)-  TAGTAGTAG [104X
    [4X         K[3][104X
    [4X         AT [104X
    [4X -->  TAGTAGTAGTCAT [104X
    [4X -(9)-  TAGTAGTAG [104X
    [4X         K[1][104X
    [4X         1 [104X
    [4X -->  TAGTAGTAGT [104X
    [4X -(10)-  TAG [104X
    [4X         K[1][104X
    [4X         AGTAGT [104X
    [4X -->  TAGTAGTAGT [104X
    [4X -(11)-  TAG [104X
    [4X         K[3][104X
    [4X         ATAGTAGT [104X
    [4X -->  TAGTCATAGTAGT [104X
    [4X -(12)-  TAGC [104X
    [4X         K[1][104X
    [4X         AGTAGT [104X
    [4X -->  TAGCTAGTAGT [104X
    [4X -(13)-  TAG [104X
    [4X         K[5][104X
    [4X         AGTAGT [104X
    [4X -->  TAGCTAGTAGT [104X
    [4X -(14)-  T [104X
    [4X         K[4][104X
    [4X         TAGTAGT [104X
    [4X -->  TATAGTAGT [104X
    [4X -(15)-  TATAG [104X
    [4X         K[1][104X
    [4X         AGT [104X
    [4X -->  TATAGTAGT [104X
    [4X -(16)-  TATAG [104X
    [4X         K[3][104X
    [4X         ATAGT [104X
    [4X -->  TATAGTCATAGT [104X
    [4X -(17)-  TATAGC [104X
    [4X         K[1][104X
    [4X         AGT [104X
    [4X -->  TATAGCTAGT [104X
    [4X -(18)-  TATAG [104X
    [4X         K[5][104X
    [4X         AGT [104X
    [4X -->  TATAGCTAGT [104X
    [4X -(19)-  TAT [104X
    [4X         K[4][104X
    [4X         TAGT [104X
    [4X -->  TATATAGT [104X
    [4X -(20)-  TATATAG [104X
    [4X         K[1][104X
    [4X         1 [104X
    [4X -->  TATATAGT [104X
    [4X -(21)-  TATATAG [104X
    [4X         K[3][104X
    [4X         AT [104X
    [4X -->  TATATAGTCAT [104X
    [4X -(22)-  TATATAGC [104X
    [4X         K[1][104X
    [4X         1 [104X
    [4X -->  TATATAGCT [104X
    [4X -(23)-  TATATAG [104X
    [4X         K[5][104X
    [4X         1 [104X
    [4X -->  TATATAGCT [104X
    [4X -(24)-  TATAT [104X
    [4X         K[4][104X
    [4X         T [104X
    [4X -->  TATATAT [104X
    [4X -(25)-  T [104X
    [4X         K[4][104X
    [4X         TATAT [104X
    [4X -->  TATATAT [104X
    [4X -(26)-  TAG [104X
    [4X         K[5][104X
    [4X         ATAT [104X
    [4X -->  TAGCTATAT [104X
    [4X -(27)-  TAGC [104X
    [4X         K[1][104X
    [4X         ATAT [104X
    [4X -->  TAGCTATAT [104X
    [4X -(28)-  TAG [104X
    [4X         K[3][104X
    [4X         ATATAT [104X
    [4X -->  TAGTCATATAT [104X
    [4X -(29)-  TAG [104X
    [4X         K[1][104X
    [4X         ATAT [104X
    [4X -->  TAGTATAT [104X
    [4X -(30)-  T [104X
    [4X         K[4][104X
    [4X         TAT [104X
    [4X -->  TATAT [104X
    [4X -(31)-  TAT [104X
    [4X         K[4][104X
    [4X         T [104X
    [4X -->  TATAT [104X
    [4X -(32)-  TAT [104X
    [4X         K[2][104X
    [4X         TAT [104X
    [4X -->  TATAGTAT [104X
    [4X -(33)-  TATG [104X
    [4X         K[4][104X
    [4X         T [104X
    [4X -->  TATGAT [104X
    [4X -(34)-  T [104X
    [4X         K[4][104X
    [4X         TGAT [104X
    [4X -->  TATGAT [104X
    [4X -(35)-  T [104X
    [4X         K[2][104X
    [4X         TATGAT [104X
    [4X -->  TAGTATGAT [104X
    [4X -(36)-  TG [104X
    [4X         K[4][104X
    [4X         TGAT [104X
    [4X -->  TGATGAT [104X
    [4X -(37)-  TGATGA [104X
    [4X         K[1][104X
    [4X         1 [104X
    [4X -->  TGATGAT [104X
    [4X -(38)-  TGATGA [104X
    [4X         K[3][104X
    [4X         AT [104X
    [4X -->  TGATGATCAT [104X
    [4X -(39)-  TGATGAC [104X
    [4X         K[1][104X
    [4X         1 [104X
    [4X -->  TGATGACT [104X
    [4X -(40)-  TGA [104X
    [4X         K[1][104X
    [4X         GACT [104X
    [4X -->  TGATGACT [104X
    [4X -(41)-  TGA [104X
    [4X         K[3][104X
    [4X         ATGACT [104X
    [4X -->  TGATCATGACT [104X
    [4X -(42)-  TGAC [104X
    [4X         K[1][104X
    [4X         GACT [104X
    [4X -->  TGACTGACT [104X
    [4X -(43)-  1 [104X
    [4X         K[1][104X
    [4X         GACTGACT [104X
    [4X -->  TGACTGACT [104X
    [4X -(44)-  1 [104X
    [4X         K[3][104X
    [4X         ATGACTGACT [104X
    [4X -->  TCATGACTGACT [104X
    [4X -(45)-  C [104X
    [4X         K[1][104X
    [4X         GACTGACT [104X
    [4X -->  CTGACTGACT [104X
    [4Xgap> NP2GP(colaNP,ALG);[104X
    [4X(1)*(C*T*G*A)^2*C*T[104X
  [4X[32X[104X
  
  [33X[0;0YAnd now the second question regarding the retro virus.[133X
  
  [4X[32X[104X
    [4Xgap> retro := C*T*G*C*T*A*C*T*G*A*C*T;;[104X
  [4X[32X[104X
  
  [33X[0;0YWe  compute  the Strong Normal Form [2XStrongNormalFormNP[102X ([14X3.5-6[114X) of [10Xretro[110X with
  respect  to [10XGB[110X. As it is [10XTGT[110X, distinct to [10XT[110X, the strong normal form of milk,
  there is no transformation from milk to retro.[133X
  
  [4X[32X[104X
    [4Xgap> NP2GP(StrongNormalFormNP(CleanNP(GP2NP(retro)),GB), ALG);[104X
    [4X(1)*T*G*T[104X
  [4X[32X[104X
  
  [33X[0;0YOf   course,   here   too   we   can  verify  the  reduction,  by  computing
  [2XStrongNormalFormTraceDiff[102X ([14X3.7-6[114X) with input the NP polynomial corresponding
  to  [10Xretro[110X  and  with  respect to [10XK[110X; it is called [10XretroTrace[110X. The symbol [10XG[110X in
  expression  like  [10XG(2)[110X  are  not  to  be  confused with the single symbols [10XG[110X
  representing the DNA element.[133X
  
  [4X[32X[104X
    [4Xgap> retroTrace := StrongNormalFormTraceDiff(CleanNP(GP2NP(retro)),GTrace);;[104X
    [4Xgap> PrintTracePol(retroTrace);[104X
    [4X TGG(1) - TGC^2G(1) - TGTAG(1) + TGTACG(1) + TGTAGG(1)AT + TGTATGAG([104X
    [4X1) + TGTAG(1)GACT - TGTAGCG(1)AT - TGTATGACG(1) + TGG(1)ACTGACT - TGTACG([104X
    [4X1)GACT + G(1)GCTACTGACT - TGCG(1)ACTGACT - CG(1)GCTACTGACT + TGTATG([104X
    [4X2)TAT + TGG(3)AT + TGCG(3)AT - TGTAG(3)AT + TGTAGG(3)ATAT + TGTATGAG([104X
    [4X3)AT + TGTAG(3)ATGACT + TGG(3)ATACTGACT + G(3)ATGCTACTGACT + TGTG([104X
    [4X4)T + TGTATG(4)T - TGTG(4)TAT - TGTATGG(4)T + TGCG(5) + TGG(5)AT - TGTAG([104X
    [4X5) + TGTAGG(5)AT [104X
  [4X[32X[104X
  
